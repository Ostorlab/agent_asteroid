"""Unit tests for GoAnywhereDeserializationExploit: CVE-2025-10035"""

from unittest import mock
import requests.exceptions
from agent.exploits import cve_2025_10035
from agent import definitions


def testCheck_WhenVulnerableVersion_ShouldReportVulnerability() -> None:
    """Test check method with a vulnerable GoAnywhere version."""
    exploit = cve_2025_10035.GoAnywhereDeserializationExploit()
    target = definitions.Target("https", "localhost", 443)
    mock_response = mock.Mock()
    mock_response.text = """
    <html>
        <title>GoAnywhere MFT Login</title>
        <body>
            <h1>GoAnywhere 7.7.0</h1>
            <form>Login form here</form>
        </body>
    </html>
    """
    mock_response.status_code = 200

    with mock.patch.object(exploit.session, "get", return_value=mock_response):
        vulns = exploit.check(target)

        assert len(vulns) == 1
        assert "7.7.0" in vulns[0].technical_detail
        assert cve_2025_10035.VULNERABILITY_REFERENCE in vulns[0].technical_detail


def testCheck_WhenNotVulnerableVersion_ShouldNotReportVulnerability() -> None:
    """Test check method with a non-vulnerable GoAnywhere version."""
    exploit = cve_2025_10035.GoAnywhereDeserializationExploit()
    target = definitions.Target("https", "localhost", 443)
    mock_response = mock.Mock()
    mock_response.text = """
    <html>
        <title>GoAnywhere MFT Login</title>
        <body>
            <h1>GoAnywhere 7.8.5</h1>
            <form>Login form here</form>
        </body>
    </html>
    """
    mock_response.status_code = 200

    with mock.patch.object(exploit.session, "get", return_value=mock_response):
        vulns = exploit.check(target)

        assert len(vulns) == 0


def testCheck_WhenSustainedSupportVulnerable_ShouldReportVulnerability() -> None:
    """Test check method with a vulnerable sustained support version."""
    exploit = cve_2025_10035.GoAnywhereDeserializationExploit()
    target = definitions.Target("https", "localhost", 443)
    mock_response = mock.Mock()
    mock_response.text = """
    <html>
        <title>GoAnywhere MFT Login</title>
        <body>
            <div>GoAnywhere 7.6.2</div>
            <form>Login form here</form>
        </body>
    </html>
    """
    mock_response.status_code = 200

    with mock.patch.object(exploit.session, "get", return_value=mock_response):
        vulns = exploit.check(target)

        assert len(vulns) == 1
        assert "7.6.2" in vulns[0].technical_detail


def testCheck_WhenInvalidVersion_ShouldNotReportVulnerability() -> None:
    """Test check method when version cannot be extracted."""
    exploit = cve_2025_10035.GoAnywhereDeserializationExploit()
    target = definitions.Target("https", "localhost", 443)

    # Mock response containing GoAnywhere but no valid version
    mock_response = mock.Mock()
    mock_response.text = """
    <html>
        <title>GoAnywhere MFT Login</title>
        <body>
            <h1>GoAnywhere Managed File Transfer</h1>
            <p>Version information not available</p>
            <form>Login form here</form>
        </body>
    </html>
    """
    mock_response.status_code = 200

    with mock.patch.object(exploit.session, "get", return_value=mock_response):
        vulns = exploit.check(target)

        assert len(vulns) == 0


def testCheck_WhenNotGoAnywhereResponse_ShouldNotReportVulnerability() -> None:
    """Test check method with a response that is not GoAnywhere."""
    exploit = cve_2025_10035.GoAnywhereDeserializationExploit()
    target = definitions.Target("https", "localhost", 443)
    mock_response = mock.Mock()
    mock_response.text = """
    <html>
        <title>Apache Tomcat</title>
        <body>
            <h1>Apache Tomcat Manager</h1>
            <p>Welcome to the Tomcat Manager</p>
        </body>
    </html>
    """
    mock_response.status_code = 200

    with mock.patch.object(exploit.session, "get", return_value=mock_response):
        vulns = exploit.check(target)

        assert len(vulns) == 0


def testCheck_WhenRequestException_ShouldNotReportVulnerability() -> None:
    """Test check method when HTTP request fails."""
    exploit = cve_2025_10035.GoAnywhereDeserializationExploit()
    target = definitions.Target("https", "localhost", 443)

    with mock.patch.object(
        exploit.session,
        "get",
        side_effect=requests.exceptions.ConnectionError("Connection refused"),
    ):
        vulns = exploit.check(target)

        assert len(vulns) == 0


def testAccept_WhenGoAnywhereDetected_ShouldReturnTrue() -> None:
    """Test accept method when GoAnywhere is detected."""
    exploit = cve_2025_10035.GoAnywhereDeserializationExploit()
    target = definitions.Target("https", "localhost", 443)

    # Mock response containing GoAnywhere patterns
    mock_response = mock.Mock()
    mock_response.text = """
    <html>
        <title>GoAnywhere MFT Login</title>
        <body>
            <h1>Fortra GoAnywhere Managed File Transfer</h1>
        </body>
    </html>
    """
    mock_response.status_code = 200

    with mock.patch.object(exploit.session, "get", return_value=mock_response):
        result = exploit.accept(target)

        assert result is True


def testAccept_WhenGoAnywhereNotDetected_ShouldReturnFalse() -> None:
    """Test accept method when GoAnywhere is not detected."""
    exploit = cve_2025_10035.GoAnywhereDeserializationExploit()
    target = definitions.Target("https", "localhost", 443)

    # Mock response from different product
    mock_response = mock.Mock()
    mock_response.text = """
    <html>
        <title>FileZilla Server</title>
        <body>
            <h1>FileZilla Server Web Interface</h1>
        </body>
    </html>
    """
    mock_response.status_code = 200

    with mock.patch.object(exploit.session, "get", return_value=mock_response):
        result = exploit.accept(target)

        assert result is False


def testAccept_WhenRequestException_ShouldReturnFalse() -> None:
    """Test accept method when HTTP request fails."""
    exploit = cve_2025_10035.GoAnywhereDeserializationExploit()
    target = definitions.Target("https", "localhost", 443)

    with mock.patch.object(
        exploit.session,
        "get",
        side_effect=requests.exceptions.Timeout("Request timeout"),
    ):
        result = exploit.accept(target)

        assert result is False
