"""Unit tests for GoAnywhereDeserializationExploit: CVE-2025-10035"""

import re
from unittest import mock
import requests.exceptions
from agent.exploits import cve_2025_10035
from agent import definitions


def testCheck_WhenVulnerableVersion_ShouldReportVulnerability() -> None:
    """Test check method with a vulnerable GoAnywhere version."""
    exploit = cve_2025_10035.GoAnywhereDeserializationExploit()
    target = definitions.Target("https", "localhost", 443)
    mock_response = mock.Mock()
    mock_response.text = """
    <html>
        <title>GoAnywhere MFT Login</title>
        <body>
            <h1>GoAnywhere 7.7.0</h1>
            <form>Login form here</form>
        </body>
    </html>
    """
    mock_response.status_code = 200

    with mock.patch.object(exploit.session, "get", return_value=mock_response):
        vulns = exploit.check(target)

        assert len(vulns) == 1
        assert "7.7.0" in vulns[0].technical_detail
        assert cve_2025_10035.VULNERABILITY_REFERENCE in vulns[0].technical_detail


def testCheck_WhenNotVulnerableVersion_ShouldNotReportVulnerability() -> None:
    """Test check method with a non-vulnerable GoAnywhere version."""
    exploit = cve_2025_10035.GoAnywhereDeserializationExploit()
    target = definitions.Target("https", "localhost", 443)
    mock_response = mock.Mock()
    mock_response.text = """
    <html>
        <title>GoAnywhere MFT Login</title>
        <body>
            <h1>GoAnywhere 7.8.5</h1>
            <form>Login form here</form>
        </body>
    </html>
    """
    mock_response.status_code = 200

    with mock.patch.object(exploit.session, "get", return_value=mock_response):
        vulns = exploit.check(target)

        assert len(vulns) == 0


def testCheck_WhenSustainedSupportVulnerable_ShouldReportVulnerability() -> None:
    """Test check method with a vulnerable sustained support version."""
    exploit = cve_2025_10035.GoAnywhereDeserializationExploit()
    target = definitions.Target("https", "localhost", 443)
    mock_response = mock.Mock()
    mock_response.text = """
    <html>
        <title>GoAnywhere MFT Login</title>
        <body>
            <div>GoAnywhere 7.6.2</div>
            <form>Login form here</form>
        </body>
    </html>
    """
    mock_response.status_code = 200

    with mock.patch.object(exploit.session, "get", return_value=mock_response):
        vulns = exploit.check(target)

        assert len(vulns) == 1
        assert "7.6.2" in vulns[0].technical_detail


def testCheck_WhenInvalidVersion_ShouldNotReportVulnerability() -> None:
    """Test check method when version cannot be extracted."""
    exploit = cve_2025_10035.GoAnywhereDeserializationExploit()
    target = definitions.Target("https", "localhost", 443)

    # Mock response containing GoAnywhere but no valid version
    mock_response = mock.Mock()
    mock_response.text = """
    <html>
        <title>GoAnywhere MFT Login</title>
        <body>
            <h1>GoAnywhere Managed File Transfer</h1>
            <p>Version information not available</p>
            <form>Login form here</form>
        </body>
    </html>
    """
    mock_response.status_code = 200

    with mock.patch.object(exploit.session, "get", return_value=mock_response):
        vulns = exploit.check(target)

        assert len(vulns) == 0


def testCheck_WhenNotGoAnywhereResponse_ShouldNotReportVulnerability() -> None:
    """Test check method with a response that is not GoAnywhere."""
    exploit = cve_2025_10035.GoAnywhereDeserializationExploit()
    target = definitions.Target("https", "localhost", 443)
    mock_response = mock.Mock()
    mock_response.text = """
    <html>
        <title>Apache Tomcat</title>
        <body>
            <h1>Apache Tomcat Manager</h1>
            <p>Welcome to the Tomcat Manager</p>
        </body>
    </html>
    """
    mock_response.status_code = 200

    with mock.patch.object(exploit.session, "get", return_value=mock_response):
        vulns = exploit.check(target)

        assert len(vulns) == 0


def testCheck_WhenRequestException_ShouldNotReportVulnerability() -> None:
    """Test check method when HTTP request fails."""
    exploit = cve_2025_10035.GoAnywhereDeserializationExploit()
    target = definitions.Target("https", "localhost", 443)

    with mock.patch.object(
        exploit.session,
        "get",
        side_effect=requests.exceptions.ConnectionError("Connection refused"),
    ):
        vulns = exploit.check(target)

        assert len(vulns) == 0


def testAccept_WhenGoAnywhereDetected_ShouldReturnTrue() -> None:
    """Test accept method when GoAnywhere is detected."""
    exploit = cve_2025_10035.GoAnywhereDeserializationExploit()
    target = definitions.Target("https", "localhost", 443)
    mock_response = mock.Mock()
    mock_response.text = """
    <html>
        <title>GoAnywhere MFT Login</title>
        <body>
            <h1>Fortra GoAnywhere Managed File Transfer</h1>
        </body>
    </html>
    """
    mock_response.status_code = 200

    with mock.patch.object(exploit.session, "get", return_value=mock_response):
        result = exploit.accept(target)

        assert result is True


def testAccept_WhenGoAnywhereNotDetected_ShouldReturnFalse() -> None:
    """Test accept method when GoAnywhere is not detected."""
    exploit = cve_2025_10035.GoAnywhereDeserializationExploit()
    target = definitions.Target("https", "localhost", 443)
    mock_response = mock.Mock()
    mock_response.text = """
    <html>
        <title>FileZilla Server</title>
        <body>
            <h1>FileZilla Server Web Interface</h1>
        </body>
    </html>
    """
    mock_response.status_code = 200

    with mock.patch.object(exploit.session, "get", return_value=mock_response):
        result = exploit.accept(target)

        assert result is False


def testAccept_WhenRequestException_ShouldReturnFalse() -> None:
    """Test accept method when HTTP request fails."""
    exploit = cve_2025_10035.GoAnywhereDeserializationExploit()
    target = definitions.Target("https", "localhost", 443)

    with mock.patch.object(
        exploit.session,
        "get",
        side_effect=requests.exceptions.Timeout("Request timeout"),
    ):
        result = exploit.accept(target)

        assert result is False


def testCheck_WhenEmptyResponseText_ShouldNotReportVulnerability() -> None:
    """Test check method when response text is empty string."""
    exploit = cve_2025_10035.GoAnywhereDeserializationExploit()
    target = definitions.Target("https", "localhost", 443)
    mock_response = mock.Mock()
    mock_response.text = ""
    mock_response.status_code = 200

    with mock.patch.object(exploit.session, "get", return_value=mock_response):
        vulns = exploit.check(target)

        assert len(vulns) == 0


def testCheck_WhenWhitespaceOnlyResponseText_ShouldNotReportVulnerability() -> None:
    """Test check method when response text contains only whitespace."""
    exploit = cve_2025_10035.GoAnywhereDeserializationExploit()
    target = definitions.Target("https", "localhost", 443)
    mock_response = mock.Mock()
    mock_response.text = "   \n\t  \r\n  "
    mock_response.status_code = 200

    with mock.patch.object(exploit.session, "get", return_value=mock_response):
        vulns = exploit.check(target)

        assert len(vulns) == 0


def testCheck_WhenNoneResponseText_ShouldNotReportVulnerability() -> None:
    """Test check method when response text is None."""
    exploit = cve_2025_10035.GoAnywhereDeserializationExploit()
    target = definitions.Target("https", "localhost", 443)
    mock_response = mock.Mock()
    mock_response.text = None
    mock_response.status_code = 200

    with mock.patch.object(exploit.session, "get", return_value=mock_response):
        vulns = exploit.check(target)

        assert len(vulns) == 0


def testAccept_WhenEmptyResponseText_ShouldReturnFalse() -> None:
    """Test accept method when response text is empty."""
    exploit = cve_2025_10035.GoAnywhereDeserializationExploit()
    target = definitions.Target("https", "localhost", 443)
    mock_response = mock.Mock()
    mock_response.text = ""
    mock_response.status_code = 200

    with mock.patch.object(exploit.session, "get", return_value=mock_response):
        result = exploit.accept(target)

        assert result is False


def testAccept_WhenNoneResponseText_ShouldReturnFalse() -> None:
    """Test accept method when response text is None."""
    exploit = cve_2025_10035.GoAnywhereDeserializationExploit()
    target = definitions.Target("https", "localhost", 443)
    mock_response = mock.Mock()
    mock_response.text = None
    mock_response.status_code = 200

    with mock.patch.object(exploit.session, "get", return_value=mock_response):
        result = exploit.accept(target)

        assert result is False


def testCheck_WhenRegexErrorInGoAnywhereDetection_ShouldNotReportVulnerability() -> (
    None
):
    """Test check method when regex error occurs during GoAnywhere detection."""
    exploit = cve_2025_10035.GoAnywhereDeserializationExploit()
    target = definitions.Target("https", "localhost", 443)
    mock_response = mock.Mock()
    mock_response.text = "GoAnywhere MFT Login"
    mock_response.status_code = 200

    with (
        mock.patch.object(exploit.session, "get", return_value=mock_response),
        mock.patch("re.search", side_effect=re.error("Invalid regex pattern")),
    ):
        vulns = exploit.check(target)

        assert len(vulns) == 0


def testAccept_WhenRegexErrorInGoAnywhereDetection_ShouldReturnFalse() -> None:
    """Test accept method when regex error occurs during GoAnywhere detection."""
    exploit = cve_2025_10035.GoAnywhereDeserializationExploit()
    target = definitions.Target("https", "localhost", 443)
    mock_response = mock.Mock()
    mock_response.text = "GoAnywhere MFT Login"
    mock_response.status_code = 200

    with (
        mock.patch.object(exploit.session, "get", return_value=mock_response),
        mock.patch("re.search", side_effect=re.error("Invalid regex pattern")),
    ):
        result = exploit.accept(target)

        assert result is False


def testCheck_WhenRegexErrorInVersionExtraction_ShouldNotReportVulnerability() -> None:
    """Test check method when regex error occurs during version extraction."""
    exploit = cve_2025_10035.GoAnywhereDeserializationExploit()
    target = definitions.Target("https", "localhost", 443)
    mock_response = mock.Mock()
    mock_response.text = "GoAnywhere MFT 7.7.0"
    mock_response.status_code = 200

    def mock_re_search(pattern: str, string: str, flags: int = 0) -> mock.Mock | None:
        for goa_pattern in cve_2025_10035.GOANYWHERE_PATTERNS:
            if pattern == goa_pattern:
                return mock.Mock()

        if "GoAnywhere" in str(pattern) and "([0-9]" in str(pattern):
            raise re.error("Invalid regex in version pattern")

        return None

    with (
        mock.patch.object(exploit.session, "get", return_value=mock_response),
        mock.patch("re.search", side_effect=mock_re_search),
    ):
        vulns = exploit.check(target)

        assert len(vulns) == 0


def testCheck_WhenValueErrorInVersionParsing_ShouldNotReportVulnerability() -> None:
    """Test check method when ValueError occurs during version parsing."""
    exploit = cve_2025_10035.GoAnywhereDeserializationExploit()
    target = definitions.Target("https", "localhost", 443)
    mock_response = mock.Mock()
    mock_response.text = "GoAnywhere MFT 7.7.invalid"
    mock_response.status_code = 200

    with (
        mock.patch.object(exploit.session, "get", return_value=mock_response),
        mock.patch(
            "packaging.version.parse", side_effect=ValueError("Invalid version format")
        ),
    ):
        vulns = exploit.check(target)

        assert len(vulns) == 0


def testCheck_WhenTypeErrorInVersionParsing_ShouldNotReportVulnerability() -> None:
    """Test check method when TypeError occurs during version parsing."""
    exploit = cve_2025_10035.GoAnywhereDeserializationExploit()
    target = definitions.Target("https", "localhost", 443)
    mock_response = mock.Mock()
    mock_response.text = "GoAnywhere MFT 7.7.0"
    mock_response.status_code = 200

    with (
        mock.patch.object(exploit.session, "get", return_value=mock_response),
        mock.patch(
            "packaging.version.parse",
            side_effect=TypeError("Type error in version parsing"),
        ),
    ):
        vulns = exploit.check(target)

        assert len(vulns) == 0
