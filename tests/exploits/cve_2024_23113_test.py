"""Unit tests for Agent Asteroid: CVE-2024-23113"""

from unittest import mock

import pytest
from pytest_mock import plugin
from ostorlab.agent.mixins import agent_report_vulnerability_mixin

from agent import definitions
from agent.exploits import cve_2024_23113


def testCVE202423113_whenVulnerable_reportFinding(
    mocker: plugin.MockerFixture,
) -> None:
    """CVE-2024-23113 unit test: case when target is vulnerable."""

    vulnerable_version = "7.0.5"
    mock_var_bind = mock.MagicMock()
    mock_var_bind.__getitem__.return_value.prettyPrint.return_value = (
        f"FortiOS v{vulnerable_version}"
    )

    mock_iterator = mock.MagicMock()
    mock_iterator.__next__.return_value = (None, None, None, [mock_var_bind])
    mocker.patch("pysnmp.hlapi.getCmd", return_value=mock_iterator)

    exploit_instance = cve_2024_23113.CVE202423113Exploit()

    target = definitions.Target("udp", "192.168.1.1", 161)

    accept = exploit_instance.accept(target)
    vulnerabilities = exploit_instance.check(target)

    assert accept is True
    assert len(vulnerabilities) == 1
    vulnerability = vulnerabilities[0]
    assert vulnerability.entry.title == cve_2024_23113.VULNERABILITY_TITLE
    assert vulnerability.entry.risk_rating == "HIGH"
    assert vulnerability.risk_rating == agent_report_vulnerability_mixin.RiskRating.HIGH
    assert (
        f"FortiOS device at udp://192.168.1.1:161/ is running a vulnerable version: {vulnerable_version}"
        in vulnerability.technical_detail
    )


def testCVE202423113_whenSafe_reportNothing(
    mocker: plugin.MockerFixture,
) -> None:
    """CVE-2024-23113 unit test: case when target is not vulnerable."""

    safe_version = "8.0.0"
    mock_var_bind = mock.MagicMock()
    mock_var_bind.__getitem__.return_value.prettyPrint.return_value = (
        f"FortiOS v{safe_version}"
    )

    mock_iterator = mock.MagicMock()
    mock_iterator.__next__.return_value = (None, None, None, [mock_var_bind])
    mocker.patch("pysnmp.hlapi.getCmd", return_value=mock_iterator)

    exploit_instance = cve_2024_23113.CVE202423113Exploit()

    target = definitions.Target("udp", "192.168.1.1", 161)

    accept = exploit_instance.accept(target)
    vulnerabilities = exploit_instance.check(target)

    assert accept is False
    assert len(vulnerabilities) == 0


def testCVE202423113_whenVersionNotFound_reportNothing(
    mocker: plugin.MockerFixture,
) -> None:
    """CVE-2024-23113 unit test: case when version cannot be determined."""

    mock_var_bind = mock.MagicMock()
    mock_var_bind.__getitem__.return_value.prettyPrint.return_value = (
        "Unexpected response"
    )

    mock_iterator = mock.MagicMock()
    mock_iterator.__next__.return_value = (None, None, None, [mock_var_bind])
    mocker.patch("pysnmp.hlapi.getCmd", return_value=mock_iterator)

    exploit_instance = cve_2024_23113.CVE202423113Exploit()

    target = definitions.Target("udp", "192.168.1.1", 161)

    accept = exploit_instance.accept(target)
    vulnerabilities = exploit_instance.check(target)

    assert accept is False
    assert len(vulnerabilities) == 0


def testCVE202423113_whenSNMPErrorStatus_handleGracefully(
    mocker: plugin.MockerFixture,
) -> None:
    """CVE-2024-23113 unit test: case when SNMP returns an error status."""

    mock_iterator = mock.MagicMock()
    mock_iterator.__next__.return_value = (None, "Error", 0, None)
    mocker.patch("pysnmp.hlapi.getCmd", return_value=mock_iterator)
    mock_logging = mocker.patch("logging.error")

    mocker.patch(
        "agent.exploits.cve_2024_23113._get_fortinet_version_http", return_value=None
    )
    mocker.patch(
        "agent.exploits.cve_2024_23113._get_fortinet_version_tcp", return_value=None
    )

    exploit_instance = cve_2024_23113.CVE202423113Exploit()

    target = definitions.Target("udp", "192.168.1.1", 161)

    accept = exploit_instance.accept(target)
    vulnerabilities = exploit_instance.check(target)

    assert accept is False
    assert len(vulnerabilities) == 0
    mock_logging.assert_called_with("SNMP error_status: %s at %s", "Error", 0)


def testCVE202423113_whenSNMPFails_fallbackToOtherMethods(
    mocker: plugin.MockerFixture,
) -> None:
    """CVE-2024-23113 unit test: case when SNMP fails and falls back to other methods."""

    # Mock SNMP to fail
    mock_iterator = mock.MagicMock()
    mock_iterator.__next__.return_value = ("Error", None, None, None)
    mocker.patch("pysnmp.hlapi.getCmd", return_value=mock_iterator)

    # Mock HTTP detection to succeed
    mocker.patch(
        "agent.exploits.cve_2024_23113._get_fortinet_version_http",
        return_value=("FortiOS", (7, 0, 5)),
    )

    exploit_instance = cve_2024_23113.CVE202423113Exploit()

    target = definitions.Target("tcp", "192.168.1.1", 443)

    accept = exploit_instance.accept(target)
    vulnerabilities = exploit_instance.check(target)

    assert accept is True
    assert len(vulnerabilities) == 1
    vulnerability = vulnerabilities[0]
    assert vulnerability.entry.title == cve_2024_23113.VULNERABILITY_TITLE
    assert (
        "FortiOS device at tcp://192.168.1.1:443/ is running a vulnerable version: 7.0.5"
        in vulnerability.technical_detail
    )


@pytest.mark.parametrize(
    "content,expected_product,expected_version",
    [
        ("<strong>FortiSwitchManager 7.2.0</strong>", "FortiSwitchManager", (7, 2, 0)),
        ("<strong>FortiPAM 1.1 Hands-On LAB</strong>", "FortiPAM", (1, 1, 0)),
    ],
)
def testCVE202423113_withHTTPDetection_returnVulnerabilities(
    mocker: plugin.MockerFixture,
    content: str,
    expected_product: str,
    expected_version: tuple[int, int, int],
) -> None:
    """Test HTTP-based detection for various Fortinet products."""
    mock_response = mock.MagicMock()
    mock_response.text = content
    mocker.patch("agent.definitions.HttpSession.get", return_value=mock_response)

    exploit_instance = cve_2024_23113.CVE202423113Exploit()
    target = definitions.Target("tcp", "192.168.1.1", 443)

    accept = exploit_instance.accept(target)
    vulnerabilities = exploit_instance.check(target)

    assert accept is True
    assert len(vulnerabilities) == 1
    vulnerability = vulnerabilities[0]
    assert vulnerability.entry.title == cve_2024_23113.VULNERABILITY_TITLE
    assert (
        f"{expected_product} device at tcp://192.168.1.1:443/ is running a vulnerable version: {'.'.join(map(str, expected_version))}"
        in vulnerability.technical_detail
    )


def testCVE202423113_withTCPDetection_returnVulnerabilities(
    mocker: plugin.MockerFixture,
) -> None:
    """Test TCP-based detection for FortiOS."""
    mock_socket = mocker.patch("socket.create_connection")
    mock_instance = mock_socket.return_value.__enter__.return_value

    # Simulate receiving Fortinet version string via TCP
    mock_instance.recv.return_value = b"7.0.0-build1234-FortiOS"

    # Instantiate the exploit class and define the target
    exploit_instance = cve_2024_23113.CVE202423113Exploit()
    target = definitions.Target("tcp", "192.168.1.1", 53)

    # Run the accept and check methods
    accept = exploit_instance.accept(target)
    vulnerabilities = exploit_instance.check(target)

    assert accept is True
    assert len(vulnerabilities) == 1
    vulnerability = vulnerabilities[0]
    assert vulnerability.entry.title == cve_2024_23113.VULNERABILITY_TITLE
    assert (
        "FortiOS device at tcp://192.168.1.1:53/ is running a vulnerable version: 7.0.0"
        in vulnerability.technical_detail
    )


def testCVE202423113_whenAllDetectionMethodsFail_shouldReturnNoVulnerabilities(
    mocker: plugin.MockerFixture,
) -> None:
    """Test case when all detection methods fail."""
    mocker.patch(
        "agent.exploits.cve_2024_23113._get_fortinet_version_snmp", return_value=None
    )
    mocker.patch(
        "agent.exploits.cve_2024_23113._get_fortinet_version_http", return_value=None
    )
    mocker.patch(
        "agent.exploits.cve_2024_23113._get_fortinet_version_tcp", return_value=None
    )

    exploit_instance = cve_2024_23113.CVE202423113Exploit()
    target = definitions.Target("tcp", "192.168.1.1", 443)

    accept = exploit_instance.accept(target)
    vulnerabilities = exploit_instance.check(target)

    assert accept is False
    assert len(vulnerabilities) == 0
