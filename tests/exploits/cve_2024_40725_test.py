"""Unit tests for Apache Source Code Disclosure Exploit."""

from unittest import mock
from unittest.mock import patch

import requests_mock as req_mock
from pygments import lexers
import pytest_mock
import requests

from agent import definitions
from agent.exploits import cve_2024_40725


def testApacheSourceCodeDisclosureExploit_whenVulnerable_reportFinding(
    requests_mock: req_mock.Mocker,
) -> None:
    """Unit test: case when target is vulnerable."""
    requests_mock.head(
        "http://example.com:80", headers={"Server": "Apache/2.4.61"}, status_code=200
    )

    requests_mock.get(
        "http://example.com:80/default.php",
        text="<?php echo 'Hello, World!'; ?>",
        status_code=200,
    )

    requests_mock.get(
        "http://example.com:80/index.php",
        text="<?php echo 'Hello, World!'; ?>",
        status_code=200,
    )

    exploit_instance = cve_2024_40725.ApacheSourceCodeDisclosureExploit()
    target = definitions.Target("http", "example.com", 80)

    assert (
        exploit_instance.accept(target) is True
    ), "The target should be reported as vulnerable."

    vulnerabilities = exploit_instance.check(target)
    assert vulnerabilities, "The target should have vulnerabilities reported."


def testApacheSourceCodeDisclosureExploit_whenSafe_reportNothing(
    requests_mock: req_mock.Mocker,
) -> None:
    """Unit test: case when target is safe."""
    requests_mock.head(
        "http://example.com:80", headers={"Server": "Apache/2.4.62"}, status_code=200
    )

    exploit_instance = cve_2024_40725.ApacheSourceCodeDisclosureExploit()
    target = definitions.Target("http", "example.com", 80)

    assert (
        exploit_instance.accept(target) is False
    ), "The target should be reported as safe."


def testGetServerVersion_whenServerVersionRetrieved_reportCorrectVersion(
    requests_mock: req_mock.Mocker,
) -> None:
    """Unit test to check if server version is correctly retrieved via accept method."""
    requests_mock.head(
        "http://example.com:80", headers={"Server": "Apache/2.4.60"}, status_code=200
    )
    exploit_instance = cve_2024_40725.ApacheSourceCodeDisclosureExploit()
    target = definitions.Target("http", "example.com", 80)
    assert exploit_instance.accept(target) is True, "The server version should be 2.4.60."


def testGetServerVersion_whenRequestException_logsError(
    requests_mock: req_mock.Mocker,
) -> None:
    """Unit test to check if server version retrieval logs error on request exception via accept method."""
    requests_mock.head("http://example.com:80", exc=requests.RequestException)
    exploit_instance = cve_2024_40725.ApacheSourceCodeDisclosureExploit()
    target = definitions.Target("http", "example.com", 80)
    with patch("agent.exploits.cve_2024_40725.logger") as mock_logger:
        assert exploit_instance.accept(target) is False
        mock_logger.error.assert_called_once()


def testIsVersionVulnerable_whenChecked_reportCorrectVulnerabilityStatus(
    mocker: pytest_mock.MockerFixture
) -> None:
    """Unit test to check if version vulnerability is correctly identified via accept method."""
    exploit_instance = cve_2024_40725.ApacheSourceCodeDisclosureExploit()
    target = definitions.Target("http", "example.com", 80)

    mocker.patch("agent.exploits.cve_2024_40725._get_server_version", return_value="2.4.60")

    assert exploit_instance.accept(target) is True

    mocker.patch("agent.exploits.cve_2024_40725._get_server_version", return_value="2.4.59")

    assert exploit_instance.accept(target) is False

    mocker.patch("agent.exploits.cve_2024_40725._get_server_version", return_value=None)

    assert exploit_instance.accept(target) is False


def testReadFilenames_whenFilenamesRead_reportCorrectFilenames(
    mocker: pytest_mock.MockerFixture,
) -> None:
    """Unit test to check if filenames are read correctly via check method."""
    mocker.patch(
        "builtins.open", mocker.mock_open(read_data="/index.php\n/plugin.js\n")
    )
    exploit_instance = cve_2024_40725.ApacheSourceCodeDisclosureExploit()
    target = definitions.Target("http", "example.com", 80)

    with patch.object(cve_2024_40725, "_read_filenames", wraps=cve_2024_40725._read_filenames) as mock_read_filenames:
        exploit_instance.check(target)
        mock_read_filenames.assert_called_once_with(mock.ANY)


def testReadFilenames_whenIOError_logsError(mocker: pytest_mock.MockerFixture) -> None:
    """Unit test to check if reading filenames logs error on IOError via check method."""
    mocker.patch("builtins.open", side_effect=IOError("File not found"))
    exploit_instance = cve_2024_40725.ApacheSourceCodeDisclosureExploit()
    target = definitions.Target("http", "example.com", 80)

    with patch("agent.exploits.cve_2024_40725.logger") as mock_logger:
        exploit_instance.check(target)
        mock_logger.error.assert_called_once()


def testContainsCodeContent_whenContentChecked_reportCorrectContentStatus(
    mocker: pytest_mock.MockerFixture,
) -> None:
    """Unit test to check if content is correctly identified as code via check method."""

    exploit_instance = cve_2024_40725.ApacheSourceCodeDisclosureExploit()
    target = definitions.Target("http", "example.com", 80)

    # Mock guess_lexer to return a PhpLexer instance for PHP content
    mock_php_lexer = mocker.MagicMock()
    mock_php_lexer.__class__ = lexers.PhpLexer
    mocker.patch(
        "agent.exploits.cve_2024_40725.lexers.guess_lexer", return_value=mock_php_lexer
    )
    with patch.object(cve_2024_40725, "_check_files", wraps=cve_2024_40725._check_files) as mock_check_files:
        requests_mock = req_mock.Mocker()
        requests_mock.get(
            "http://example.com/index.php", text="<?php echo 'Hello'; ?>", status_code=200
        )
        exploit_instance.check(target)
        assert mock_check_files.call_count > 0, "Source code disclosure should be checked."


def testContainsCodeContent_whenTypeError_logsError(mocker: pytest_mock.MockerFixture) -> None:
    """Unit test to check if content checking logs error on TypeError via check method."""
    mocker.patch(
        "agent.exploits.cve_2024_40725.lexers.guess_lexer",
        side_effect=TypeError("Invalid content"),
    )
    exploit_instance = cve_2024_40725.ApacheSourceCodeDisclosureExploit()
    target = definitions.Target("http", "example.com", 80)

    with patch("agent.exploits.cve_2024_40725.logger") as mock_logger:
        exploit_instance.check(target)
        mock_logger.error.assert_called_once()


def testCheckFiles_whenFilesChecked_reportCorrectCheckResults(
    requests_mock: req_mock.Mocker,
) -> None:
    """Unit test to check if files are correctly checked via check method."""
    requests_mock.get(
        "http://example.com/index.php", text="<?php echo 'Hello'; ?>", status_code=200
    )
    exploit_instance = cve_2024_40725.ApacheSourceCodeDisclosureExploit()
    target = definitions.Target("http", "example.com", 80)

    with patch.object(cve_2024_40725, "_check_files", wraps=cve_2024_40725._check_files) as mock_check_files:
        exploit_instance.check(target)
        assert mock_check_files.call_count > 0, "Source code disclosure should be checked."


def testCheckFiles_whenRequestException_logsError(
    requests_mock: req_mock.Mocker,
) -> None:
    """Unit test to check if file checking logs error on request exception via check method."""
    requests_mock.get("http://example.com/index.php", exc=requests.RequestException)
    exploit_instance = cve_2024_40725.ApacheSourceCodeDisclosureExploit()
    target = definitions.Target("http", "example.com", 80)

    with patch("agent.exploits.cve_2024_40725.logger") as mock_logger:
        exploit_instance.check(target)
        mock_logger.error.assert_called_once_with(
            "Request error checking file %s: %s", "/index.php", mock.ANY
        )
