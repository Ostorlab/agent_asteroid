"""Unit tests for: CVE-2025-4322"""

import pytest
import requests
import requests_mock as req_mock
from urllib.parse import urljoin
import logging

from agent import definitions
from agent.exploits import cve_2025_4322

# --- Test Constants ---
TARGET_SCHEME = "http"
TARGET_HOST = "testhost.com"
TARGET_PORT = 80
BASE_URL = f"{TARGET_SCHEME}://{TARGET_HOST}:{TARGET_PORT}"
HOMEPAGE_URL = urljoin(BASE_URL, "/")


# Helper to ensure a specific log level and message part exists
def assert_log_entry(
    caplog: pytest.LogCaptureFixture, level: int, message_part: str
) -> None:
    found = False
    # if any(record.levelno == level and message_part in record.message for record in caplog.records) is False:
    #     print(f"--- ASSERTION FAILED for: level={logging.getLevelName(level)}, part='{message_part}' ---")
    #     print("----- Captured Logs -----")
    #     for record_idx, record in enumerate(caplog.records):
    #         print(f"{record_idx}: {logging.getLevelName(record.levelno)} (Logger: {record.name}): {record.message}")
    #     print("----- End Captured Logs -----")

    for record in caplog.records:
        if record.levelno == level and message_part in record.message:
            found = True
            break
    assert found, (
        f"Log entry with level {logging.getLevelName(level)} and message part '{message_part}' not found. See printed logs above if any."
    )


# --- Tests for accept() method ---


def testAccept_whenIndicatorPresentOnHomepage_shouldReturnTrue(
    requests_mock: req_mock.mocker.Mocker,
    caplog: pytest.LogCaptureFixture,
) -> None:
    caplog.set_level(logging.DEBUG, logger="agent.exploits.cve_2025_4322")
    requests_mock.get(
        HOMEPAGE_URL,
        text=f"Some content <div class='{cve_2025_4322.MOTORS_LOGIN_FORM_INDICATOR}'>Login</div> end content",
        status_code=200,
    )
    exploit_instance = cve_2025_4322.MotorsPasswordResetExploit()
    target = definitions.Target(TARGET_SCHEME, TARGET_HOST, TARGET_PORT)
    assert exploit_instance.accept(target) is True
    assert_log_entry(
        caplog,
        logging.INFO,
        "Motors theme indicator 'stm-login-form' found on homepage",
    )


def testAccept_whenIndicatorNotPresentOnHomepage_shouldReturnFalse(
    requests_mock: req_mock.mocker.Mocker,
    caplog: pytest.LogCaptureFixture,
) -> None:
    caplog.set_level(logging.DEBUG, logger="agent.exploits.cve_2025_4322")
    requests_mock.get(
        HOMEPAGE_URL, text="Some other content without the indicator", status_code=200
    )
    exploit_instance = cve_2025_4322.MotorsPasswordResetExploit()
    target = definitions.Target(TARGET_SCHEME, TARGET_HOST, TARGET_PORT)
    assert exploit_instance.accept(target) is False
    assert_log_entry(
        caplog,
        logging.INFO,
        "Motors theme indicator 'stm-login-form' not found on homepage. Rejecting target.",
    )


def testAccept_whenHomepageRequestRaisesRequestException_shouldReturnFalseAndLogError(
    requests_mock: req_mock.mocker.Mocker,
    caplog: pytest.LogCaptureFixture,
) -> None:
    caplog.set_level(logging.WARNING, logger="agent.exploits.cve_2025_4322")
    requests_mock.get(
        HOMEPAGE_URL, exc=requests.exceptions.RequestException("Connection error")
    )
    exploit_instance = cve_2025_4322.MotorsPasswordResetExploit()
    target = definitions.Target(TARGET_SCHEME, TARGET_HOST, TARGET_PORT)
    assert exploit_instance.accept(target) is False
    expected_log_part = f"Request failed while checking for Motors form indicator at homepage {HOMEPAGE_URL}: Connection error"
    assert_log_entry(caplog, logging.WARNING, expected_log_part)


def testAccept_whenHomepageReturnsNon200Status_shouldReturnFalseAndLogDebug(
    requests_mock: req_mock.mocker.Mocker,
    caplog: pytest.LogCaptureFixture,
) -> None:
    caplog.set_level(logging.DEBUG, logger="agent.exploits.cve_2025_4322")
    requests_mock.get(HOMEPAGE_URL, text="Error page", status_code=404)
    exploit_instance = cve_2025_4322.MotorsPasswordResetExploit()
    target = definitions.Target(TARGET_SCHEME, TARGET_HOST, TARGET_PORT)
    assert exploit_instance.accept(target) is False
    expected_log_part = f"Motors form indicator '{cve_2025_4322.MOTORS_LOGIN_FORM_INDICATOR}' not found or unexpected status code (404) at homepage {HOMEPAGE_URL}"
    assert_log_entry(caplog, logging.DEBUG, expected_log_part)


# --- Tests for check() method ---


def testCheck_whenExploitSucceedsOnFirstPath_shouldReportVulnerabilityAndLogCritical(
    requests_mock: req_mock.mocker.Mocker,
    caplog: pytest.LogCaptureFixture,
) -> None:
    caplog.set_level(logging.INFO, logger="agent.exploits.cve_2025_4322")

    first_exploit_path = cve_2025_4322.VULNERABLE_ENDPOINT_PATHS[0]
    exploit_url = urljoin(BASE_URL, first_exploit_path)
    success_message_text = cve_2025_4322.EXPLICIT_SUCCESS_MESSAGE_PATTERNS[0]
    requests_mock.post(
        exploit_url, text=f"<div>{success_message_text}</div>", status_code=200
    )

    exploit_instance = cve_2025_4322.MotorsPasswordResetExploit()
    target = definitions.Target(TARGET_SCHEME, TARGET_HOST, TARGET_PORT)
    vulnerabilities = exploit_instance.check(target)

    assert len(vulnerabilities) == 1
    assert vulnerabilities[0].entry.title == cve_2025_4322.VULNERABILITY_TITLE
    expected_log_part = f"Exploit attempt on {BASE_URL}{first_exploit_path} for user_id {cve_2025_4322.TARGET_USER_ID_TO_ATTACK} appears to be SUCCESSFUL"
    assert_log_entry(caplog, logging.CRITICAL, expected_log_part)


def testCheck_whenExploitSucceedsOnLaterPath_shouldReportVulnerabilityAndLogCritical(
    requests_mock: req_mock.mocker.Mocker,
    caplog: pytest.LogCaptureFixture,
) -> None:
    caplog.set_level(logging.INFO, logger="agent.exploits.cve_2025_4322")

    path0_url = urljoin(BASE_URL, cve_2025_4322.VULNERABLE_ENDPOINT_PATHS[0])
    path1_exploit_path = cve_2025_4322.VULNERABLE_ENDPOINT_PATHS[1]
    path1_url = urljoin(BASE_URL, path1_exploit_path)
    success_message_text = cve_2025_4322.EXPLICIT_SUCCESS_MESSAGE_PATTERNS[0]

    requests_mock.post(path0_url, text="Some other page content", status_code=200)
    requests_mock.post(
        path1_url, text=f"Success: {success_message_text} here.", status_code=200
    )
    for path in cve_2025_4322.VULNERABLE_ENDPOINT_PATHS[2:]:
        requests_mock.post(
            urljoin(BASE_URL, path), text="Not relevant", status_code=200
        )

    exploit_instance = cve_2025_4322.MotorsPasswordResetExploit()
    target = definitions.Target(TARGET_SCHEME, TARGET_HOST, TARGET_PORT)
    vulnerabilities = exploit_instance.check(target)

    assert len(vulnerabilities) == 1
    assert vulnerabilities[0].entry.title == cve_2025_4322.VULNERABILITY_TITLE
    expected_log_part = f"Exploit attempt on {BASE_URL}{path1_exploit_path} for user_id {cve_2025_4322.TARGET_USER_ID_TO_ATTACK} appears to be SUCCESSFUL"
    assert_log_entry(caplog, logging.CRITICAL, expected_log_part)


def testCheck_whenNoPathYieldsExplicitSuccessMessage_shouldReportNothingAndLogRelevantMessages(
    requests_mock: req_mock.mocker.Mocker,
    caplog: pytest.LogCaptureFixture,
) -> None:
    # Set level to capture both INFO and WARNING for this specific logger
    caplog.set_level(logging.INFO, logger="agent.exploits.cve_2025_4322")

    for path in cve_2025_4322.VULNERABLE_ENDPOINT_PATHS:
        url = urljoin(BASE_URL, path)
        requests_mock.post(
            url, text="Page reloaded, no specific success.", status_code=200
        )

    exploit_instance = cve_2025_4322.MotorsPasswordResetExploit()
    target = definitions.Target(TARGET_SCHEME, TARGET_HOST, TARGET_PORT)
    vulnerabilities = exploit_instance.check(target)

    assert len(vulnerabilities) == 0
    # This WARNING is logged inside _attempt_password_reset for each path
    assert_log_entry(
        caplog,
        logging.WARNING,
        "returned 200 OK, but no recognized explicit success message was found",
    )
    # This INFO is logged at the end of check() if no success
    assert_log_entry(
        caplog,
        logging.INFO,
        "did not confirm vulnerability on any tested paths with an explicit success message",
    )


def testCheck_whenAllPostRequestsReturnNon200_shouldReportNothingAndLogWarning(
    requests_mock: req_mock.mocker.Mocker,
    caplog: pytest.LogCaptureFixture,
) -> None:
    caplog.set_level(logging.INFO, logger="agent.exploits.cve_2025_4322")

    for path in cve_2025_4322.VULNERABLE_ENDPOINT_PATHS:
        url = urljoin(BASE_URL, path)
        requests_mock.post(url, text="Not Found", status_code=404)

    exploit_instance = cve_2025_4322.MotorsPasswordResetExploit()
    target = definitions.Target(TARGET_SCHEME, TARGET_HOST, TARGET_PORT)
    vulnerabilities = exploit_instance.check(target)

    assert len(vulnerabilities) == 0
    # This WARNING is logged inside _attempt_password_reset for each path
    assert_log_entry(caplog, logging.WARNING, "returned non-200 status: 404")
    # This INFO is logged at the end of check() if no success
    assert_log_entry(
        caplog,
        logging.INFO,
        "did not confirm vulnerability on any tested paths with an explicit success message",
    )


def testCheck_whenPostRequestRaisesRequestException_shouldReportNothingAndLogError(
    requests_mock: req_mock.mocker.Mocker,
    caplog: pytest.LogCaptureFixture,
) -> None:
    caplog.set_level(
        logging.INFO, logger="agent.exploits.cve_2025_4322"
    )  # Capture ERROR and INFO

    path0_url = urljoin(BASE_URL, cve_2025_4322.VULNERABLE_ENDPOINT_PATHS[0])
    path1_exploit_path = cve_2025_4322.VULNERABLE_ENDPOINT_PATHS[1]
    path1_url = urljoin(BASE_URL, path1_exploit_path)

    requests_mock.post(path0_url, text="No success here", status_code=200)
    requests_mock.post(
        path1_url, exc=requests.exceptions.Timeout("Connection timed out")
    )
    for path in cve_2025_4322.VULNERABLE_ENDPOINT_PATHS[2:]:
        requests_mock.post(
            urljoin(BASE_URL, path), text="Not reached or also fails", status_code=200
        )

    exploit_instance = cve_2025_4322.MotorsPasswordResetExploit()
    target = definitions.Target(TARGET_SCHEME, TARGET_HOST, TARGET_PORT)
    vulnerabilities = exploit_instance.check(target)

    assert len(vulnerabilities) == 0
    expected_log_part = f"HTTP request failed during password reset attempt to {path1_exploit_path}: Connection timed out"
    assert_log_entry(caplog, logging.ERROR, expected_log_part)
    assert_log_entry(
        caplog,
        logging.INFO,
        "did not confirm vulnerability on any tested paths with an explicit success message",
    )


def testCheck_whenRedirectToWpLoginWithoutSuccessMessage_shouldReportNothingAndLogWarning(
    requests_mock: req_mock.mocker.Mocker,
    caplog: pytest.LogCaptureFixture,
) -> None:
    caplog.set_level(logging.INFO, logger="agent.exploits.cve_2025_4322")

    exploit_path = cve_2025_4322.VULNERABLE_ENDPOINT_PATHS[0]
    exploit_url = urljoin(BASE_URL, exploit_path)

    requests_mock.post(
        exploit_url,
        text="<form id='loginform'>User <input name='log'></form>",
        status_code=200,
    )
    for path in cve_2025_4322.VULNERABLE_ENDPOINT_PATHS[1:]:
        requests_mock.post(
            urljoin(BASE_URL, path), text="Another page", status_code=200
        )

    exploit_instance = cve_2025_4322.MotorsPasswordResetExploit()
    target = definitions.Target(TARGET_SCHEME, TARGET_HOST, TARGET_PORT)
    vulnerabilities = exploit_instance.check(target)

    assert len(vulnerabilities) == 0
    expected_log_part = (
        "Password reset POST to %s returned 200 OK, but no recognized explicit success message was found"
        % exploit_path
    )
    assert_log_entry(caplog, logging.WARNING, expected_log_part)
    assert_log_entry(
        caplog,
        logging.INFO,
        "did not confirm vulnerability on any tested paths with an explicit success message",
    )
