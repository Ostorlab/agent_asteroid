"""Unit tests for: CVE-2025-4322"""

import pytest
import requests
import requests_mock as req_mock
from urllib.parse import urljoin
import logging

from agent import definitions
from agent.exploits import cve_2025_4322  # Ensure this is your updated exploit script

# --- Test Constants ---
TARGET_SCHEME = "http"
TARGET_HOST = "testhost.com"
TARGET_PORT = 80
BASE_URL = f"{TARGET_SCHEME}://{TARGET_HOST}:{TARGET_PORT}"
# The MOTORS_INDICATOR is now central to the accept method
STYLE_CSS_URL = urljoin(BASE_URL, cve_2025_4322.MOTORS_INDICATOR)


# Helper to ensure a specific log level and message part exists
def assert_log_entry(
    caplog: pytest.LogCaptureFixture, level: int, message_part: str
) -> None:
    found = False
    # if any(record.levelno == level and message_part in record.message for record in caplog.records) is False:
    #     print(f"--- ASSERTION FAILED for: level={logging.getLevelName(level)}, part='{message_part}' ---")
    #     print("----- Captured Logs -----")
    #     for record_idx, record in enumerate(caplog.records):
    #         print(f"{record_idx}: {logging.getLevelName(record.levelno)} (Logger: {record.name}): {record.message}")
    #     print("----- End Captured Logs -----")

    for record in caplog.records:
        if record.levelno == level and message_part in record.message:
            found = True
            break
    assert found, (
        f"Log entry with level {logging.getLevelName(level)} and message part '{message_part}' not found. See printed logs above if any."
    )


# --- Tests for accept() method (Updated for style.css check) ---


def testAccept_whenStyleCssContainsMotorsThemeName_shouldReturnTrue(
    requests_mock: req_mock.mocker.Mocker,
    caplog: pytest.LogCaptureFixture,
) -> None:
    """Test accept() when style.css indicates Motors theme."""
    caplog.set_level(logging.DEBUG, logger="agent.exploits.cve_2025_4322")
    requests_mock.get(
        STYLE_CSS_URL,  # Mock the request to style.css
        text="/*\nTheme Name: Motors\nVersion: 5.6.0\n*/",  # Content indicating Motors theme
        status_code=200,
    )
    exploit_instance = cve_2025_4322.MotorsPasswordResetExploit()
    target = definitions.Target(TARGET_SCHEME, TARGET_HOST, TARGET_PORT)
    assert exploit_instance.accept(target) is True
    # Check the log message from the (now slightly misnamed) _check_homepage_for_motors_form_indicator
    assert_log_entry(
        caplog,
        logging.INFO,
        f"Found Motors form indicator '{cve_2025_4322.MOTORS_INDICATOR}' at homepage {STYLE_CSS_URL}",  # Log still says homepage due to func name
    )
    assert_log_entry(
        caplog,
        logging.INFO,
        f"Motors theme indicator '{cve_2025_4322.MOTORS_INDICATOR}' found on homepage '{target.origin}'. Accepting target.",  # Log from accept()
    )


def testAccept_whenStyleCssDoesNotContainMotorsThemeName_shouldReturnFalse(
    requests_mock: req_mock.mocker.Mocker,
    caplog: pytest.LogCaptureFixture,
) -> None:
    """Test accept() when style.css indicates a different theme."""
    caplog.set_level(logging.DEBUG, logger="agent.exploits.cve_2025_4322")
    requests_mock.get(
        STYLE_CSS_URL,
        text="/*\nTheme Name: Another Theme\nVersion: 1.0\n*/",
        status_code=200,
    )
    exploit_instance = cve_2025_4322.MotorsPasswordResetExploit()
    target = definitions.Target(TARGET_SCHEME, TARGET_HOST, TARGET_PORT)
    assert exploit_instance.accept(target) is False
    assert_log_entry(
        caplog,
        logging.DEBUG,  # This log is DEBUG if indicator not found
        f"Motors form indicator '{cve_2025_4322.MOTORS_INDICATOR}' not found or unexpected status code (200) at homepage {STYLE_CSS_URL}",
    )
    assert_log_entry(
        caplog,
        logging.INFO,
        f"Motors theme indicator '{cve_2025_4322.MOTORS_INDICATOR}' not found on homepage. Rejecting target.",
    )


def testAccept_whenStyleCssRequestRaisesRequestException_shouldReturnFalseAndLogError(
    requests_mock: req_mock.mocker.Mocker,
    caplog: pytest.LogCaptureFixture,
) -> None:
    """Test accept() when the GET request for style.css fails."""
    caplog.set_level(logging.WARNING, logger="agent.exploits.cve_2025_4322")
    requests_mock.get(
        STYLE_CSS_URL, exc=requests.exceptions.RequestException("Connection error")
    )
    exploit_instance = cve_2025_4322.MotorsPasswordResetExploit()
    target = definitions.Target(TARGET_SCHEME, TARGET_HOST, TARGET_PORT)
    assert exploit_instance.accept(target) is False
    expected_log_part = f"Request failed while checking for Motors form indicator at homepage {STYLE_CSS_URL}: Connection error"
    assert_log_entry(caplog, logging.WARNING, expected_log_part)


def testAccept_whenStyleCssReturnsNon200Status_shouldReturnFalseAndLogDebug(
    requests_mock: req_mock.mocker.Mocker,
    caplog: pytest.LogCaptureFixture,
) -> None:
    """Test accept() when style.css request returns a non-200 status code."""
    caplog.set_level(logging.DEBUG, logger="agent.exploits.cve_2025_4322")
    requests_mock.get(STYLE_CSS_URL, text="Not Found", status_code=404)
    exploit_instance = cve_2025_4322.MotorsPasswordResetExploit()
    target = definitions.Target(TARGET_SCHEME, TARGET_HOST, TARGET_PORT)
    assert exploit_instance.accept(target) is False
    expected_log_part = f"Motors form indicator '{cve_2025_4322.MOTORS_INDICATOR}' not found or unexpected status code (404) at homepage {STYLE_CSS_URL}"
    assert_log_entry(caplog, logging.DEBUG, expected_log_part)


# --- Tests for check() method (These should largely remain the same as check logic didn't change) ---


def testCheck_whenExploitSucceedsOnFirstPath_shouldReportVulnerabilityAndLogCritical(
    requests_mock: req_mock.mocker.Mocker,
    caplog: pytest.LogCaptureFixture,
) -> None:
    caplog.set_level(logging.INFO, logger="agent.exploits.cve_2025_4322")

    first_exploit_path = cve_2025_4322.VULNERABLE_ENDPOINT_PATHS[0]
    exploit_url = urljoin(BASE_URL, first_exploit_path)
    success_message_text = cve_2025_4322.EXPLICIT_SUCCESS_MESSAGE_PATTERNS[0]
    requests_mock.post(
        exploit_url, text=f"<div>{success_message_text}</div>", status_code=200
    )

    exploit_instance = cve_2025_4322.MotorsPasswordResetExploit()
    target = definitions.Target(TARGET_SCHEME, TARGET_HOST, TARGET_PORT)
    vulnerabilities = exploit_instance.check(target)

    assert len(vulnerabilities) == 1
    assert vulnerabilities[0].entry.title == cve_2025_4322.VULNERABILITY_TITLE
    expected_log_part = f"Exploit attempt on {BASE_URL}{first_exploit_path} for user_id {cve_2025_4322.TARGET_USER_ID_TO_ATTACK} appears to be SUCCESSFUL"
    assert_log_entry(caplog, logging.CRITICAL, expected_log_part)


def testCheck_whenExploitSucceedsOnLaterPath_shouldReportVulnerabilityAndLogCritical(
    requests_mock: req_mock.mocker.Mocker,
    caplog: pytest.LogCaptureFixture,
) -> None:
    caplog.set_level(logging.INFO, logger="agent.exploits.cve_2025_4322")

    path0_url = urljoin(BASE_URL, cve_2025_4322.VULNERABLE_ENDPOINT_PATHS[0])
    path1_exploit_path = cve_2025_4322.VULNERABLE_ENDPOINT_PATHS[1]
    path1_url = urljoin(BASE_URL, path1_exploit_path)
    success_message_text = cve_2025_4322.EXPLICIT_SUCCESS_MESSAGE_PATTERNS[0]

    requests_mock.post(path0_url, text="Some other page content", status_code=200)
    requests_mock.post(
        path1_url, text=f"Success: {success_message_text} here.", status_code=200
    )
    for path in cve_2025_4322.VULNERABLE_ENDPOINT_PATHS[2:]:
        requests_mock.post(
            urljoin(BASE_URL, path), text="Not relevant", status_code=200
        )

    exploit_instance = cve_2025_4322.MotorsPasswordResetExploit()
    target = definitions.Target(TARGET_SCHEME, TARGET_HOST, TARGET_PORT)
    vulnerabilities = exploit_instance.check(target)

    assert len(vulnerabilities) == 1
    assert vulnerabilities[0].entry.title == cve_2025_4322.VULNERABILITY_TITLE
    expected_log_part = f"Exploit attempt on {BASE_URL}{path1_exploit_path} for user_id {cve_2025_4322.TARGET_USER_ID_TO_ATTACK} appears to be SUCCESSFUL"
    assert_log_entry(caplog, logging.CRITICAL, expected_log_part)


def testCheck_whenNoPathYieldsExplicitSuccessMessage_shouldReportNothingAndLogRelevantMessages(
    requests_mock: req_mock.mocker.Mocker,
    caplog: pytest.LogCaptureFixture,
) -> None:
    caplog.set_level(logging.INFO, logger="agent.exploits.cve_2025_4322")

    for path in cve_2025_4322.VULNERABLE_ENDPOINT_PATHS:
        url = urljoin(BASE_URL, path)
        requests_mock.post(
            url, text="Page reloaded, no specific success.", status_code=200
        )

    exploit_instance = cve_2025_4322.MotorsPasswordResetExploit()
    target = definitions.Target(TARGET_SCHEME, TARGET_HOST, TARGET_PORT)
    vulnerabilities = exploit_instance.check(target)

    assert len(vulnerabilities) == 0
    assert_log_entry(
        caplog,
        logging.WARNING,
        "returned 200 OK, but no recognized explicit success message was found",
    )
    assert_log_entry(
        caplog,
        logging.INFO,
        "did not confirm vulnerability on any tested paths with an explicit success message",
    )


def testCheck_whenAllPostRequestsReturnNon200_shouldReportNothingAndLogWarning(
    requests_mock: req_mock.mocker.Mocker,
    caplog: pytest.LogCaptureFixture,
) -> None:
    caplog.set_level(logging.INFO, logger="agent.exploits.cve_2025_4322")

    for path in cve_2025_4322.VULNERABLE_ENDPOINT_PATHS:
        url = urljoin(BASE_URL, path)
        requests_mock.post(url, text="Not Found", status_code=404)

    exploit_instance = cve_2025_4322.MotorsPasswordResetExploit()
    target = definitions.Target(TARGET_SCHEME, TARGET_HOST, TARGET_PORT)
    vulnerabilities = exploit_instance.check(target)

    assert len(vulnerabilities) == 0
    assert_log_entry(caplog, logging.WARNING, "returned non-200 status: 404")
    assert_log_entry(
        caplog,
        logging.INFO,
        "did not confirm vulnerability on any tested paths with an explicit success message",
    )


def testCheck_whenPostRequestRaisesRequestException_shouldReportNothingAndLogError(
    requests_mock: req_mock.mocker.Mocker,
    caplog: pytest.LogCaptureFixture,
) -> None:
    caplog.set_level(logging.INFO, logger="agent.exploits.cve_2025_4322")

    path0_url = urljoin(BASE_URL, cve_2025_4322.VULNERABLE_ENDPOINT_PATHS[0])
    path1_exploit_path = cve_2025_4322.VULNERABLE_ENDPOINT_PATHS[1]
    path1_url = urljoin(BASE_URL, path1_exploit_path)

    requests_mock.post(path0_url, text="No success here", status_code=200)
    requests_mock.post(
        path1_url, exc=requests.exceptions.Timeout("Connection timed out")
    )
    for path in cve_2025_4322.VULNERABLE_ENDPOINT_PATHS[2:]:
        requests_mock.post(
            urljoin(BASE_URL, path), text="Not reached or also fails", status_code=200
        )

    exploit_instance = cve_2025_4322.MotorsPasswordResetExploit()
    target = definitions.Target(TARGET_SCHEME, TARGET_HOST, TARGET_PORT)
    vulnerabilities = exploit_instance.check(target)

    assert len(vulnerabilities) == 0
    expected_log_part = f"HTTP request failed during password reset attempt to {path1_exploit_path}: Connection timed out"
    assert_log_entry(caplog, logging.ERROR, expected_log_part)
    assert_log_entry(
        caplog,
        logging.INFO,
        "did not confirm vulnerability on any tested paths with an explicit success message",
    )


def testCheck_whenRedirectToWpLoginWithoutSuccessMessage_shouldReportNothingAndLogWarning(
    requests_mock: req_mock.mocker.Mocker,
    caplog: pytest.LogCaptureFixture,
) -> None:
    caplog.set_level(logging.INFO, logger="agent.exploits.cve_2025_4322")

    exploit_path = cve_2025_4322.VULNERABLE_ENDPOINT_PATHS[0]
    exploit_url = urljoin(BASE_URL, exploit_path)

    requests_mock.post(
        exploit_url,
        text="<form id='loginform'>User <input name='log'></form>",  # Content of wp-login.php
        status_code=200,
    )
    for path in cve_2025_4322.VULNERABLE_ENDPOINT_PATHS[1:]:
        requests_mock.post(
            urljoin(BASE_URL, path), text="Another page", status_code=200
        )

    exploit_instance = cve_2025_4322.MotorsPasswordResetExploit()
    target = definitions.Target(TARGET_SCHEME, TARGET_HOST, TARGET_PORT)
    vulnerabilities = exploit_instance.check(target)

    assert len(vulnerabilities) == 0
    expected_log_part = (
        "Password reset POST to %s returned 200 OK, but no recognized explicit success message was found"
        % exploit_path
    )
    assert_log_entry(caplog, logging.WARNING, expected_log_part)
    assert_log_entry(
        caplog,
        logging.INFO,
        "did not confirm vulnerability on any tested paths with an explicit success message",
    )
