"""Unit tests for Agent Asteroid: CVE-2024-55591"""

import socket
import ssl
from unittest import mock

from requests import exceptions as requests_exceptions

from agent import definitions
from agent.exploits import cve_2024_55591


def testAccept_whenPotentialVulnerableInstance_shouldReturnTrue() -> None:
    """Test accept method with valid schemes."""
    exploit = cve_2024_55591.FortiOSAuthBypassExploit()
    target = definitions.Target("https", "localhost", 443)

    mock_login_response = mock.Mock()
    mock_login_response.status_code = 200
    mock_login_response.text = (
        '<html class="main-app"><f-icon class="fa-warning"></f-icon>'
    )
    mock_login_response.headers = {"Set-Cookie": "APSCOOKIE_12345"}

    with mock.patch.object(exploit, "session") as mock_session:
        mock_session.get.side_effect = [mock_login_response]

        assert exploit.accept(target) is True


def testCheck_whenTargetIsVulnerable_shouldReportVulnerability() -> None:
    """Test check method with vulnerable target."""
    exploit = cve_2024_55591.FortiOSAuthBypassExploit()
    target = definitions.Target("https", "localhost", 443)

    mock_websocket_response = mock.Mock()
    mock_websocket_response.status_code = 101
    mock_websocket_response.headers = {"Connection": "Upgrade"}

    with mock.patch.object(exploit, "session") as mock_session:
        mock_session.get.side_effect = [mock_websocket_response]

        vulnerabilities = exploit.check(target)

        assert len(vulnerabilities) == 1
        assert vulnerabilities[0].entry.title == cve_2024_55591.VULNERABILITY_TITLE
        assert vulnerabilities[0].entry.risk_rating == cve_2024_55591.RISK_RATING


def testAccept_whenLoginResponseInvalid_shouldReturnFalse() -> None:
    """Test check method when login response is invalid."""
    exploit = cve_2024_55591.FortiOSAuthBypassExploit()
    target = definitions.Target("https", "localhost", 443)

    mock_response = mock.Mock()
    mock_response.status_code = 200
    mock_response.text = "<html></html>"  # Missing required patterns
    mock_response.headers = {}

    with mock.patch.object(exploit, "session") as mock_session:
        mock_session.get.return_value = mock_response

        assert exploit.accept(target) is False


def testCheck_whenWebsocketResponseInvalid_shouldNotReportVulnerability() -> None:
    """Test check method when websocket response is invalid."""
    exploit = cve_2024_55591.FortiOSAuthBypassExploit()
    target = definitions.Target("https", "localhost", 443)

    mock_websocket_response = mock.Mock()
    mock_websocket_response.status_code = 200  # Invalid status code
    mock_websocket_response.headers = {}

    with mock.patch.object(exploit, "session") as mock_session:
        mock_session.get.side_effect = [mock_websocket_response]

        vulnerabilities = exploit.check(target)

        assert len(vulnerabilities) == 0


def testAccept_whenRequestFails_shouldReturnFalse() -> None:
    """Test check method when request fails."""
    exploit = cve_2024_55591.FortiOSAuthBypassExploit()
    target = definitions.Target("https", "localhost", 443)

    with mock.patch.object(exploit, "session") as mock_session:
        mock_session.get.side_effect = requests_exceptions.RequestException()

        assert exploit.accept(target) is False


def testAccept_whenMissingFIconWarning_shouldReturnFalse() -> None:
    """Test accept method when f-icon warning pattern is missing."""
    exploit = cve_2024_55591.FortiOSAuthBypassExploit()
    target = definitions.Target("https", "localhost", 443)

    mock_response = mock.Mock()
    mock_response.status_code = 200
    mock_response.text = '<html class="main-app"></html>'
    mock_response.headers = {"Set-Cookie": "APSCOOKIE_12345"}

    with mock.patch.object(exploit, "session") as mock_session:
        mock_session.get.return_value = mock_response
        assert exploit.accept(target) is False


def testAccept_whenMissingFIconClosing_shouldReturnFalse() -> None:
    """Test accept method when f-icon closing pattern is missing."""
    exploit = cve_2024_55591.FortiOSAuthBypassExploit()
    target = definitions.Target("https", "localhost", 443)

    mock_response = mock.Mock()
    mock_response.status_code = 200
    mock_response.text = '<html class="main-app"><f-icon class="fa-warning">'
    mock_response.headers = {"Set-Cookie": "APSCOOKIE_12345"}

    with mock.patch.object(exploit, "session") as mock_session:
        mock_session.get.return_value = mock_response
        assert exploit.accept(target) is False


def testAccept_whenMissingApsCookie_shouldReturnFalse() -> None:
    """Test accept method when APSCOOKIE marker is missing."""
    exploit = cve_2024_55591.FortiOSAuthBypassExploit()
    target = definitions.Target("https", "localhost", 443)

    mock_response = mock.Mock()
    mock_response.status_code = 200
    mock_response.text = '<html class="main-app"><f-icon class="fa-warning"></f-icon>'
    mock_response.headers = {}

    with mock.patch.object(exploit, "session") as mock_session:
        mock_session.get.return_value = mock_response
        assert exploit.accept(target) is False


def testAccept_whenInvalidStatusCode_shouldReturnFalse() -> None:
    """Test accept method when status code is invalid."""
    exploit = cve_2024_55591.FortiOSAuthBypassExploit()
    target = definitions.Target("https", "localhost", 443)

    mock_response = mock.Mock()
    mock_response.status_code = 404
    mock_response.text = '<html class="main-app"><f-icon class="fa-warning"></f-icon>'
    mock_response.headers = {"Set-Cookie": "APSCOOKIE_12345"}

    with mock.patch.object(exploit, "session") as mock_session:
        mock_session.get.return_value = mock_response
        assert exploit.accept(target) is False


def testAccept_whenResponseTextIsNone_shouldReturnFalse() -> None:
    """Test accept method when response text is None."""
    exploit = cve_2024_55591.FortiOSAuthBypassExploit()
    target = definitions.Target("https", "localhost", 443)

    mock_response = mock.Mock()
    mock_response.status_code = 200
    mock_response.text = ""
    mock_response.headers = {"Set-Cookie": "APSCOOKIE_12345"}

    with mock.patch.object(exploit, "session") as mock_session:
        mock_session.get.return_value = mock_response
        assert exploit.accept(target) is False


def testCheck_whenRequestFails_shouldReturnEmptyList() -> None:
    """Test check method when request fails."""
    exploit = cve_2024_55591.FortiOSAuthBypassExploit()
    target = definitions.Target("https", "localhost", 443)

    with mock.patch.object(exploit, "session") as mock_session:
        mock_session.get.side_effect = requests_exceptions.RequestException(
            "Request failed"
        )

        vulnerabilities = exploit.check(target)
        assert len(vulnerabilities) == 0


def testCheck_whenSocketError_shouldReturnEmptyList() -> None:
    """Test check method when socket error occurs."""
    exploit = cve_2024_55591.FortiOSAuthBypassExploit()
    target = definitions.Target("https", "localhost", 443)

    with mock.patch.object(exploit, "session") as mock_session:
        mock_session.get.side_effect = socket.error("Socket error")

        vulnerabilities = exploit.check(target)
        assert len(vulnerabilities) == 0


def testCheck_whenSSLError_shouldReturnEmptyList() -> None:
    """Test check method when SSL error occurs."""
    exploit = cve_2024_55591.FortiOSAuthBypassExploit()
    target = definitions.Target("https", "localhost", 443)

    with mock.patch.object(exploit, "session") as mock_session:
        mock_session.get.side_effect = ssl.SSLError("SSL error")

        vulnerabilities = exploit.check(target)
        assert len(vulnerabilities) == 0
