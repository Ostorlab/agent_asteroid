"""Unit tests for Agent Asteroid: CVE-2025-0282"""

import socket
import ssl
import struct
from unittest import mock

from requests import exceptions as requests_exceptions

from agent import definitions
from agent.exploits import cve_2025_0282


def create_mock_socket(is_vulnerable: bool = True) -> mock.Mock:
    """Create a mock socket with predefined responses."""
    mock_socket = mock.Mock(spec=ssl.SSLSocket)

    # Mock initial HTTP upgrade response
    mock_socket.recv.return_value = b"HTTP/1.1 101 Switching Protocols\r\n"

    # Mock the sequence of read responses
    responses = [
        # Version response header + data
        struct.pack(">IIII", 0x5597, 1, 20, 0),  # 16 byte header + 4 byte data
        b"\x00\x01\x02\x02",
        # Auth challenge header + data
        struct.pack(">IIII", 0xA4C, 0x87, 48, 1),  # 16 byte header + 32 byte data
        b"A" * 32,
    ]

    if is_vulnerable is True:
        # Simulate connection reset after auth challenge
        mock_socket.read.side_effect = responses + [
            socket.error("Connection reset by peer")
        ]
    else:
        # Simulate normal response
        responses.extend(
            [
                struct.pack(
                    ">IIII", 0xA4C, 0x93, 20, 2
                ),  # 16 byte header + 4 byte data
                b"Patched",
            ]
        )
        mock_socket.read.side_effect = responses

    return mock_socket


def testAccept_whenHttpsAndVulnerableVersion_shouldReturnTrue() -> None:
    """Test accept method with valid conditions."""
    exploit = cve_2025_0282.IvantiConnectSecureExploit()
    target = definitions.Target("https", "localhost", 443)

    mock_response = mock.Mock()
    mock_response.text = '<PARAM NAME="ProductVersion" VALUE="22.7.2.4">'
    mock_response.raise_for_status = mock.Mock()

    mock_session = mock.Mock()
    mock_session.get.return_value = mock_response

    with mock.patch.object(exploit, "session", mock_session):
        assert exploit.accept(target) is True

    target = definitions.Target("http", "localhost", 80)
    assert exploit.accept(target) is False


def testCheck_whenTargetIsVulnerable_shouldReportVulnerability() -> None:
    """Test check method with vulnerable target."""
    exploit = cve_2025_0282.IvantiConnectSecureExploit()
    target = definitions.Target("https", "localhost", 443)

    mock_version_response = mock.Mock()
    mock_version_response.text = '<PARAM NAME="ProductVersion" VALUE="22.7.2.4">'
    mock_version_response.raise_for_status = mock.Mock()
    mock_socket = create_mock_socket(is_vulnerable=True)

    with (
        mock.patch.object(exploit, "session") as mock_session,
        mock.patch("ssl.create_default_context") as mock_ssl_ctx,
        mock.patch("socket.create_connection") as mock_create_conn,
    ):
        mock_session.get.return_value = mock_version_response
        mock_ssl_ctx.return_value.wrap_socket.return_value = mock_socket
        mock_create_conn.return_value = mock_socket

        vulnerabilities = exploit.check(target)
        assert len(vulnerabilities) == 1
        assert vulnerabilities[0].entry.title == cve_2025_0282.VULNERABILITY_TITLE
        assert vulnerabilities[0].entry.risk_rating == cve_2025_0282.RISK_RATING


def testCheck_whenTargetIsNotVulnerable_shouldNotReportVulnerability() -> None:
    """Test check method with non-vulnerable target."""
    exploit = cve_2025_0282.IvantiConnectSecureExploit()
    target = definitions.Target("https", "localhost", 443)

    mock_version_response = mock.Mock()
    mock_version_response.text = '<PARAM NAME="ProductVersion" VALUE="22.7R2.6">'
    mock_version_response.raise_for_status = mock.Mock()
    mock_socket = create_mock_socket(is_vulnerable=False)

    with (
        mock.patch.object(exploit, "session") as mock_session,
        mock.patch("ssl.create_default_context") as mock_ssl_ctx,
        mock.patch("socket.create_connection") as mock_create_conn,
    ):
        mock_session.get.return_value = mock_version_response
        mock_ssl_ctx.return_value.wrap_socket.return_value = mock_socket
        mock_create_conn.return_value = mock_socket

        vulnerabilities = exploit.check(target)
        assert len(vulnerabilities) == 0


def testCheck_whenVersionCheckFails_shouldNotReportVulnerability() -> None:
    """Test check method when version check fails."""
    exploit = cve_2025_0282.IvantiConnectSecureExploit()
    target = definitions.Target("https", "localhost", 443)

    with (
        mock.patch.object(exploit, "session") as mock_session,
        mock.patch("ssl.create_default_context"),
        mock.patch("socket.create_connection") as mock_create_conn,
    ):
        mock_session.get.side_effect = requests_exceptions.RequestException()
        mock_create_conn.side_effect = ConnectionError("Test connection error")

        vulnerabilities = exploit.check(target)
        assert len(vulnerabilities) == 0
