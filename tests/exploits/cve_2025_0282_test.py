"""Unit tests for Agent Asteroid: CVE-2025-0282"""

import socket
import ssl
import struct
from unittest import mock

from requests import exceptions as requests_exceptions

from agent import definitions
from agent.exploits import cve_2025_0282


def create_mock_socket(is_vulnerable: bool = True) -> mock.Mock:
    """Create a mock socket with predefined responses."""
    mock_socket = mock.Mock(spec=ssl.SSLSocket)

    # Mock initial HTTP upgrade response
    mock_socket.recv.return_value = b"HTTP/1.1 101 Switching Protocols\r\n"

    # Mock the sequence of read responses
    responses = [
        # Version response header + data
        struct.pack(">IIII", 0x5597, 1, 20, 0),  # 16 byte header + 4 byte data
        b"\x00\x01\x02\x02",
        # Auth challenge header + data
        struct.pack(">IIII", 0xA4C, 0x87, 48, 1),  # 16 byte header + 32 byte data
        b"A" * 32,
    ]

    if is_vulnerable is True:
        # Simulate connection reset after auth challenge
        mock_socket.read.side_effect = responses + [
            socket.error("Connection reset by peer")
        ]
    else:
        # Simulate normal response
        responses.extend(
            [
                struct.pack(
                    ">IIII", 0xA4C, 0x93, 20, 2
                ),  # 16 byte header + 4 byte data
                b"Patched",
            ]
        )
        mock_socket.read.side_effect = responses

    return mock_socket


def testAccept_whenHttpsAndVulnerableVersion_shouldReturnTrue() -> None:
    """Test accept method with valid conditions."""
    exploit = cve_2025_0282.IvantiConnectSecureExploit()
    target = definitions.Target("https", "localhost", 443)

    mock_response = mock.Mock()
    mock_response.text = '<PARAM NAME="ProductVersion" VALUE="22.7.2.4">'
    mock_response.raise_for_status = mock.Mock()

    mock_session = mock.Mock()
    mock_session.get.return_value = mock_response

    with mock.patch.object(exploit, "session", mock_session):
        assert exploit.accept(target) is True

    target = definitions.Target("http", "localhost", 80)

    assert exploit.accept(target) is False


def testCheck_whenTargetIsVulnerable_shouldReportVulnerability() -> None:
    """Test check method with vulnerable target."""
    exploit = cve_2025_0282.IvantiConnectSecureExploit()
    target = definitions.Target("https", "localhost", 443)

    mock_version_response = mock.Mock()
    mock_version_response.text = '<PARAM NAME="ProductVersion" VALUE="22.7.2.4">'
    mock_version_response.raise_for_status = mock.Mock()
    mock_socket = create_mock_socket(is_vulnerable=True)

    with (
        mock.patch.object(exploit, "session") as mock_session,
        mock.patch("ssl.create_default_context") as mock_ssl_ctx,
        mock.patch("socket.create_connection") as mock_create_conn,
    ):
        mock_session.get.return_value = mock_version_response
        mock_ssl_ctx.return_value.wrap_socket.return_value = mock_socket
        mock_create_conn.return_value = mock_socket

        vulnerabilities = exploit.check(target)

        assert len(vulnerabilities) == 1
        assert vulnerabilities[0].entry.title == cve_2025_0282.VULNERABILITY_TITLE
        assert vulnerabilities[0].entry.risk_rating == cve_2025_0282.RISK_RATING


def testCheck_whenVersionCheckFails_shouldNotReportVulnerability() -> None:
    """Test check method when version check fails."""
    exploit = cve_2025_0282.IvantiConnectSecureExploit()
    target = definitions.Target("https", "localhost", 443)

    with (
        mock.patch.object(exploit, "session") as mock_session,
        mock.patch("ssl.create_default_context"),
        mock.patch("socket.create_connection") as mock_create_conn,
    ):
        mock_session.get.side_effect = requests_exceptions.RequestException()
        mock_create_conn.side_effect = ConnectionError("Test connection error")

        vulnerabilities = exploit.check(target)

        assert len(vulnerabilities) == 0


def testCheck_whenServerDoesNotSupportIFT_shouldNotReportVulnerability() -> None:
    """Test check method when server doesn't support IF-T/TLS."""
    exploit = cve_2025_0282.IvantiConnectSecureExploit()
    target = definitions.Target("https", "localhost", 443)

    mock_socket = mock.Mock(spec=ssl.SSLSocket)
    mock_socket.recv.return_value = b"HTTP/1.1 200 OK\r\n"  # Not switching protocols

    with (
        mock.patch.object(exploit, "session") as mock_session,
        mock.patch("ssl.create_default_context") as mock_ssl_ctx,
        mock.patch("socket.create_connection") as mock_create_conn,
    ):
        mock_session.get.return_value = mock.Mock(
            text='<PARAM NAME="ProductVersion" VALUE="22.7.2.4">'
        )
        mock_ssl_ctx.return_value.wrap_socket.return_value = mock_socket
        mock_create_conn.return_value = mock_socket

        vulnerabilities = exploit.check(target)

        assert len(vulnerabilities) == 0


def testCheck_whenSocketReadFails_shouldNotReportVulnerability() -> None:
    """Test check method when socket read fails."""
    exploit = cve_2025_0282.IvantiConnectSecureExploit()
    target = definitions.Target("https", "localhost", 443)

    mock_socket = mock.Mock(spec=ssl.SSLSocket)
    mock_socket.recv.return_value = b"HTTP/1.1 101 Switching Protocols\r\n"
    mock_socket.read.side_effect = socket.error("Failed to read IF-T header")

    with (
        mock.patch.object(exploit, "session") as mock_session,
        mock.patch("ssl.create_default_context") as mock_ssl_ctx,
        mock.patch("socket.create_connection") as mock_create_conn,
    ):
        mock_session.get.return_value = mock.Mock(
            text='<PARAM NAME="ProductVersion" VALUE="22.7.2.4">',
            raise_for_status=mock.Mock(),
        )
        mock_ssl_ctx.return_value.wrap_socket.return_value = mock_socket
        mock_create_conn.return_value = mock_socket

        vulnerabilities = exploit.check(target)

        assert len(vulnerabilities) == 0


def testCheck_whenVersionNotVulnerable_shouldNotReportVulnerability() -> None:
    """Test check method when version is not vulnerable."""
    exploit = cve_2025_0282.IvantiConnectSecureExploit()
    target = definitions.Target("https", "localhost", 443)

    mock_response = mock.Mock()
    mock_response.text = '<html><PARAM NAME="ProductVersion" VALUE="22.8.0.0"></html>'
    mock_response.raise_for_status = mock.Mock()

    mock_socket = create_mock_socket(is_vulnerable=False)

    with (
        mock.patch.object(exploit, "session") as mock_session,
        mock.patch("ssl.create_default_context") as mock_ssl_ctx,
        mock.patch("socket.create_connection") as mock_create_conn,
    ):
        mock_session.get.return_value = mock_response
        mock_ssl_ctx.return_value.wrap_socket.return_value = mock_socket
        mock_create_conn.return_value = mock_socket

        vulnerabilities = exploit.check(target)

        assert len(vulnerabilities) == 0


def testCheck_whenSocketTimeout_shouldReportVulnerability() -> None:
    """Test check method when socket times out."""
    exploit = cve_2025_0282.IvantiConnectSecureExploit()
    target = definitions.Target("https", "localhost", 443)

    mock_socket = mock.Mock(spec=ssl.SSLSocket)
    mock_socket.recv.return_value = b"HTTP/1.1 101 Switching Protocols\r\n"
    # Simulate timeout after initial response
    mock_socket.read.side_effect = [
        struct.pack(">IIII", 0x5597, 1, 20, 0),  # Version response header
        b"\x00\x01\x02\x02",  # Version response data
        struct.pack(">IIII", 0xA4C, 0x87, 48, 1),  # Auth challenge header
        b"A" * 32,  # Auth challenge data
        socket.timeout("Test timeout"),  # Timeout on auth response
    ]

    with (
        mock.patch.object(exploit, "session") as mock_session,
        mock.patch("ssl.create_default_context") as mock_ssl_ctx,
        mock.patch("socket.create_connection") as mock_create_conn,
    ):
        mock_session.get.return_value = mock.Mock(
            text='<PARAM NAME="ProductVersion" VALUE="22.7.2.4">',
            raise_for_status=mock.Mock(),
        )
        mock_ssl_ctx.return_value.wrap_socket.return_value = mock_socket
        mock_create_conn.return_value = mock_socket

        vulnerabilities = exploit.check(target)

        assert len(vulnerabilities) == 1
        assert vulnerabilities[0].entry.title == cve_2025_0282.VULNERABILITY_TITLE


def testCheck_whenSocketCloseFails_shouldLogError() -> None:
    """Test check method when socket close fails."""
    exploit = cve_2025_0282.IvantiConnectSecureExploit()
    target = definitions.Target("https", "localhost", 443)

    mock_socket = mock.Mock(spec=ssl.SSLSocket)
    mock_socket.recv.return_value = b"HTTP/1.1 101 Switching Protocols\r\n"
    # Simulate successful vulnerability detection
    mock_socket.read.side_effect = [
        struct.pack(">IIII", 0x5597, 1, 20, 0),  # Version response header
        b"\x00\x01\x02\x02",  # Version response data
        struct.pack(">IIII", 0xA4C, 0x87, 48, 1),  # Auth challenge header
        b"A" * 32,  # Auth challenge data
        socket.error("Connection reset by peer"),  # Simulate crash
    ]
    mock_socket.close.side_effect = socket.error("Test close error")

    with (
        mock.patch.object(exploit, "session") as mock_session,
        mock.patch("ssl.create_default_context") as mock_ssl_ctx,
        mock.patch("socket.create_connection") as mock_create_conn,
        mock.patch("logging.error") as mock_logging,
    ):
        mock_session.get.return_value = mock.Mock(
            text='<PARAM NAME="ProductVersion" VALUE="22.7.2.4">',
            raise_for_status=mock.Mock(),
        )
        mock_ssl_ctx.return_value.wrap_socket.return_value = mock_socket
        mock_create_conn.return_value = mock_socket

        vulnerabilities = exploit.check(target)

        assert len(vulnerabilities) == 1
        # Verify both the vulnerability detection and close error logging
        assert vulnerabilities[0].entry.title == cve_2025_0282.VULNERABILITY_TITLE
        mock_logging.assert_any_call(
            "Socket error while closing socket: %s", "Test close error"
        )
