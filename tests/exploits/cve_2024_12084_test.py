"""Unit tests for CVE-2024-12084"""

import socket
from typing import Callable, Any

from agent import definitions
from agent.exploits import cve_2024_12084


# Dummy socket to simulate a network connection.
class DummySocket:
    def __init__(self) -> None:
        self.sent: list[bytes] = []  # Type annotation added for 'sent'

    def send(self, payload: bytes) -> int:
        self.sent.append(payload)
        return len(payload)

    def recv(self, bufsize: int) -> bytes:
        return b""

    def close(self) -> None:
        pass


# Dummy _get_socket that always returns a dummy socket.
def dummy_get_socket_success(host: str, port: int, timeout: float) -> DummySocket:
    return DummySocket()


# Dummy _get_socket that simulates a socket error by raising OSError.
def dummy_get_socket_failure(host: str, port: int, timeout: float) -> None:
    raise OSError("Simulated socket error")


# Factory to create a dummy _req_response that returns responses in a predefined order.
def dummy_req_response_factory(
    responses: list[bytes],
) -> Callable[[socket.socket, bytes | None, bool, bool], bytes | int]:
    def dummy_req_response(
        sock: socket.socket,
        payload: bytes | None,
        expect_resp: bool = True,
        do_req: bool = True,
    ) -> bytes | int:
        if len(responses) > 0:
            return responses.pop(0)
        return b""

    return dummy_req_response


# Dummy _req_response for the hello message.
def dummy_req_response_hello(
    sock: socket.socket,
    payload: bytes | None,
    expect_resp: bool = True,
    do_req: bool = True,
) -> bytes:
    if payload == b"@RSYNCD: 29.0 sha512 sha256 sha1 md5 md4\n":
        return payload
    return b""


# Dummy _req_response that always returns an invalid response.
def dummy_req_response_invalid(
    sock: socket.socket,
    payload: bytes | None,
    expect_resp: bool = True,
    do_req: bool = True,
) -> bytes:
    return b"Invalid response"


def testCVE202412084_whenTargetIsRsync_shouldReturnTrue(monkeypatch: Any) -> None:
    target = definitions.Target(
        scheme="rsync", host="127.0.0.1", port=cve_2024_12084.DEFAULT_RSYNC_PORT
    )
    exploit_instance = cve_2024_12084.RsyncHeapBufferOverflowExploit()

    monkeypatch.setattr(cve_2024_12084, "_get_socket", dummy_get_socket_success)
    monkeypatch.setattr(cve_2024_12084, "_req_response", dummy_req_response_hello)

    accept = exploit_instance.accept(target)
    assert accept is True


def testCVE202412084_whenHelloResponseIsInvalid_shouldRejects(monkeypatch: Any) -> None:
    target = definitions.Target(
        scheme="rsync", host="127.0.0.1", port=cve_2024_12084.DEFAULT_RSYNC_PORT
    )
    exploit_instance = cve_2024_12084.RsyncHeapBufferOverflowExploit()

    monkeypatch.setattr(cve_2024_12084, "_get_socket", dummy_get_socket_success)
    monkeypatch.setattr(cve_2024_12084, "_req_response", dummy_req_response_invalid)

    accept = exploit_instance.accept(target)
    assert accept is False


def testCVE202412084_whenExploitSucceed_shouldReportVulnerability(
    monkeypatch: Any,
) -> None:
    target = definitions.Target(
        scheme="rsync", host="127.0.0.1", port=cve_2024_12084.DEFAULT_RSYNC_PORT
    )
    exploit_instance = cve_2024_12084.RsyncHeapBufferOverflowExploit()

    # Expected responses in the order of _req_response calls during check():
    # 1. hello response: valid hello message
    # 2. module response: contains b'@RSYNCD: OK'
    # 3. response for '--server\n' call (dummy value)
    # 4. sender args response: contains b'\x67'
    # 5. response for b'\x00\x00\x00\x00' call (dummy value)
    # 6. file list response: non-empty (e.g. b'flist')
    # 7. response from _write_sum_head (dummy non-empty, e.g. b'sumhead')
    # 8. final response: non-empty (e.g. b'final')
    # 9. response for the final no-response call (dummy value)
    responses = [
        b"@RSYNCD: 29.0 sha512 sha256 sha1 md5 md4\n",  # hello
        b"@RSYNCD: OK",  # module
        b"\x01",  # for '--server\n'
        b"\x67",  # sender args response
        b"\x01",  # for b'\x00\x00\x00\x00'
        b"flist",  # file list response
        b"sumhead",  # response from sum head
        b"final",  # final response
        b"\x01",  # dummy for final no-response
    ]
    dummy_req_response = dummy_req_response_factory(responses)
    monkeypatch.setattr(cve_2024_12084, "_get_socket", dummy_get_socket_success)
    monkeypatch.setattr(cve_2024_12084, "_req_response", dummy_req_response)

    vulnerabilities = exploit_instance.check(target)
    assert len(vulnerabilities) > 0
    vuln = vulnerabilities[0]
    assert vuln.entry.title == "Rsync Heap Buffer Overflow"
    assert vuln.risk_rating.name == "HIGH"
    assert vuln.vulnerability_location is not None
    assert vuln.dna is not None


def testCVE202412084_whenExploitationFails_shouldNotReportVulnerability(
    monkeypatch: Any,
) -> None:
    target = definitions.Target(
        scheme="rsync", host="127.0.0.1", port=cve_2024_12084.DEFAULT_RSYNC_PORT
    )
    exploit_instance = cve_2024_12084.RsyncHeapBufferOverflowExploit()

    # Simulate failure: valid hello but an invalid module response.
    responses = [
        b"@RSYNCD: 29.0 sha512 sha256 sha1 md5 md4\n",  # hello valid
        b"Invalid module response",  # invalid module response
    ]
    dummy_req_response = dummy_req_response_factory(responses)
    monkeypatch.setattr(cve_2024_12084, "_get_socket", dummy_get_socket_success)
    monkeypatch.setattr(cve_2024_12084, "_req_response", dummy_req_response)

    vulnerabilities = exploit_instance.check(target)
    assert len(vulnerabilities) == 0


def testCVE202412084_whenSocketErrorOccurs_shouldHandleCorrectly(
    monkeypatch: Any,
) -> None:
    target = definitions.Target(
        scheme="rsync", host="127.0.0.1", port=cve_2024_12084.DEFAULT_RSYNC_PORT
    )
    exploit_instance = cve_2024_12084.RsyncHeapBufferOverflowExploit()

    monkeypatch.setattr(cve_2024_12084, "_get_socket", dummy_get_socket_failure)
    monkeypatch.setattr(cve_2024_12084, "_req_response", dummy_req_response_hello)

    accept = exploit_instance.accept(target)
    assert accept is False

    vulnerabilities = exploit_instance.check(target)
    assert len(vulnerabilities) == 0


def testCVE202412084_whenOSErrorOccursDuringPayloadSending_shouldReturnNone(
    monkeypatch: Any,
) -> None:
    target = definitions.Target(
        scheme="rsync", host="127.0.0.1", port=cve_2024_12084.DEFAULT_RSYNC_PORT
    )
    exploit_instance = cve_2024_12084.RsyncHeapBufferOverflowExploit()

    # Mock _req_response to raise an OSError when sending payload.
    def dummy_req_response_with_error(
        sock: socket.socket,
        payload: bytes | None,
        expect_resp: bool = True,
        do_req: bool = True,
    ) -> bytes | int:
        if do_req is True and payload is not None:
            raise OSError("Simulated payload sending error")
        return b""

    monkeypatch.setattr(cve_2024_12084, "_get_socket", dummy_get_socket_success)
    monkeypatch.setattr(cve_2024_12084, "_req_response", dummy_req_response_with_error)

    vulnerabilities = exploit_instance.check(target)
    assert len(vulnerabilities) == 0


def testCVE202412084_whenBadModuleResponse_shouldReturnEmptyVulnerabilities(
    monkeypatch: Any,
) -> None:
    target = definitions.Target(
        scheme="rsync", host="127.0.0.1", port=cve_2024_12084.DEFAULT_RSYNC_PORT
    )
    exploit_instance = cve_2024_12084.RsyncHeapBufferOverflowExploit()

    # Simulate bad module response
    responses = [
        b"@RSYNCD: 29.0 sha512 sha256 sha1 md5 md4\n",  # hello valid
        b"@RSYNCD: OK",  # module request valid
        b"Invalid module response",  # Invalid response for module request
    ]
    dummy_req_response = dummy_req_response_factory(responses)
    monkeypatch.setattr(cve_2024_12084, "_get_socket", dummy_get_socket_success)
    monkeypatch.setattr(cve_2024_12084, "_req_response", dummy_req_response)

    vulnerabilities = exploit_instance.check(target)
    assert len(vulnerabilities) == 0


def testCVE202412084_whenSocketCannotConnect_shouldReturnEmptyVulnerabilities(
        monkeypatch: Any,
) -> None:
    target = definitions.Target(
        scheme="rsync", host="127.0.0.1", port=cve_2024_12084.DEFAULT_RSYNC_PORT
    )
    exploit_instance = cve_2024_12084.RsyncHeapBufferOverflowExploit()

    # Mock _get_socket to simulate failure scenario.
    monkeypatch.setattr(cve_2024_12084, "_get_socket", dummy_get_socket_failure)

    # Mock _req_response to simulate a valid response.
    monkeypatch.setattr(cve_2024_12084, "_req_response", dummy_req_response_hello)

    vulnerabilities = exploit_instance.check(target)
    assert len(vulnerabilities) == 0


def testCVE202412084_whenPaddingIsRequired_shouldPadPayloadCorrectly(
        monkeypatch: Any,
) -> None:
    target = definitions.Target(
        scheme="rsync", host="127.0.0.1", port=cve_2024_12084.DEFAULT_RSYNC_PORT
    )
    exploit_instance = cve_2024_12084.RsyncHeapBufferOverflowExploit()

    # Mock _get_socket to simulate success
    monkeypatch.setattr(cve_2024_12084, "_get_socket", dummy_get_socket_success)

    # Simulate _req_response returning a valid response
    monkeypatch.setattr(cve_2024_12084, "_req_response", dummy_req_response_hello)

    # Padding occurs when s2length > 2, set s2length to a value greater than 2
    s2length = 10  # This should trigger padding behavior
    sock = socket.socket()

    # Call the public method that indirectly invokes _write_sum_head()
    success = exploit_instance.check(target)

    # Assert the padding was correctly applied (check if the last 10 bytes are 'A's)
    assert sock.sent[0][-10:] == b"A" * 10  # Padding of 10 'A's
