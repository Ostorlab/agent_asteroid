"""Unit tests for CVE-2024-12084"""

import socket
from typing import Callable, Any

from agent import definitions
from agent.exploits import cve_2024_12084


# Dummy socket to simulate a network connection.
class DummySocket:
    def __init__(self) -> None:
        self.sent: list[bytes] = []
        self._timeout: float = 5.0

    def send(self, payload: bytes) -> int:
        self.sent.append(payload)
        return len(payload)

    def recv(self, bufsize: int) -> bytes:
        # Always return empty unless overridden by the dummy _send_and_receive.
        return b""

    def settimeout(self, timeout: float) -> None:
        self._timeout = timeout

    def gettimeout(self) -> float:
        return self._timeout

    def close(self) -> None:
        pass


# Dummy _get_socket that always returns a dummy socket.
def dummy_get_socket_success(host: str, port: int, timeout: float) -> DummySocket:
    return DummySocket()


# Dummy _get_socket that simulates a socket error by raising OSError.
def dummy_get_socket_failure(host: str, port: int, timeout: float) -> None:
    raise OSError("Simulated socket error")


# Factory to create a dummy _send_and_receive function that returns responses in a predefined order.
def dummy_send_and_receive_factory(
    responses: list[bytes],
) -> Callable[[socket.socket, bytes | None, bool, float], bytes | int]:
    def dummy_send_and_receive(
        sock: socket.socket,
        payload: bytes | None,
        expect_resp: bool = True,
        timeout: float = 5.0,
    ) -> bytes | int:
        if payload is None:
            payload = b""
        if expect_resp is False:
            return len(payload)
        if len(responses) > 0:
            return responses.pop(0)
        return b""

    return dummy_send_and_receive


# Dummy _send_and_receive that raises an OSError when sending a payload.
def dummy_send_and_receive_raise(
    sock: socket.socket,
    payload: bytes | None,
    expect_resp: bool = True,
    timeout: float = 5.0,
) -> bytes | int:
    if payload is not None:
        raise OSError("Simulated payload sending error")
    return b""


# Dummy _send_and_receive for the hello message.
def dummy_send_and_receive_hello(
    sock: socket.socket,
    payload: bytes | None,
    expect_resp: bool = True,
    timeout: float = 5.0,
) -> bytes:
    if payload == b"@RSYNCD: 31.0\n":
        return payload
    return b""


# Dummy _send_and_receive that always returns an invalid response.
def dummy_send_and_receive_invalid(
    sock: socket.socket,
    payload: bytes | None,
    expect_resp: bool = True,
    timeout: float = 5.0,
) -> bytes:
    return b"Invalid response"


# Dummy _send_and_receive that distinguishes the banner from non-response cases.
def dummy_send_and_receive_expect_false(
    sock: socket.socket,
    payload: bytes | None,
    expect_resp: bool = True,
    timeout: float = 5.0,
) -> bytes | int:
    # If the banner is sent, return the correct banner.
    if payload == b"@RSYNCD: 31.0\n" and expect_resp is True:
        return b"@RSYNCD: 31.0\n"
    # For non-response cases, return the length of the payload.
    if not expect_resp:
        return len(payload) if payload is not None else 0
    return b"response"


def testCVE202412084_accept_valid(monkeypatch: Any) -> None:
    target = definitions.Target(
        scheme="rsync", host="127.0.0.1", port=cve_2024_12084.DEFAULT_RSYNC_PORT
    )
    exploit_instance = cve_2024_12084.RsyncHeapBufferOverflowExploit()

    monkeypatch.setattr(cve_2024_12084, "_get_socket", dummy_get_socket_success)
    monkeypatch.setattr(
        cve_2024_12084, "_send_and_receive", dummy_send_and_receive_hello
    )

    # Valid hello response should make accept() return True.
    assert exploit_instance.accept(target) is True


def testCVE202412084_accept_invalid_hello(monkeypatch: Any) -> None:
    target = definitions.Target(
        scheme="rsync", host="127.0.0.1", port=cve_2024_12084.DEFAULT_RSYNC_PORT
    )
    exploit_instance = cve_2024_12084.RsyncHeapBufferOverflowExploit()

    # Simulate an invalid hello response.
    monkeypatch.setattr(cve_2024_12084, "_get_socket", dummy_get_socket_success)
    monkeypatch.setattr(
        cve_2024_12084,
        "_send_and_receive",
        lambda s, p, expect_resp=True, timeout=5.0: b"Bad response",
    )

    assert exploit_instance.accept(target) is False


def testCVE202412084_check_success(monkeypatch: Any) -> None:
    """
    Simulate a full successful exploit:
      1. Hello handshake returns valid banner.
      2. Module request returns '@RSYNCD: OK'.
      3. Minimal command-line handshake (newline) is accepted.
      4. File list termination (null byte) is sent.
      5. Sum payload returns a dummy non-empty response.
      6. Final payload (no response expected) is sent.
    """
    target = definitions.Target(
        scheme="rsync", host="127.0.0.1", port=cve_2024_12084.DEFAULT_RSYNC_PORT
    )
    exploit_instance = cve_2024_12084.RsyncHeapBufferOverflowExploit()

    responses = [
        b"@RSYNCD: 31.0\n",  # Step 1: hello response
        b"@RSYNCD: OK",  # Step 2: module response
        b"\n",  # Step 3: command-line handshake response
        b"",  # Step 4: file list termination (no response expected)
        b"sum response",  # Step 5: response from sending the sum_struct payload
        b"",  # Step 6: final payload (no response expected)
    ]
    dummy_send_and_receive = dummy_send_and_receive_factory(responses)
    monkeypatch.setattr(cve_2024_12084, "_get_socket", dummy_get_socket_success)
    monkeypatch.setattr(cve_2024_12084, "_send_and_receive", dummy_send_and_receive)

    vulnerabilities = exploit_instance.check(target)
    assert len(vulnerabilities) > 0
    vuln = vulnerabilities[0]
    assert vuln.entry.title == "Rsync Heap Buffer Overflow"
    assert vuln.risk_rating.name == "CRITICAL"
    # Ensure that we have a location and a DNA string.
    assert vuln.vulnerability_location is not None
    assert vuln.dna is not None


def testCVE202412084_check_module_failure(monkeypatch: Any) -> None:
    """
    Simulate failure in the module handshake:
      - Valid hello response.
      - Invalid module response.
    """
    target = definitions.Target(
        scheme="rsync", host="127.0.0.1", port=cve_2024_12084.DEFAULT_RSYNC_PORT
    )
    exploit_instance = cve_2024_12084.RsyncHeapBufferOverflowExploit()

    responses = [
        b"@RSYNCD: 31.0\n",  # Valid hello response.
        b"Invalid module response",  # Module handshake fails.
    ]
    dummy_send_and_receive = dummy_send_and_receive_factory(responses)
    monkeypatch.setattr(cve_2024_12084, "_get_socket", dummy_get_socket_success)
    monkeypatch.setattr(cve_2024_12084, "_send_and_receive", dummy_send_and_receive)

    vulnerabilities = exploit_instance.check(target)
    assert len(vulnerabilities) == 0


def testCVE202412084_socket_error(monkeypatch: Any) -> None:
    """
    Simulate a socket connection error.
    Both accept() and check() should handle the error and return False or empty vulnerabilities.
    """
    target = definitions.Target(
        scheme="rsync", host="127.0.0.1", port=cve_2024_12084.DEFAULT_RSYNC_PORT
    )
    exploit_instance = cve_2024_12084.RsyncHeapBufferOverflowExploit()

    monkeypatch.setattr(cve_2024_12084, "_get_socket", dummy_get_socket_failure)
    monkeypatch.setattr(
        cve_2024_12084, "_send_and_receive", dummy_send_and_receive_hello
    )

    assert exploit_instance.accept(target) is False
    vulnerabilities = exploit_instance.check(target)
    assert len(vulnerabilities) == 0


def testCVE202412084_payload_sending_error(monkeypatch: Any) -> None:
    """
    Simulate an error when sending the payload (e.g. during the sum_struct transmission).
    The exploit should catch the error and not report any vulnerability.
    """
    target = definitions.Target(
        scheme="rsync", host="127.0.0.1", port=cve_2024_12084.DEFAULT_RSYNC_PORT
    )
    exploit_instance = cve_2024_12084.RsyncHeapBufferOverflowExploit()

    monkeypatch.setattr(cve_2024_12084, "_get_socket", dummy_get_socket_success)
    monkeypatch.setattr(
        cve_2024_12084, "_send_and_receive", dummy_send_and_receive_raise
    )

    vulnerabilities = exploit_instance.check(target)
    assert len(vulnerabilities) == 0


def testCVE202412084_expect_resp_false(monkeypatch: Any) -> None:
    """
    Test the branch in _send_and_receive where expect_resp is False.
    This is used in some parts of the exploit to send data without waiting for a response.
    """
    target = definitions.Target(
        scheme="rsync", host="127.0.0.1", port=cve_2024_12084.DEFAULT_RSYNC_PORT
    )
    exploit_instance = cve_2024_12084.RsyncHeapBufferOverflowExploit()

    monkeypatch.setattr(cve_2024_12084, "_get_socket", dummy_get_socket_success)
    monkeypatch.setattr(
        cve_2024_12084, "_send_and_receive", dummy_send_and_receive_expect_false
    )

    vulnerabilities = exploit_instance.check(target)

    # Even if the final responses are dummy, the overall process should not crash.
    assert vulnerabilities is not None
    assert exploit_instance.accept(target) is True
