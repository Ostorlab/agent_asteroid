"""Unit tests for CVE-2025-23016"""

import socket
import struct
from unittest import mock

from agent import definitions
from agent.exploits import cve_2025_23016

# --- Tests for accept() ---


def testAccept_whenFastcgiServiceDetected_shouldReturnTrue(
    mock_create_connection: mock.MagicMock, mock_socket_instance: mock.MagicMock
) -> None:
    """Test accept() works when server responds as expected (e.g., STDOUT)."""
    target = definitions.Target(scheme="http", host="127.0.0.1", port=9000)
    exp = cve_2025_23016.FastCGIIntegerOverflowExploit()
    # Mock server responding with STDOUT header, content=10, padding=6
    response_header = struct.pack(">BBHHBB", 1, cve_2025_23016.FCGI_STDOUT, 1, 10, 6, 0)
    response_body = b"A" * 10
    response_pad = b"B" * 6
    mock_socket_instance.recv.side_effect = [
        response_header,
        response_body,
        response_pad,
    ]

    assert exp.accept(target) is True

    send_calls = mock_socket_instance.sendall.call_args_list
    assert len(send_calls) == 3  # BEGIN_REQ, empty PARAMS, empty STDIN

    recv_calls = mock_socket_instance.recv.call_args_list
    assert len(recv_calls) == 3  # Initial header(8), body(10), padding(6)
    assert recv_calls[0] == mock.call(8)
    assert recv_calls[1] == mock.call(10, socket.MSG_WAITALL)
    assert recv_calls[2] == mock.call(6, socket.MSG_WAITALL)


def testAccept_whenSocketTimeout_shouldReturnFalse(
    mock_create_connection: mock.MagicMock, mock_socket_instance: mock.MagicMock
) -> None:
    """Test accept() when socket recv times out."""
    target = definitions.Target(scheme="http", host="127.0.0.1", port=9000)
    exp = cve_2025_23016.FastCGIIntegerOverflowExploit()
    mock_socket_instance.recv.side_effect = socket.timeout()
    assert exp.accept(target) is False


def testAccept_whenConnectionRefused_shouldReturnFalse(
    mock_create_connection: mock.MagicMock,
) -> None:
    """Test accept() when connection is refused."""
    target = definitions.Target(scheme="http", host="127.0.0.1", port=9000)
    exp = cve_2025_23016.FastCGIIntegerOverflowExploit()
    mock_create_connection.side_effect = ConnectionRefusedError()
    assert exp.accept(target) is False


def testAccept_whenNoResponse_shouldReturnFalse(
    mock_create_connection: mock.MagicMock, mock_socket_instance: mock.MagicMock
) -> None:
    """Test accept() when server sends nothing back (empty bytes)."""
    target = definitions.Target(scheme="http", host="127.0.0.1", port=9000)
    exp = cve_2025_23016.FastCGIIntegerOverflowExploit()
    mock_socket_instance.recv.return_value = b""
    assert exp.accept(target) is False


def testAccept_whenIncompleteHeader_shouldReturnFalse(
    mock_create_connection: mock.MagicMock, mock_socket_instance: mock.MagicMock
) -> None:
    """Test accept() when server sends less than 8 bytes."""
    target = definitions.Target(scheme="http", host="127.0.0.1", port=9000)
    exp = cve_2025_23016.FastCGIIntegerOverflowExploit()
    mock_socket_instance.recv.return_value = b"\x01\x01\x00\x01"  # Only 4 bytes
    assert exp.accept(target) is False


def testAccept_whenStructUnpackError_shouldReturnFalse(
    mock_create_connection: mock.MagicMock, mock_socket_instance: mock.MagicMock
) -> None:
    """Test accept() when received bytes don't unpack."""
    target = definitions.Target(scheme="http", host="127.0.0.1", port=9000)
    exp = cve_2025_23016.FastCGIIntegerOverflowExploit()
    mock_socket_instance.recv.return_value = (
        b"ABCDEFGH"  # Valid length, invalid content for unpack
    )
    assert exp.accept(target) is False


def testAccept_whenUnexpectedResponseType_shouldReturnFalse(
    mock_create_connection: mock.MagicMock, mock_socket_instance: mock.MagicMock
) -> None:
    """Test accept() when server sends an unexpected but valid FCGI type."""
    target = definitions.Target(scheme="http", host="127.0.0.1", port=9000)
    exp = cve_2025_23016.FastCGIIntegerOverflowExploit()
    # FCGI_GET_VALUES_RESULT = 10, not in the allowed list for accept probe response
    header_bytes = struct.pack(">BBHHBB", 1, 10, 1, 0, 0, 0)
    mock_socket_instance.recv.return_value = header_bytes
    assert exp.accept(target) is False


# --- Tests for check() ---


@mock.patch(
    "agent.exploits.cve_2025_23016.FastCGIIntegerOverflowExploit._trigger_heap_overflow"
)
def testCheck_whenTriggerSucceeds_shouldReportVuln(
    mock_trigger: mock.MagicMock,
) -> None:
    """Test check() reports vuln when _trigger_heap_overflow returns True."""
    target = definitions.Target(scheme="http", host="127.0.0.1", port=9000)
    exp = cve_2025_23016.FastCGIIntegerOverflowExploit()
    mock_trigger.return_value = True
    vulns = exp.check(target)
    assert len(vulns) == 1
    mock_trigger.assert_called_once_with(target)


@mock.patch(
    "agent.exploits.cve_2025_23016.FastCGIIntegerOverflowExploit._trigger_heap_overflow"
)
def testCheck_whenTriggerFails_shouldReportNothing(
    mock_trigger: mock.MagicMock,
) -> None:
    """Test check() reports nothing when _trigger_heap_overflow returns False."""
    target = definitions.Target(scheme="http", host="127.0.0.1", port=9000)
    exp = cve_2025_23016.FastCGIIntegerOverflowExploit()
    mock_trigger.return_value = False
    vulns = exp.check(target)
    assert len(vulns) == 0
    mock_trigger.assert_called_once_with(target)


# --- Tests for _trigger_heap_overflow() ---


def testTriggerHeapOverflow_whenSendSucceeds_returnsTrue(
    mock_create_connection: mock.MagicMock, mock_socket_instance: mock.MagicMock
) -> None:
    """Test _trigger_heap_overflow returns True on successful send."""
    target = definitions.Target(scheme="http", host="127.0.0.1", port=9000)
    exp = cve_2025_23016.FastCGIIntegerOverflowExploit()
    mock_socket_instance.sendall.return_value = None
    result = exp._trigger_heap_overflow(target)
    assert result is True
    assert mock_socket_instance.sendall.call_count >= 4  # pre-crash+main sends


def testTriggerHeapOverflow_whenSendErrors_returnsFalse(
    mock_create_connection: mock.MagicMock, mock_socket_instance: mock.MagicMock
) -> None:
    """Test _trigger_heap_overflow returns False if sendall errors."""
    target = definitions.Target(scheme="http", host="127.0.0.1", port=9000)
    exp = cve_2025_23016.FastCGIIntegerOverflowExploit()
    mock_socket_instance.sendall.side_effect = [
        None,
        None,
        None,
        socket.error("Send failed"),
    ]  # Error on main PARAMS send
    result = exp._trigger_heap_overflow(target)
    assert result is False


def testTriggerHeapOverflow_whenPreCrashErrors_stillAttemptsMainPayload(
    mock_create_connection: mock.MagicMock, mock_socket_instance: mock.MagicMock
) -> None:
    """Test _trigger continues even if pre-crash fails."""
    target = definitions.Target(scheme="http", host="127.0.0.1", port=9000)
    exp = cve_2025_23016.FastCGIIntegerOverflowExploit()

    # Mock pre-crash connection to fail, but main connection to succeed
    mock_create_connection.side_effect = [
        ConnectionRefusedError("Pre-crash failed"),  # Error on first call
        mock_socket_instance,  # Success on second call
    ]
    mock_socket_instance.sendall.return_value = (
        None  # Assume sends succeed for main attempt
    )

    result = exp._trigger_heap_overflow(target)

    assert result is True  # Should succeed if main payload sends
    # Verify create_connection was called twice
    assert mock_create_connection.call_count == 2
    # Verify sendall was called for the main payload attempt
    # BEGIN_REQ, PARAMS, empty PARAMS, empty STDIN -> 4 calls
    assert mock_socket_instance.sendall.call_count == 4


# --- Tests for encode_param ---
def testEncodeParam_whenSmallValues_shouldEncodeCorrectly() -> None:
    result = cve_2025_23016.encode_param(b"test", b"value")
    assert len(result) == 11
    assert result[0] == 4
    assert result[1] == 5


def testEncodeParam_whenLargeName_shouldEncodCorrectly() -> None:
    name = b"x" * 200
    value = b"y" * 10
    result = cve_2025_23016.encode_param(name, value)
    assert len(result) == 215
    name_len_encoded = struct.unpack(">I", result[0:4])[0]
    assert name_len_encoded == (200 | 0x80000000)
