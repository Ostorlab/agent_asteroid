"""Unit tests for Agent Asteroid: CVE-2025-32756"""

from unittest import mock

import requests  # For requests.exceptions

from agent import definitions
from agent.exploits import cve_2025_32756  # This is the module under test


# Helper to setup a basic pwn mock for exploit instantiation and basic operations
def _get_mock_pwn_module() -> mock.MagicMock:
    """Creates a mock pwn module object with necessary attributes for exploit initialization and basic functions."""
    mock_pwn = mock.MagicMock()
    # Attributes for __init__
    mock_pwn.context = mock.MagicMock()
    mock_pwn.context.arch = cve_2025_32756.TARGET_ARCHITECTURE
    mock_pwn.context.endian = cve_2025_32756.TARGET_ENDIANNESS
    if cve_2025_32756.TARGET_ARCHITECTURE in ["amd64", "aarch64"]:
        mock_pwn.context.bits = 64
    elif cve_2025_32756.TARGET_ARCHITECTURE in ["i386", "arm"]:
        mock_pwn.context.bits = 32
    else:
        # Fallback if arch not explicitly handled, matching exploit logic
        mock_pwn.context.bits = (
            64 if cve_2025_32756.TARGET_ARCHITECTURE == "amd64" else 32
        )

    # Methods for _pack_address
    mock_pwn.p64 = mock.MagicMock(return_value=b"\x01\x02\x03\x04\x05\x06\x07\x08")
    mock_pwn.p32 = mock.MagicMock(return_value=b"\x01\x02\x03\x04")

    # Exception type for _pack_address
    mock_pwn.pwnlib = mock.MagicMock()
    mock_pwn.pwnlib.exception = mock.MagicMock()
    mock_pwn.pwnlib.exception.PwnlibException = type(
        "PwnlibException", (Exception,), {}
    )

    return mock_pwn


# --- Tests for accept() method ---


@mock.patch("requests.Session.get")  # Patch Session.get used by exploit.http.get
def testAccept_whenFortinetIndicatorHttpAnd200_shouldReturnTrue(
    mock_requests_session_get: mock.Mock,
) -> None:
    """Test accept method with HTTP target, Fortinet indicator, and 200 status."""
    mock_response = mock.Mock()
    mock_response.text = "Welcome to FortiMail Gateway"
    mock_response.content = b"Welcome to FortiMail Gateway"
    mock_response.status_code = 200
    mock_requests_session_get.return_value = mock_response

    # pwn needs to be mocked for __init__
    with mock.patch("agent.exploits.cve_2025_32756.pwn", _get_mock_pwn_module()):
        exploit = cve_2025_32756.FortinetCVE202532756Exploit()

    target = definitions.Target(host="localhost", port=80, scheme="http")
    assert exploit.accept(target) is True
    mock_requests_session_get.assert_called_once()
    call_args = mock_requests_session_get.call_args[0]
    assert call_args[0] == "http://localhost:80/user/login"


@mock.patch("requests.Session.get")
def testAccept_whenFortinetIndicatorHttpsAnd200_shouldReturnTrue(
    mock_requests_session_get: mock.Mock,
) -> None:
    """Test accept method with HTTPS target, Fortinet indicator, and 200 status."""
    mock_response = mock.Mock()
    mock_response.text = "FortiVoice Administration Interface"
    mock_response.content = b"FortiVoice Administration Interface"
    mock_response.status_code = 200
    mock_requests_session_get.return_value = mock_response

    with mock.patch("agent.exploits.cve_2025_32756.pwn", _get_mock_pwn_module()):
        exploit = cve_2025_32756.FortinetCVE202532756Exploit()

    target = definitions.Target(host="localhost", port=443, scheme="http")
    assert exploit.accept(target) is True
    mock_requests_session_get.assert_called_once()
    call_args = mock_requests_session_get.call_args[0]
    assert call_args[0] == "https://localhost:443/user/login"


@mock.patch("requests.Session.get")
def testAccept_whenNoFortinetIndicatorAnd200_shouldReturnFalse(
    mock_requests_session_get: mock.Mock,
) -> None:
    """Test accept method when no Fortinet indicator is present."""
    mock_response = mock.Mock()
    mock_response.text = "Some other web server"
    mock_response.content = b"Some other web server"
    mock_response.status_code = 200
    mock_requests_session_get.return_value = mock_response

    with mock.patch("agent.exploits.cve_2025_32756.pwn", _get_mock_pwn_module()):
        exploit = cve_2025_32756.FortinetCVE202532756Exploit()

    target = definitions.Target(host="localhost", port=80, scheme="http")
    assert exploit.accept(target) is False


@mock.patch("requests.Session.get")
def testAccept_whenRequestException_shouldReturnFalse(
    mock_requests_session_get: mock.Mock,
) -> None:
    """Test accept method when a request exception occurs."""
    mock_requests_session_get.side_effect = requests.exceptions.RequestException(
        "Connection error"
    )

    with mock.patch("agent.exploits.cve_2025_32756.pwn", _get_mock_pwn_module()):
        exploit = cve_2025_32756.FortinetCVE202532756Exploit()

    target = definitions.Target(host="localhost", port=80, scheme="http")
    assert exploit.accept(target) is False


@mock.patch("requests.Session.get")
def testAccept_whenHttpStatusNot200OrBelow500_shouldReturnFalse(
    mock_requests_session_get: mock.Mock,
) -> None:
    """Test accept method when HTTP status is a server error (e.g., 503)."""
    mock_response = mock.Mock()
    mock_response.text = "Server Error"
    mock_response.content = b"Server Error"
    mock_response.status_code = 503  # Server error
    mock_requests_session_get.return_value = mock_response

    with mock.patch("agent.exploits.cve_2025_32756.pwn", _get_mock_pwn_module()):
        exploit = cve_2025_32756.FortinetCVE202532756Exploit()

    target = definitions.Target(host="localhost", port=80, scheme="http")
    assert exploit.accept(target) is False


# --- Tests for check() method ---


def testCheck_whenPwnModuleIsNoneInCheckMethod_shouldReturnEmptyList() -> None:
    """Test check method when pwn is None (guard within check method)."""
    # pwn must be available for __init__
    initial_mock_pwn = _get_mock_pwn_module()
    with mock.patch("agent.exploits.cve_2025_32756.pwn", initial_mock_pwn):
        exploit = cve_2025_32756.FortinetCVE202532756Exploit()

    target = definitions.Target(host="localhost", port=80, scheme="http")

    # Now, simulate pwn being None when check() is called
    with mock.patch("agent.exploits.cve_2025_32756.pwn", None):
        vulnerabilities = exploit.check(target)
        assert len(vulnerabilities) == 0


@mock.patch("agent.exploits.cve_2025_32756.pwn")
def testCheck_whenBuildExploitCodeFails_shouldReturnEmptyList(
    mock_pwn_module: mock.Mock,
) -> None:
    """Test check method when _build_exploit_code returns None."""
    mock_pwn_module_instance = _get_mock_pwn_module()
    # Configure the main mock_pwn_module to behave like the instance for __init__
    mock_pwn_module.context = mock_pwn_module_instance.context
    mock_pwn_module.p64 = mock_pwn_module_instance.p64
    mock_pwn_module.p32 = mock_pwn_module_instance.p32
    mock_pwn_module.pwnlib = mock_pwn_module_instance.pwnlib

    exploit = cve_2025_32756.FortinetCVE202532756Exploit()
    target = definitions.Target(host="localhost", port=80, scheme="http")

    with mock.patch.object(
        exploit, "_build_exploit_code", return_value=None
    ) as mock_build:
        vulnerabilities = exploit.check(target)
        assert len(vulnerabilities) == 0
        mock_build.assert_called_once()


@mock.patch("agent.exploits.cve_2025_32756.pwn")
def testCheck_whenCraftPayloadFails_shouldReturnEmptyList(
    mock_pwn_module: mock.Mock,
) -> None:
    """Test check method when _craft_exploit_payload returns None."""
    mock_pwn_module_instance = _get_mock_pwn_module()
    mock_pwn_module.context = mock_pwn_module_instance.context
    mock_pwn_module.p64 = mock_pwn_module_instance.p64
    mock_pwn_module.p32 = mock_pwn_module_instance.p32
    mock_pwn_module.pwnlib = mock_pwn_module_instance.pwnlib

    exploit = cve_2025_32756.FortinetCVE202532756Exploit()
    target = definitions.Target(host="localhost", port=80, scheme="http")

    # _build_exploit_code must succeed for _craft_exploit_payload to be called
    with (
        mock.patch.object(exploit, "_build_exploit_code", return_value=b"dummy_code"),
        mock.patch.object(
            exploit, "_craft_exploit_payload", return_value=None
        ) as mock_craft,
    ):
        vulnerabilities = exploit.check(target)
        assert len(vulnerabilities) == 0
        mock_craft.assert_called_once_with(b"dummy_code")


@mock.patch("agent.exploits.cve_2025_32756.pwn")
@mock.patch(
    "time.sleep", return_value=None
)  # Mock time.sleep in _verify_exploit_success
def testCheck_whenVerificationFails_shouldReturnEmptyList(
    mock_sleep: mock.Mock, mock_pwn_module: mock.Mock
) -> None:
    """Test check method when _verify_exploit_success returns False."""
    mock_pwn_module_instance = _get_mock_pwn_module()
    mock_pwn_module.context = mock_pwn_module_instance.context
    mock_pwn_module.p64 = mock_pwn_module_instance.p64
    mock_pwn_module.p32 = mock_pwn_module_instance.p32
    mock_pwn_module.pwnlib = mock_pwn_module_instance.pwnlib

    exploit = cve_2025_32756.FortinetCVE202532756Exploit()
    target = definitions.Target(host="localhost", port=80, scheme="http")

    with (
        mock.patch.object(exploit, "_build_exploit_code", return_value=b"dummy_code"),
        mock.patch.object(
            exploit, "_craft_exploit_payload", return_value=b"dummy_payload"
        ),
        mock.patch.object(exploit, "_trigger_vulnerability", return_value=True),
        mock.patch.object(
            exploit, "_verify_exploit_success", return_value=False
        ) as mock_verify,
    ):
        vulnerabilities = exploit.check(target)
        assert len(vulnerabilities) == 0
        mock_verify.assert_called_once_with(target.host, target.port)


@mock.patch("agent.exploits.cve_2025_32756.pwn")
@mock.patch(
    "time.sleep", return_value=None
)  # Mock time.sleep in _verify_exploit_success
def testCheck_whenExploitationSucceeds_shouldReportVulnerability(
    mock_sleep: mock.Mock, mock_pwn_module: mock.Mock
) -> None:
    """Test check method when exploitation is successful."""
    mock_pwn_module_instance = _get_mock_pwn_module()
    mock_pwn_module.context = mock_pwn_module_instance.context
    mock_pwn_module.p64 = mock_pwn_module_instance.p64
    mock_pwn_module.p32 = mock_pwn_module_instance.p32
    mock_pwn_module.pwnlib = mock_pwn_module_instance.pwnlib

    exploit = cve_2025_32756.FortinetCVE202532756Exploit()
    target = definitions.Target(host="localhost", port=80, scheme="http")

    with (
        mock.patch.object(
            exploit, "_build_exploit_code", return_value=b"dummy_rop_code"
        ) as mock_build,
        mock.patch.object(
            exploit, "_craft_exploit_payload", return_value=b"full_payload"
        ) as mock_craft,
        mock.patch.object(
            exploit, "_trigger_vulnerability", return_value=True
        ) as mock_trigger,
        mock.patch.object(
            exploit, "_verify_exploit_success", return_value=True
        ) as mock_verify,
    ):
        vulnerabilities = exploit.check(target)

        mock_build.assert_called_once()
        mock_craft.assert_called_once_with(b"dummy_rop_code")
        mock_trigger.assert_called_once_with(b"full_payload", target.host, target.port)
        mock_verify.assert_called_once_with(target.host, target.port)

        assert len(vulnerabilities) == 1
        vuln = vulnerabilities[0]
        assert vuln.entry.title == cve_2025_32756.VULNERABILITY_TITLE
        assert vuln.entry.description == cve_2025_32756.VULNERABILITY_DESCRIPTION
        assert vuln.entry.risk_rating == cve_2025_32756.RISK_RATING
        assert vuln.technical_detail is not None
        assert "CVE-2025-32756" in vuln.technical_detail
        assert vuln.vulnerability_location is not None
        assert vuln.dna is not None
