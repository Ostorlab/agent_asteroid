"""Unit tests for CVE-2025-32756 exploit agent."""

import builtins
import logging
import typing
from unittest import mock

import pytest
import requests
import requests_mock as req_mock
from _pytest.logging import LogCaptureFixture
from _pytest.monkeypatch import MonkeyPatch

from agent.exploits import cve_2025_32756
from agent.exploits.cve_2025_32756 import (
    VERIFICATION_HTTP_FILE_PATH,
    VERIFICATION_HTTP_EXPECTED_CONTENT,
    TARGET_ARCHITECTURE as DEFAULT_TARGET_ARCHITECTURE,
    TARGET_ENDIANNESS as DEFAULT_TARGET_ENDIANNESS,
    ROP_COMMAND_VERIFICATION,
)

try:
    import pwn
    import pwnlib.exception  # type: ignore[import-untyped]

    PWNTOOLS_AVAILABLE = True
except ImportError:
    PWNTOOLS_AVAILABLE = False
    pwn = None
    pwnlib = None


@pytest.fixture
def exploit_instance_fixture(
    monkeypatch: MonkeyPatch,
) -> cve_2025_32756.FortinetCVE202532756Exploit:
    """Fixture to create an instance of the exploit with default constants."""
    if PWNTOOLS_AVAILABLE is False:
        pytest.skip("Pwntools not installed, skipping tests that require it.")

    monkeypatch.setattr(
        cve_2025_32756, "TARGET_ARCHITECTURE", DEFAULT_TARGET_ARCHITECTURE
    )
    monkeypatch.setattr(cve_2025_32756, "TARGET_ENDIANNESS", DEFAULT_TARGET_ENDIANNESS)
    monkeypatch.setattr(cve_2025_32756, "pwn", pwn)

    return cve_2025_32756.FortinetCVE202532756Exploit()


# --- Mock Pwntools Packers ---
def mock_pwn_packers_default(
    addr: int, bits: int = 64, endian: str = "little"
) -> bytes:
    """Default mock for pwn.p64/p32, produces 'clean' bytes for known addresses."""
    byte_order_literal: typing.Literal["little", "big"]
    if endian == "little":
        byte_order_literal = "little"
    elif endian == "big":
        byte_order_literal = "big"
    else:
        raise ValueError(f"Invalid endian value for mock: {endian}")

    if bits == 64:
        # Known good addresses that don't contain bad chars
        if addr == 0x401A23:  # pop_rdi_ret gadget
            return b"\x23\x1a\x40\x00\x00\x00\x00\x00"
        if addr == 0x7FFFF7C50D60:  # system address
            return b"\x60\x0d\xc5\xf7\xff\x7f\x00\x00"
        if addr == 0x41424344454645F8:  # Modified input buffer base
            return b"\xf8\x45\x46\x45\x44\x43\x42\x41"
        if addr == 0x4142434445464760:  # exploit_code_live_ad (calculated)
            return b"\x60\x47\x46\x45\x44\x43\x42\x41"
        if addr == 0x4142434445464788:  # live_cmd_str_ad (calculated)
            return b"\x88\x47\x46\x45\x44\x43\x42\x41"
        # Fallback to to_bytes for other addresses
        return addr.to_bytes(8, byteorder=byte_order_literal, signed=False)
    elif bits == 32:
        if addr == 0x44332211:
            return b"\x11\x22\x33\x44"
        return addr.to_bytes(4, byteorder=byte_order_literal, signed=False)
    raise ValueError(f"Unsupported bits {bits} in mock_pwn_packers_default")


# --- __init__ Tests ---
def testInit_whenArchIsAmd64_shouldSetPointerSize8(monkeypatch: MonkeyPatch) -> None:
    if PWNTOOLS_AVAILABLE is False:
        pytest.skip("Pwntools not available")
    monkeypatch.setattr(cve_2025_32756, "TARGET_ARCHITECTURE", "amd64")
    original_arch = pwn.context.arch
    try:
        instance = cve_2025_32756.FortinetCVE202532756Exploit()
        assert instance.pointer_size == 8
        assert pwn.context.arch == "amd64"
    finally:
        pwn.context.arch = original_arch


def testInit_whenArchIsAarch64_shouldSetPointerSize8(monkeypatch: MonkeyPatch) -> None:
    if PWNTOOLS_AVAILABLE is False:
        pytest.skip("Pwntools not available")
    monkeypatch.setattr(cve_2025_32756, "TARGET_ARCHITECTURE", "aarch64")
    original_arch = pwn.context.arch
    try:
        instance = cve_2025_32756.FortinetCVE202532756Exploit()
        assert instance.pointer_size == 8
        assert pwn.context.arch == "aarch64"
    finally:
        pwn.context.arch = original_arch


def testInit_whenArchIsI386_shouldSetPointerSize4(monkeypatch: MonkeyPatch) -> None:
    if PWNTOOLS_AVAILABLE is False:
        pytest.skip("Pwntools not available")
    monkeypatch.setattr(cve_2025_32756, "TARGET_ARCHITECTURE", "i386")
    original_arch = pwn.context.arch
    try:
        instance = cve_2025_32756.FortinetCVE202532756Exploit()
        assert instance.pointer_size == 4
        assert pwn.context.arch == "i386"
    finally:
        pwn.context.arch = original_arch


def testInit_whenArchIsArm_shouldSetPointerSize4(monkeypatch: MonkeyPatch) -> None:
    if PWNTOOLS_AVAILABLE is False:
        pytest.skip("Pwntools not available")
    monkeypatch.setattr(cve_2025_32756, "TARGET_ARCHITECTURE", "arm")
    original_arch = pwn.context.arch
    try:
        instance = cve_2025_32756.FortinetCVE202532756Exploit()
        assert instance.pointer_size == 4
        assert pwn.context.arch == "arm"
    finally:
        pwn.context.arch = original_arch


@mock.patch("agent.exploits.cve_2025_32756.pwn.context", autospec=True)
def testInit_whenArchIsUnknownAndBits32_shouldSetPointerSize4(
    mock_pwn_ctx: mock.MagicMock, monkeypatch: MonkeyPatch
) -> None:
    if PWNTOOLS_AVAILABLE is False:
        pytest.skip("Pwntools not available")
    monkeypatch.setattr(cve_2025_32756, "TARGET_ARCHITECTURE", "mips")
    mock_pwn_ctx.bits = 32
    instance = cve_2025_32756.FortinetCVE202532756Exploit()
    assert instance.pointer_size == 4
    assert mock_pwn_ctx.arch == "mips"


@mock.patch("agent.exploits.cve_2025_32756.pwn.context", autospec=True)
def testInit_whenArchIsUnknownAndBits64_shouldSetPointerSize8(
    mock_pwn_ctx: mock.MagicMock, monkeypatch: MonkeyPatch
) -> None:
    if PWNTOOLS_AVAILABLE is False:
        pytest.skip("Pwntools not available")
    monkeypatch.setattr(cve_2025_32756, "TARGET_ARCHITECTURE", "mips64")
    mock_pwn_ctx.bits = 64
    instance = cve_2025_32756.FortinetCVE202532756Exploit()
    assert instance.pointer_size == 8
    assert mock_pwn_ctx.arch == "mips64"


@mock.patch("agent.exploits.cve_2025_32756.pwn.context", autospec=True)
def testInit_whenArchAndBitsAreUndeterminable_shouldRaiseValueError(
    mock_pwn_ctx: mock.MagicMock, monkeypatch: MonkeyPatch
) -> None:
    if PWNTOOLS_AVAILABLE is False:
        pytest.skip("Pwntools not available")
    monkeypatch.setattr(cve_2025_32756, "TARGET_ARCHITECTURE", "mips")
    mock_pwn_ctx.bits = 16
    with pytest.raises(builtins.ValueError, match="Could not determine pointer size"):
        cve_2025_32756.FortinetCVE202532756Exploit()


def testInit_whenPwntoolsNotImported_shouldRaiseImportError() -> None:
    with mock.patch("agent.exploits.cve_2025_32756.pwn", None):
        with pytest.raises(ImportError) as excinfo:
            _ = cve_2025_32756.FortinetCVE202532756Exploit()
        assert "Pwntools could not be imported" in str(excinfo.value)


# --- _pack_address Tests ---
def testPackAddress_whenAddrIsNotInt_shouldRaiseTypeError(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    with pytest.raises(builtins.TypeError, match="Address must be int"):
        exploit_instance_fixture._pack_address("not_an_int")  # type: ignore


@mock.patch("agent.exploits.cve_2025_32756.pwn", None)
def testPackAddress_whenPwnIsNone_shouldRaiseRuntimeError(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    with pytest.raises(builtins.RuntimeError, match="Pwntools not available"):
        exploit_instance_fixture._pack_address(0x1234)


def testPackAddress_whenPointerSizeIsUnsupported_shouldRaiseValueError(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    exploit_instance_fixture.pointer_size = 16  # Unsupported size
    with pytest.raises(builtins.ValueError, match="Unsupported pointer size"):
        exploit_instance_fixture._pack_address(0x1234)


@mock.patch("agent.exploits.cve_2025_32756.pwn.p64")
def testPackAddress_whenPwntoolsRaisesException_shouldRaiseValueError(
    mock_p64: mock.MagicMock,
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    if PWNTOOLS_AVAILABLE:
        mock_p64.side_effect = pwn.pwnlib.exception.PwnlibException("Mock error")
    else:
        mock_p64.side_effect = Exception("Mock error")

    with pytest.raises(builtins.ValueError, match="Pwntools packing failed"):
        exploit_instance_fixture._pack_address(0x1234)


def testPackAddress_when64Bit_shouldUseP64(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    exploit_instance_fixture.pointer_size = 8
    with mock.patch("agent.exploits.cve_2025_32756.pwn.p64") as mock_p64:
        mock_p64.return_value = b"\x34\x12\x00\x00\x00\x00\x00\x00"
        result = exploit_instance_fixture._pack_address(0x1234)
        mock_p64.assert_called_once_with(0x1234)
        assert result == b"\x34\x12\x00\x00\x00\x00\x00\x00"


def testPackAddress_when32Bit_shouldUseP32(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    exploit_instance_fixture.pointer_size = 4
    with mock.patch("agent.exploits.cve_2025_32756.pwn.p32") as mock_p32:
        mock_p32.return_value = b"\x34\x12\x00\x00"
        result = exploit_instance_fixture._pack_address(0x1234)
        mock_p32.assert_called_once_with(0x1234)
        assert result == b"\x34\x12\x00\x00"


# --- _generate_safe_random_padding Tests ---
def testGenerateSafePadding_whenNIsZero_shouldReturnEmptyBytes(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    assert exploit_instance_fixture._generate_safe_random_padding(0) == b""


def testGenerateSafePadding_whenNIsNegative_shouldReturnFillBytes(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    assert (
        exploit_instance_fixture._generate_safe_random_padding(-5)
        == b"\xff\xff\xff\xff\xff"
    )


def testGenerateSafePadding_whenNoBadChars_shouldReturnTokenBytes(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
    monkeypatch: MonkeyPatch,
) -> None:
    monkeypatch.setattr(exploit_instance_fixture, "bad_chars_set", set())
    expected_bytes = b"\x01\x02\x03\x04\x05"
    with mock.patch(
        "agent.exploits.cve_2025_32756.secrets.token_bytes"
    ) as mock_token_bytes:
        mock_token_bytes.return_value = expected_bytes
        assert (
            exploit_instance_fixture._generate_safe_random_padding(5) == expected_bytes
        )
        mock_token_bytes.assert_called_once_with(5)


def testGenerateSafePadding_whenAllBytesAreBad_shouldRaiseValueError(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    exploit_instance_fixture.bad_chars_set = set(range(256))
    with pytest.raises(builtins.ValueError, match="All bytes forbidden for padding"):
        exploit_instance_fixture._generate_safe_random_padding(5)


@mock.patch("agent.exploits.cve_2025_32756.secrets.token_bytes")
def testGenerateSafePadding_whenFailsToGenerateEnoughBytes_shouldRaiseValueError(
    mock_token_bytes: mock.MagicMock,
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    exploit_instance_fixture.bad_chars_set = {0xDE, 0xAD, 0xBE, 0xEF}
    mock_token_bytes.side_effect = [b"\xde"] * (5 * 20)
    with pytest.raises(builtins.ValueError, match="Padding gen failed"):
        exploit_instance_fixture._generate_safe_random_padding(5)


@mock.patch("agent.exploits.cve_2025_32756.secrets.token_bytes")
def testGenerateSafePadding_whenSomeBadChars_shouldFilterCorrectly(
    mock_token_bytes: mock.MagicMock,
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    exploit_instance_fixture.bad_chars_set = {0x00}
    # Return mix of good and bad bytes
    mock_token_bytes.side_effect = [bytes([b]) for b in [0x00, 0x01, 0x00, 0x02, 0x03]]
    result = exploit_instance_fixture._generate_safe_random_padding(3)
    assert result == b"\x01\x02\x03"


# --- _update_dependent_addresses Tests ---
def testUpdateDependentAddresses_whenModuleBaseMissingForGadgets_shouldLogWarning(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
    monkeypatch: MonkeyPatch,
    caplog: LogCaptureFixture,
) -> None:
    monkeypatch.setattr(
        cve_2025_32756,
        "ROP_MODULE_GADGET_OFFSETS",
        {"unknown_module": {"gadget1": 0x100}},
    )
    with caplog.at_level(logging.WARNING):
        exploit_instance_fixture._update_dependent_addresses()
    assert "Base for module 'unknown_module' not found for gadgets." in caplog.text


def testUpdateDependentAddresses_whenModuleBaseMissingForSymbols_shouldLogWarning(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
    monkeypatch: MonkeyPatch,
    caplog: LogCaptureFixture,
) -> None:
    monkeypatch.setattr(
        cve_2025_32756, "ADDR_MODULE_OFFSETS", {"unknown_module": {"symbol1": 0x200}}
    )
    with caplog.at_level(logging.WARNING):
        exploit_instance_fixture._update_dependent_addresses()
    assert "Base for module 'unknown_module' not found for symbols." in caplog.text


def testUpdateDependentAddresses_whenAllConditionsMet_shouldPopulateGadgetsAndAddresses(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
    monkeypatch: MonkeyPatch,
) -> None:
    monkeypatch.setattr(
        cve_2025_32756,
        "ROP_MODULE_GADGET_OFFSETS",
        {"libc": {"test_gadget": 0x100}},
    )
    monkeypatch.setattr(
        cve_2025_32756, "ADDR_MODULE_OFFSETS", {"libc": {"test_symbol": 0x200}}
    )

    exploit_instance_fixture._update_dependent_addresses()

    # Check that flat gadgets are copied
    assert "pop_rdi_ret" in exploit_instance_fixture.all_gadgets
    # Check that module gadgets are calculated
    assert "libc_test_gadget" in exploit_instance_fixture.all_gadgets
    # Check that addresses are calculated
    assert "libc_test_symbol" in exploit_instance_fixture.all_addresses


# --- _build_exploit_code Tests ---
def testBuildExploitCode_whenPopRdiMissing_shouldReturnNone(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
    caplog: LogCaptureFixture,
) -> None:
    exploit_instance_fixture.all_gadgets = {}  # No gadgets
    exploit_instance_fixture.all_addresses = {"libc_system": 0x1234}

    with caplog.at_level(logging.ERROR):
        result = exploit_instance_fixture._build_exploit_code()

    assert result is None
    assert "ROP build: Missing pop_rdi_ret" in caplog.text


def testBuildExploitCode_whenSystemMissing_shouldReturnNone(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
    caplog: LogCaptureFixture,
) -> None:
    exploit_instance_fixture.all_gadgets = {"pop_rdi_ret": 0x1234}
    exploit_instance_fixture.all_addresses = {}  # No system address

    with caplog.at_level(logging.ERROR):
        result = exploit_instance_fixture._build_exploit_code()

    assert result is None
    assert "ROP build: Missing system address" in caplog.text


def testBuildExploitCode_whenPackAddressFails_shouldReturnNone(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
    caplog: LogCaptureFixture,
) -> None:
    exploit_instance_fixture.all_gadgets = {"pop_rdi_ret": 0x1234}
    exploit_instance_fixture.all_addresses = {"libc_system": 0x5678}

    with mock.patch.object(
        exploit_instance_fixture, "_pack_address", side_effect=ValueError("Pack error")
    ):
        with caplog.at_level(logging.ERROR):
            result = exploit_instance_fixture._build_exploit_code()

    assert result is None
    assert "ROP build error" in caplog.text


def testBuildExploitCode_whenSuccessful_shouldReturnROPChain(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    exploit_instance_fixture.all_gadgets = {"pop_rdi_ret": 0x401A23}
    exploit_instance_fixture.all_addresses = {"libc_system": 0x7FFFF7C50D60}

    result = exploit_instance_fixture._build_exploit_code()

    assert result is not None
    assert len(result) > 0
    # Should contain the command string at the end
    assert ROP_COMMAND_VERIFICATION.encode("utf-8") in result
    # Should set the placeholder offset
    assert exploit_instance_fixture.rop_cmd_addr_placeholder_offset != -1


# --- _craft_exploit_payload Tests ---
def testCraftExploitPayload_whenUnpatchedCodeIsNone_shouldReturnNone(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
    caplog: LogCaptureFixture,
) -> None:
    with caplog.at_level(logging.ERROR):
        result = exploit_instance_fixture._craft_exploit_payload(None)

    assert result is None
    assert "Unpatched code is None" in caplog.text


def testCraftExploitPayload_whenNegativePadding_shouldReturnNone(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
    monkeypatch: MonkeyPatch,
    caplog: LogCaptureFixture,
) -> None:
    # Create conditions for negative padding
    monkeypatch.setattr(cve_2025_32756, "STACK_RETURN_ADDRESS_OVERWRITE_OFFSET", 10)
    monkeypatch.setattr(cve_2025_32756, "STACK_BUFFER_OFFSET", 64)
    monkeypatch.setattr(cve_2025_32756, "STACK_BUFFER_SIZE", 256)

    with caplog.at_level(logging.ERROR):
        result = exploit_instance_fixture._craft_exploit_payload(b"test")

    assert result is None
    assert "Negative padding_before_overwrite" in caplog.text


def testCraftExploitPayload_whenBadCharsInPayload_shouldRaiseValueError(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
    caplog: LogCaptureFixture,
) -> None:
    # Mock _pack_address to return bad chars
    with mock.patch.object(
        exploit_instance_fixture, "_pack_address", return_value=b"\x00\x01\x02\x03"
    ):
        with caplog.at_level(logging.ERROR):
            result = exploit_instance_fixture._craft_exploit_payload(b"test")

    assert result is None
    assert "Payload crafting error" in caplog.text


def testCraftExploitPayload_whenSuccessful_shouldReturnPayload(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    exploit_instance_fixture.rop_cmd_addr_placeholder_offset = 8

    # Mock _pack_address to return clean bytes
    with mock.patch.object(
        exploit_instance_fixture,
        "_pack_address",
        return_value=b"\x60\x47\x46\x45\x44\x43\x42\x41",
    ):
        result = exploit_instance_fixture._craft_exploit_payload(b"test_rop_code")

    assert result is not None
    assert len(result) > 0


# --- _trigger_vulnerability Tests ---
def testTriggerVulnerability_whenPayloadIsNone_shouldReturnFalse(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
    caplog: LogCaptureFixture,
) -> None:
    with caplog.at_level(logging.ERROR):
        result = exploit_instance_fixture._trigger_vulnerability(None, "127.0.0.1", 80)

    assert result is False
    assert "Payload is None" in caplog.text


def testTriggerVulnerability_whenUnsupportedLocation_shouldReturnFalse(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
    monkeypatch: MonkeyPatch,
    caplog: LogCaptureFixture,
) -> None:
    monkeypatch.setattr(cve_2025_32756, "TRIGGER_PAYLOAD_LOCATION", "unsupported")

    with caplog.at_level(logging.ERROR):
        result = exploit_instance_fixture._trigger_vulnerability(
            b"test", "127.0.0.1", 80
        )

    assert result is False
    assert "Unsupported trigger location" in caplog.text


def testTriggerVulnerability_whenRequestSucceeds_shouldReturnTrue(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
    requests_mock: req_mock.mocker.Mocker,
) -> None:
    requests_mock.get("http://127.0.0.1:80", status_code=200)

    result = exploit_instance_fixture._trigger_vulnerability(b"test", "127.0.0.1", 80)

    assert result is True


def testTriggerVulnerability_whenRequestTimesOut_shouldReturnTrue(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
    requests_mock: req_mock.mocker.Mocker,
) -> None:
    requests_mock.get("http://127.0.0.1:80", exc=requests.exceptions.Timeout)

    result = exploit_instance_fixture._trigger_vulnerability(b"test", "127.0.0.1", 80)

    assert result is True  # Timeout is expected in exploit scenarios


def testTriggerVulnerability_whenRequestFails_shouldReturnFalse(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
    requests_mock: req_mock.mocker.Mocker,
    caplog: LogCaptureFixture,
) -> None:
    requests_mock.get("http://127.0.0.1:80", exc=requests.exceptions.ConnectionError)

    with caplog.at_level(logging.ERROR):
        result = exploit_instance_fixture._trigger_vulnerability(
            b"test", "127.0.0.1", 80
        )

    assert result is False
    assert "Trigger failed" in caplog.text


def testTriggerVulnerability_whenHttpsPort_shouldUseHttpsScheme(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
    requests_mock: req_mock.mocker.Mocker,
) -> None:
    requests_mock.get("https://127.0.0.1:443", status_code=200)

    result = exploit_instance_fixture._trigger_vulnerability(b"test", "127.0.0.1", 443)

    assert result is True


# --- _verify_exploit_success Tests ---
def testVerifyExploitSuccess_whenVerificationSucceeds_shouldReturnTrue(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
    requests_mock: req_mock.mocker.Mocker,
) -> None:
    url = f"http://127.0.0.1:80{VERIFICATION_HTTP_FILE_PATH}"
    requests_mock.get(url, text=VERIFICATION_HTTP_EXPECTED_CONTENT, status_code=200)

    with mock.patch("time.sleep"):  # Speed up test
        result = exploit_instance_fixture._verify_exploit_success("127.0.0.1", 80)

    assert result is True
