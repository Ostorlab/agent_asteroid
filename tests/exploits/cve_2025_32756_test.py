"""Unit tests for CVE-2025-32756 exploit agent."""

import logging
from unittest import mock  # For patching pwn if needed, or constants

import pytest
import requests
import requests_mock as req_mock

from agent import definitions
from agent.exploits import cve_2025_32756  # Assuming your file is named this

# Import constants from the exploit module to use in tests
from agent.exploits.cve_2025_32756 import (
    TARGET_VULNERABLE_PATH,
    VERIFICATION_HTTP_FILE_PATH,
    VERIFICATION_HTTP_EXPECTED_CONTENT,
    # Current workaround base
    # ORIGINAL_ADDR_FIXED_INPUT_BUFFER_BASE = 0x7FFFFFFDE000 # If we want to test original
)

# Try to import pwn for type hinting and mocking, but handle if not installed for basic structure
try:
    import pwn

    PWNTOOLS_AVAILABLE = True
except ImportError:
    PWNTOOLS_AVAILABLE = False
    pwn = None  # Placeholder


@pytest.fixture
def exploit_instance_fixture() -> cve_2025_32756.FortinetCVE202532756Exploit:
    """Fixture to create an instance of the exploit."""
    if not PWNTOOLS_AVAILABLE:
        pytest.skip("Pwntools not installed, skipping tests that require it.")
    return cve_2025_32756.FortinetCVE202532756Exploit()


# --- Accept Method Tests ---


def testAccept_whenTargetIsFortinet_returnsTrue(
    requests_mock: req_mock.mocker.Mocker,
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    """Test accept() when the target appears to be a vulnerable Fortinet device."""
    target = definitions.Target(scheme="http", host="127.0.0.1", port=80)
    base_url = f"http://{target.host}:{target.port}"
    requests_mock.head(
        f"{base_url}{TARGET_VULNERABLE_PATH}",
        headers={"Server": "FortiSomething-HTTP"},
        status_code=200,
    )
    assert exploit_instance_fixture.accept(target) is True


def testAccept_whenTargetIsGenericButPathExists_returnsTrue(
    requests_mock: req_mock.mocker.Mocker,
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    """Test accept() when target is generic but vulnerable path is accessible."""
    target = definitions.Target(scheme="http", host="127.0.0.1", port=80)
    base_url = f"http://{target.host}:{target.port}"
    requests_mock.head(
        f"{base_url}{TARGET_VULNERABLE_PATH}",
        status_code=200,  # Or 404 as in your logs, but still < 500
    )
    assert exploit_instance_fixture.accept(target) is True


def testAccept_whenTargetIsNotFortinetAndPathMissing_returnsFalse(
    requests_mock: req_mock.mocker.Mocker,
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    """Test accept() when the target is not identifiable and path gives 500."""
    target = definitions.Target(scheme="http", host="127.0.0.1", port=80)
    base_url = f"http://{target.host}:{target.port}"
    requests_mock.head(f"{base_url}{TARGET_VULNERABLE_PATH}", status_code=500)
    assert exploit_instance_fixture.accept(target) is False


def testAccept_whenNetworkError_returnsFalse(
    requests_mock: req_mock.mocker.Mocker,
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    """Test accept() when a network error occurs."""
    target = definitions.Target(scheme="http", host="127.0.0.1", port=80)
    base_url = f"http://{target.host}:{target.port}"
    requests_mock.head(
        f"{base_url}{TARGET_VULNERABLE_PATH}", exc=requests.exceptions.ConnectionError
    )
    assert exploit_instance_fixture.accept(target) is False


# --- Check Method Tests ---


# Helper to mock Pwntools packing for consistency in tests
# This mock should produce "clean" bytes for the addresses used.
# It needs to handle all addresses that _pack_address will be called with.
def mock_pwn_packers(addr: int) -> bytes:
    """Simplified mock for pwn.p64/p32 for testing."""
    # This should ideally mirror what a *correct* Pwntools would do.
    # For 0x4142434445464748 (our workaround RET) -> 4847464544434241
    # For 0x401A23 (pop_rdi_ret) -> 231a400000000000
    # For 0x7ffff7c50d60 (system) -> 600dc5f7ff7f0000 (as per your logs for this value, seems <2^48 treated fine)
    # For 0x4142434445464760 (live_cmd_str_ad with workaround base) -> 6047464544434241

    # For 64-bit addresses (amd64)
    if addr == 0x4142434445464748:  # exploit_code_live_ad with workaround
        return b"\x48\x47\x46\x45\x44\x43\x42\x41"
    elif addr == 0x401A23:  # pop_rdi_ret
        return b"\x23\x1a\x40\x00\x00\x00\x00\x00"
    elif addr == 0x7FFFF7C50D60:  # system address (from logs, seems < 2^48 is fine)
        return b"\x60\x0d\xc5\xf7\xff\x7f\x00\x00"
    elif addr == 0x4142434445464760:  # live_cmd_str_ad with workaround base
        return b"\x60\x47\x46\x45\x44\x43\x42\x41"
    # Add other addresses if _pack_address is called with them during tests
    # Fallback for unexpected addresses during test
    logging.warning(
        f"MockPwnPack: Unexpected address {hex(addr)}, using default struct pack."
    )
    import struct

    return struct.pack("<Q", addr)


@mock.patch(
    "agent.exploits.cve_2025_32756.pwn", autospec=True
)  # Mock the entire pwn module
def testCheck_whenTargetIsVulnerable_reportsVulnerability(
    mock_pwn_module: mock.MagicMock,
    requests_mock: req_mock.mocker.Mocker,
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    """Test check() when target is vulnerable and all steps succeed."""
    target = definitions.Target(scheme="http", host="127.0.0.1", port=80)
    base_url = f"http://{target.host}:{target.port}"

    mock_pwn_module.context = pwn.context
    mock_pwn_module.context.arch = cve_2025_32756.TARGET_ARCHITECTURE
    mock_pwn_module.context.endian = cve_2025_32756.TARGET_ENDIANNESS
    mock_pwn_module.context.bits = 64  # for amd64

    mock_pwn_module.p64.side_effect = mock_pwn_packers

    requests_mock.get(f"{base_url}{TARGET_VULNERABLE_PATH}", status_code=200)  # Trigger
    requests_mock.get(
        f"{base_url}{VERIFICATION_HTTP_FILE_PATH}",
        text=VERIFICATION_HTTP_EXPECTED_CONTENT,
    )

    vulnerabilities = exploit_instance_fixture.check(target)

    assert len(vulnerabilities) == 1
    vulnerability = vulnerabilities[0]
    assert vulnerability.entry.title == cve_2025_32756.VULNERABILITY_TITLE
    assert vulnerability.risk_rating.name == "CRITICAL"


@mock.patch("agent.exploits.cve_2025_32756.pwn", autospec=True)
def testCheck_whenVerificationFails_reportsNothing(
    mock_pwn_module: mock.MagicMock,
    requests_mock: req_mock.mocker.Mocker,
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    """Test check() when verification step fails."""
    target = definitions.Target(scheme="http", host="127.0.0.1", port=80)
    base_url = f"http://{target.host}:{target.port}"

    mock_pwn_module.context = pwn.context
    mock_pwn_module.context.arch = cve_2025_32756.TARGET_ARCHITECTURE
    mock_pwn_module.context.endian = cve_2025_32756.TARGET_ENDIANNESS
    mock_pwn_module.context.bits = 64
    mock_pwn_module.p64.side_effect = mock_pwn_packers

    requests_mock.get(f"{base_url}{TARGET_VULNERABLE_PATH}", status_code=200)  # Trigger
    requests_mock.get(f"{base_url}{VERIFICATION_HTTP_FILE_PATH}", status_code=404)

    vulnerabilities = exploit_instance_fixture.check(target)
    assert len(vulnerabilities) == 0


@mock.patch("agent.exploits.cve_2025_32756.pwn", autospec=True)
def testCheck_whenTriggerRequestFails_reportsNothing(
    mock_pwn_module: mock.MagicMock,
    requests_mock: req_mock.mocker.Mocker,
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    """Test check() when the trigger request itself fails."""
    target = definitions.Target(scheme="http", host="127.0.0.1", port=80)
    base_url = f"http://{target.host}:{target.port}"

    mock_pwn_module.context = pwn.context
    mock_pwn_module.context.arch = cve_2025_32756.TARGET_ARCHITECTURE
    mock_pwn_module.context.endian = cve_2025_32756.TARGET_ENDIANNESS
    mock_pwn_module.context.bits = 64
    mock_pwn_module.p64.side_effect = mock_pwn_packers

    requests_mock.get(
        f"{base_url}{cve_2025_32756.TARGET_VULNERABLE_PATH}",
        exc=requests.exceptions.ConnectionError,
    )

    requests_mock.get(
        f"{base_url}{cve_2025_32756.VERIFICATION_HTTP_FILE_PATH}", status_code=404
    )

    vulnerabilities = exploit_instance_fixture.check(target)
    assert len(vulnerabilities) == 0


@mock.patch("agent.exploits.cve_2025_32756.pwn", autospec=True)
def testCheck_whenPayloadCraftingFailsDueToBadChars_reportsNothing(
    mock_pwn_module: mock.MagicMock,
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    """Test check() if payload crafting fails due to bad characters.
    This test simulates Pwntools producing a 'bad' byte for a specific address.
    """
    target = definitions.Target(scheme="http", host="127.0.0.1", port=80)

    mock_pwn_module.context = pwn.context
    mock_pwn_module.context.arch = cve_2025_32756.TARGET_ARCHITECTURE
    mock_pwn_module.context.endian = cve_2025_32756.TARGET_ENDIANNESS
    mock_pwn_module.context.bits = 64

    def mock_pwn_packers_with_bad_char(addr: int) -> bytes:
        if addr == 0x4142434445464748:
            return b"\x48\x47\x46\x45\x44\x43\x42\x00"
        return mock_pwn_packers(addr)

    mock_pwn_module.p64.side_effect = mock_pwn_packers_with_bad_char

    vulnerabilities = exploit_instance_fixture.check(target)
    assert len(vulnerabilities) == 0


def testCheck_whenPwntoolsNotImported_raisesImportErrorOnInit(
    caplog: pytest.LogCaptureFixture,
) -> None:
    """Test that if Pwntools is not imported, __init__ raises ImportError."""

    with mock.patch("agent.exploits.cve_2025_32756.pwn", None):
        with pytest.raises(ImportError) as excinfo:
            _ = cve_2025_32756.FortinetCVE202532756Exploit()

        assert "Pwntools could not be imported" in str(excinfo.value)
