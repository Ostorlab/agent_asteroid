"""Unit tests for CVE-2025-32756 exploit agent."""

import logging
import typing
from unittest import mock
import builtins

import pytest
import requests
import requests_mock as req_mock
from _pytest.logging import LogCaptureFixture
from _pytest.monkeypatch import MonkeyPatch

from agent import definitions
from agent.exploits import cve_2025_32756

from agent.exploits.cve_2025_32756 import (
    VULNERABILITY_TITLE,
    TARGET_VULNERABLE_PATH,
    VERIFICATION_HTTP_FILE_PATH,
    VERIFICATION_HTTP_EXPECTED_CONTENT,
    TARGET_ARCHITECTURE as DEFAULT_TARGET_ARCHITECTURE,
    TARGET_ENDIANNESS as DEFAULT_TARGET_ENDIANNESS,
    ROP_FLAT_GADGETS as DEFAULT_ROP_FLAT_GADGETS,
)

try:
    import pwn
    import pwnlib.exception  # type: ignore[import-untyped]

    PWNTOOLS_AVAILABLE = True
except ImportError:
    PWNTOOLS_AVAILABLE = False
    pwn = None
    pwnlib = None


@pytest.fixture
def exploit_instance_fixture(
    monkeypatch: MonkeyPatch,
) -> cve_2025_32756.FortinetCVE202532756Exploit:
    """Fixture to create an instance of the exploit with default constants."""
    if PWNTOOLS_AVAILABLE is False:
        pytest.skip("Pwntools not installed, skipping tests that require it.")

    monkeypatch.setattr(
        cve_2025_32756, "TARGET_ARCHITECTURE", DEFAULT_TARGET_ARCHITECTURE
    )
    monkeypatch.setattr(cve_2025_32756, "TARGET_ENDIANNESS", DEFAULT_TARGET_ENDIANNESS)
    monkeypatch.setattr(cve_2025_32756, "pwn", pwn)

    return cve_2025_32756.FortinetCVE202532756Exploit()


# --- Mock Pwntools Packers ---
def mock_pwn_packers_default(
    addr: int, bits: int = 64, endian: str = "little"
) -> bytes:
    """Default mock for pwn.p64/p32, produces 'clean' bytes for known addresses."""
    byte_order_literal: typing.Literal["little", "big"]
    if endian == "little":
        byte_order_literal = "little"
    elif endian == "big":
        byte_order_literal = "big"
    else:
        raise ValueError(f"Invalid endian value for mock: {endian}")

    if bits == 64:
        if addr == 0x4142434445464748:
            return b"\x48\x47\x46\x45\x44\x43\x42\x41"
        if addr == 0x401A23:
            return b"\x23\x1a\x40\x00\x00\x00\x00\x00"
        if addr == 0x7FFFFFFDE150:
            return b"\x50\xe1\xdf\xff\xff\xff\xff\x07"
        if addr == 0x7FFFF7C50D60:
            return b"\x60\x0d\xc5\xf7\xff\x7f\x00\x00"
        if addr == 0x4142434445464760:
            return b"\x60\x47\x46\x45\x44\x43\x42\x41"
        logging.warning(
            "MockPwnPackersDefault: Unhandled 64-bit address %s, using to_bytes.",
            hex(addr),
        )
        return addr.to_bytes(8, byteorder=byte_order_literal, signed=False)
    elif bits == 32:
        if addr == 0x44332211:
            return b"\x11\x22\x33\x44"
        logging.warning(
            "MockPwnPackersDefault: Unhandled 32-bit address %s, using to_bytes.",
            hex(addr),
        )
        return addr.to_bytes(4, byteorder=byte_order_literal, signed=False)
    raise ValueError(f"Unsupported bits {bits} in mock_pwn_packers_default")


# --- __init__ Tests ---
def testInit_whenArchIsI386_shouldSetPointerSize4(monkeypatch: MonkeyPatch) -> None:
    if PWNTOOLS_AVAILABLE is False:
        pytest.skip("Pwntools not available")
    monkeypatch.setattr(cve_2025_32756, "TARGET_ARCHITECTURE", "i386")
    original_arch = pwn.context.arch
    try:
        instance = cve_2025_32756.FortinetCVE202532756Exploit()
        assert instance.pointer_size == 4
        assert pwn.context.arch == "i386"
    finally:
        pwn.context.arch = original_arch


def testInit_whenArchIsArm_shouldSetPointerSize4(monkeypatch: MonkeyPatch) -> None:
    if PWNTOOLS_AVAILABLE is False:
        pytest.skip("Pwntools not available")
    monkeypatch.setattr(cve_2025_32756, "TARGET_ARCHITECTURE", "arm")
    original_arch = pwn.context.arch
    try:
        instance = cve_2025_32756.FortinetCVE202532756Exploit()
        assert instance.pointer_size == 4
        assert pwn.context.arch == "arm"
    finally:
        pwn.context.arch = original_arch


@mock.patch("agent.exploits.cve_2025_32756.pwn.context", autospec=True)
def testInit_whenArchIsUnknownAndBits32_shouldSetPointerSize4(
    mock_pwn_ctx: mock.MagicMock, monkeypatch: MonkeyPatch
) -> None:
    if PWNTOOLS_AVAILABLE is False:
        pytest.skip("Pwntools not available")
    monkeypatch.setattr(cve_2025_32756, "TARGET_ARCHITECTURE", "mips")

    mock_pwn_ctx.bits = 32

    instance = cve_2025_32756.FortinetCVE202532756Exploit()
    assert instance.pointer_size == 4
    assert mock_pwn_ctx.arch == "mips"


@mock.patch("agent.exploits.cve_2025_32756.pwn.context", autospec=True)
def testInit_whenArchIsUnknownAndBits64_shouldSetPointerSize8(
    mock_pwn_ctx: mock.MagicMock, monkeypatch: MonkeyPatch
) -> None:
    if PWNTOOLS_AVAILABLE is False:
        pytest.skip("Pwntools not available")
    monkeypatch.setattr(cve_2025_32756, "TARGET_ARCHITECTURE", "mips64")
    mock_pwn_ctx.bits = 64
    instance = cve_2025_32756.FortinetCVE202532756Exploit()
    assert instance.pointer_size == 8
    assert mock_pwn_ctx.arch == "mips64"


@mock.patch("agent.exploits.cve_2025_32756.pwn.context", autospec=True)
def testInit_whenArchAndBitsAreUndeterminable_shouldRaiseValueError(
    mock_pwn_ctx: mock.MagicMock, monkeypatch: MonkeyPatch
) -> None:
    if PWNTOOLS_AVAILABLE is False:
        pytest.skip("Pwntools not available")
    monkeypatch.setattr(cve_2025_32756, "TARGET_ARCHITECTURE", "mips")
    mock_pwn_ctx.bits = 16
    with pytest.raises(builtins.ValueError, match="Could not determine pointer size"):
        cve_2025_32756.FortinetCVE202532756Exploit()


# --- _generate_safe_random_padding Tests ---


def testGenerateSafePadding_whenNIsZero_shouldReturnEmptyBytes(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    assert exploit_instance_fixture._generate_safe_random_padding(0) == b""


def testGenerateSafePadding_whenNIsNegative_shouldReturnFillBytes(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    assert (
        exploit_instance_fixture._generate_safe_random_padding(-5)
        == b"\xff\xff\xff\xff\xff"
    )


def testGenerateSafePadding_whenNoBadChars_shouldReturnTokenBytes(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
    monkeypatch: MonkeyPatch,
) -> None:
    monkeypatch.setattr(exploit_instance_fixture, "bad_chars_set", set())
    expected_bytes = b"\x01\x02\x03\x04\x05"
    with mock.patch(
        "agent.exploits.cve_2025_32756.secrets.token_bytes"
    ) as mock_token_bytes:
        mock_token_bytes.return_value = expected_bytes
        assert (
            exploit_instance_fixture._generate_safe_random_padding(5) == expected_bytes
        )
        mock_token_bytes.assert_called_once_with(5)


def testGenerateSafePadding_whenAllBytesAreBad_shouldRaiseValueError(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
    monkeypatch: MonkeyPatch,
) -> None:
    monkeypatch.setattr(exploit_instance_fixture, "bad_chars_set", set(range(256)))
    with pytest.raises(builtins.ValueError, match="All bytes forbidden for padding"):
        exploit_instance_fixture._generate_safe_random_padding(5)


@mock.patch("agent.exploits.cve_2025_32756.secrets.token_bytes")
def testGenerateSafePadding_whenFailsToGenerateEnoughBytes_shouldRaiseValueError(
    mock_token_bytes: mock.MagicMock,
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
    monkeypatch: MonkeyPatch,
) -> None:
    monkeypatch.setattr(
        exploit_instance_fixture, "bad_chars_set", {0xDE, 0xAD, 0xBE, 0xEF}
    )
    mock_token_bytes.side_effect = [b"\xde"] * (5 * 20)
    with pytest.raises(builtins.ValueError, match="Padding gen failed"):
        exploit_instance_fixture._generate_safe_random_padding(5)


# --- _update_dependent_addresses Tests ---
def testUpdateDependentAddresses_whenModuleBaseIsMissingForGadgets_shouldLogWarning(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
    monkeypatch: MonkeyPatch,
    caplog: LogCaptureFixture,
) -> None:
    monkeypatch.setattr(
        cve_2025_32756,
        "ROP_MODULE_GADGET_OFFSETS",
        {"unknown_module": {"gadget1": 0x100}},
    )
    monkeypatch.setattr(cve_2025_32756, "ADDR_MODULE_OFFSETS", {})
    instance = (
        cve_2025_32756.FortinetCVE202532756Exploit()
    )  # Create new instance after patching constants
    with caplog.at_level(logging.WARNING):
        instance._update_dependent_addresses()
    assert "Base for module 'unknown_module' not found for gadgets." in caplog.text


def testUpdateDependentAddresses_whenModuleBaseIsMissingForSymbols_shouldLogWarning(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
    monkeypatch: MonkeyPatch,
    caplog: LogCaptureFixture,
) -> None:
    monkeypatch.setattr(cve_2025_32756, "ROP_MODULE_GADGET_OFFSETS", {})
    monkeypatch.setattr(
        cve_2025_32756, "ADDR_MODULE_OFFSETS", {"unknown_module": {"symbol1": 0x200}}
    )
    instance = cve_2025_32756.FortinetCVE202532756Exploit()  # New instance
    with caplog.at_level(logging.WARNING):
        instance._update_dependent_addresses()
    assert "Base for module 'unknown_module' not found for symbols." in caplog.text


# --- _build_exploit_code Tests ---
def testBuildExploitCode_whenPopRdiIsMissing_shouldReturnNone(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
    monkeypatch: MonkeyPatch,
    caplog: LogCaptureFixture,
) -> None:
    monkeypatch.setattr(cve_2025_32756, "ROP_FLAT_GADGETS", {})
    instance = cve_2025_32756.FortinetCVE202532756Exploit()  # New instance
    instance._update_dependent_addresses()
    with caplog.at_level(logging.ERROR):
        assert instance._build_exploit_code() is None
    assert "ROP build: Missing pop_rdi_ret" in caplog.text


def testBuildExploitCode_whenSystemIsMissing_shouldReturnNone(
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
    monkeypatch: MonkeyPatch,
    caplog: LogCaptureFixture,
) -> None:
    monkeypatch.setattr(cve_2025_32756, "ROP_FLAT_GADGETS", DEFAULT_ROP_FLAT_GADGETS)
    monkeypatch.setattr(
        cve_2025_32756, "ADDR_MODULE_OFFSETS", {"libc": {"not_system": 0x456}}
    )
    instance = cve_2025_32756.FortinetCVE202532756Exploit()  # New instance
    instance._update_dependent_addresses()
    with caplog.at_level(logging.ERROR):
        assert instance._build_exploit_code() is None
    assert "ROP build: Missing system address" in caplog.text


# --- Main Check and Accept Method Tests ---
def testAccept_whenTargetIsFortinet_shouldReturnTrue(
    requests_mock: req_mock.mocker.Mocker,
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    target = definitions.Target(scheme="http", host="127.0.0.1", port=80)
    base_url = f"http://{target.host}:{target.port}"
    requests_mock.head(
        f"{base_url}{TARGET_VULNERABLE_PATH}",
        headers={"Server": "FortiSomething-HTTP"},
        status_code=200,
    )
    assert exploit_instance_fixture.accept(target) is True


@mock.patch("agent.exploits.cve_2025_32756.pwn", autospec=True)
def testCheck_whenTargetIsVulnerable_shouldReportVulnerability(
    mock_pwn_module: mock.MagicMock,
    requests_mock: req_mock.mocker.Mocker,
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    target = definitions.Target(scheme="http", host="127.0.0.1", port=80)
    base_url = f"http://{target.host}:{target.port}"

    mock_pwn_module.context.arch = DEFAULT_TARGET_ARCHITECTURE
    mock_pwn_module.context.endian = DEFAULT_TARGET_ENDIANNESS
    mock_pwn_module.context.bits = 64 if DEFAULT_TARGET_ARCHITECTURE == "amd64" else 32

    if mock_pwn_module.context.bits == 64:
        mock_pwn_module.p64.side_effect = lambda addr: mock_pwn_packers_default(
            addr, bits=64, endian=str(mock_pwn_module.context.endian)
        )
    else:
        mock_pwn_module.p32.side_effect = lambda addr: mock_pwn_packers_default(
            addr, bits=32, endian=str(mock_pwn_module.context.endian)
        )

    requests_mock.head(
        f"{base_url}{TARGET_VULNERABLE_PATH}",
        headers={"Server": "Fortinet"},
        status_code=200,
    )
    requests_mock.get(f"{base_url}{TARGET_VULNERABLE_PATH}", status_code=200)
    requests_mock.get(
        f"{base_url}{VERIFICATION_HTTP_FILE_PATH}",
        text=VERIFICATION_HTTP_EXPECTED_CONTENT,
    )

    vulnerabilities = exploit_instance_fixture.check(target)
    assert len(vulnerabilities) == 1
    vulnerability = vulnerabilities[0]
    assert vulnerability.entry.title == VULNERABILITY_TITLE
    assert vulnerability.risk_rating.name == "CRITICAL"


def testInit_whenPwntoolsNotImported_shouldRaiseImportError() -> None:
    if (
        PWNTOOLS_AVAILABLE is True
    ):  # If Pwntools *is* available, we forcibly mock it away for the test.
        with mock.patch("agent.exploits.cve_2025_32756.pwn", None):
            with pytest.raises(ImportError) as excinfo:
                _ = cve_2025_32756.FortinetCVE202532756Exploit()
            assert "Pwntools could not be imported" in str(excinfo.value)
    else:  # If Pwntools is *already* unavailable, the ImportError should happen.
        with pytest.raises(ImportError) as excinfo:
            _ = cve_2025_32756.FortinetCVE202532756Exploit()
        assert "Pwntools could not be imported" in str(excinfo.value)


@mock.patch("agent.exploits.cve_2025_32756.pwn", autospec=True)
def testCheck_whenVerificationFails_shouldReportNothing(
    mock_pwn_module: mock.MagicMock,
    requests_mock: req_mock.mocker.Mocker,
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    target = definitions.Target(scheme="http", host="127.0.0.1", port=80)
    base_url = f"http://{target.host}:{target.port}"

    mock_pwn_module.context.arch = DEFAULT_TARGET_ARCHITECTURE
    mock_pwn_module.context.endian = DEFAULT_TARGET_ENDIANNESS
    mock_pwn_module.context.bits = 64 if DEFAULT_TARGET_ARCHITECTURE == "amd64" else 32
    if mock_pwn_module.context.bits == 64:
        mock_pwn_module.p64.side_effect = lambda addr: mock_pwn_packers_default(
            addr, bits=64, endian=str(mock_pwn_module.context.endian)
        )
    else:
        mock_pwn_module.p32.side_effect = lambda addr: mock_pwn_packers_default(
            addr, bits=32, endian=str(mock_pwn_module.context.endian)
        )

    requests_mock.head(
        f"{base_url}{TARGET_VULNERABLE_PATH}",
        headers={"Server": "Fortinet"},
        status_code=200,
    )
    requests_mock.get(f"{base_url}{TARGET_VULNERABLE_PATH}", status_code=200)
    requests_mock.get(f"{base_url}{VERIFICATION_HTTP_FILE_PATH}", status_code=404)

    vulnerabilities = exploit_instance_fixture.check(target)
    assert len(vulnerabilities) == 0


@mock.patch("agent.exploits.cve_2025_32756.pwn", autospec=True)
def testCheck_whenTriggerRequestFails_shouldReportNothing(
    mock_pwn_module: mock.MagicMock,
    requests_mock: req_mock.mocker.Mocker,
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    target = definitions.Target(scheme="http", host="127.0.0.1", port=80)
    base_url = f"http://{target.host}:{target.port}"

    mock_pwn_module.context.arch = DEFAULT_TARGET_ARCHITECTURE
    mock_pwn_module.context.endian = DEFAULT_TARGET_ENDIANNESS
    mock_pwn_module.context.bits = 64 if DEFAULT_TARGET_ARCHITECTURE == "amd64" else 32
    if mock_pwn_module.context.bits == 64:
        mock_pwn_module.p64.side_effect = lambda addr: mock_pwn_packers_default(
            addr, bits=64, endian=str(mock_pwn_module.context.endian)
        )
    else:
        mock_pwn_module.p32.side_effect = lambda addr: mock_pwn_packers_default(
            addr, bits=32, endian=str(mock_pwn_module.context.endian)
        )

    requests_mock.head(
        f"{base_url}{TARGET_VULNERABLE_PATH}",
        headers={"Server": "Fortinet"},
        status_code=200,
    )
    requests_mock.get(
        f"{base_url}{TARGET_VULNERABLE_PATH}", exc=requests.exceptions.ConnectionError
    )
    requests_mock.get(f"{base_url}{VERIFICATION_HTTP_FILE_PATH}", status_code=404)

    vulnerabilities = exploit_instance_fixture.check(target)
    assert len(vulnerabilities) == 0


@mock.patch("agent.exploits.cve_2025_32756.pwn", autospec=True)
def testCheck_whenPayloadCraftingFailsDueToBadChars_shouldReportNothing(
    mock_pwn_module: mock.MagicMock,
    exploit_instance_fixture: cve_2025_32756.FortinetCVE202532756Exploit,
    requests_mock: req_mock.mocker.Mocker,  # Added for accept call
) -> None:
    target = definitions.Target(scheme="http", host="127.0.0.1", port=80)
    base_url = f"http://{target.host}:{target.port}"
    requests_mock.head(
        f"{base_url}{TARGET_VULNERABLE_PATH}",
        headers={"Server": "Fortinet"},
        status_code=200,
    )

    mock_pwn_module.context.arch = DEFAULT_TARGET_ARCHITECTURE
    mock_pwn_module.context.endian = DEFAULT_TARGET_ENDIANNESS
    mock_pwn_module.context.bits = 64 if DEFAULT_TARGET_ARCHITECTURE == "amd64" else 32

    def mock_pwn_packers_with_bad_char(addr: int, bits: int, endian: str) -> bytes:
        # Current ADDR_FIXED_INPUT_BUFFER_BASE leads to exploit_code_live_ad = 0x4142434445464748
        if addr == 0x4142434445464748 and bits == 64:
            return b"\x48\x47\x46\x45\x44\x43\x42\x00"  # Bad char
        return mock_pwn_packers_default(addr, bits=bits, endian=endian)

    if mock_pwn_module.context.bits == 64:
        mock_pwn_module.p64.side_effect = lambda addr: mock_pwn_packers_with_bad_char(
            addr, bits=64, endian=str(mock_pwn_module.context.endian)
        )
    else:
        mock_pwn_module.p32.side_effect = lambda addr: mock_pwn_packers_with_bad_char(
            addr, bits=32, endian=str(mock_pwn_module.context.endian)
        )

    vulnerabilities = exploit_instance_fixture.check(target)
    assert len(vulnerabilities) == 0
