"""Unit tests for CVE-2025-32433 exploit"""

import socket
import struct
import time
from typing import Any

import pytest

from agent import definitions
from agent.exploits import cve_2025_32433


class DummySocket:
    def __init__(self, *args: Any, **kwargs: Any) -> None:
        self.sent_data: list[bytes] = []
        self.to_receive: list[bytes | Exception] = []
        self.timeout: float | None = None
        self.connected: bool = False
        self.closed: bool = False
        self.file_no: int = 10  # Valid file descriptor

    def settimeout(self, timeout: float) -> None:
        self.timeout = timeout

    def connect(self, addr: tuple[str, int]) -> None:
        if addr[0] == "bad":
            raise socket.error("Connection refused")
        self.connected = True

    def sendall(self, data: bytes) -> None:
        self.sent_data.append(data)

    def recv(self, bufsize: int) -> bytes:
        if len(self.to_receive) == 0:
            return b""
        resp = self.to_receive.pop(0)
        if isinstance(resp, Exception):
            raise resp
        return resp

    def close(self) -> None:
        self.connected = False
        self.closed = True

    def fileno(self) -> int:
        return -1 if self.closed else self.file_no


@pytest.fixture(autouse=True)
def patch_socket(monkeypatch: pytest.MonkeyPatch) -> DummySocket:
    """Patch socket.socket to always return the same DummySocket instance."""
    dummy = DummySocket()
    monkeypatch.setattr(socket, "socket", lambda *args, **kwargs: dummy)
    return dummy


def testCVE202532433_whenTargetIsErlangSSH_accepts(patch_socket: DummySocket) -> None:
    """accept() should return True when banner contains Erlang signature."""
    target = definitions.Target(scheme="ssh", host="127.0.0.1", port=2222)
    patch_socket.to_receive = [b"SSH-2.0-Erlang-OTP\r\n"]
    exploit = cve_2025_32433.ErlangSSHPreAuthExploit()

    assert exploit.accept(target) is True


def testCVE202532433_whenTargetIsNotErlangSSH_rejects(
    patch_socket: DummySocket,
) -> None:
    """accept() should return False when banner does not match."""
    target = definitions.Target(scheme="ssh", host="127.0.0.1", port=2222)
    patch_socket.to_receive = [b"SSH-2.0-OpenSSH_8.9\r\n"]
    exploit = cve_2025_32433.ErlangSSHPreAuthExploit()

    assert exploit.accept(target) is False


def testCVE202532433_whenConnectErrorInAccept_returnsFalse(
    patch_socket: DummySocket,
) -> None:
    """accept() should return False when connect() raises an error."""
    target = definitions.Target(scheme="ssh", host="bad", port=2222)
    exploit = cve_2025_32433.ErlangSSHPreAuthExploit()

    assert exploit.accept(target) is False


def testCVE202532433_whenResponseWithPwned_reportsVulnerability(
    patch_socket: DummySocket, monkeypatch: pytest.MonkeyPatch
) -> None:
    """check() should report vulnerability when response contains 'pwned'."""
    target = definitions.Target(scheme="ssh", host="127.0.0.1", port=2222)

    # Setup response sequence for the full exploit flow
    patch_socket.to_receive = [
        b"SSH-2.0-Erlang-OTP\r\n",  # Banner response
        socket.timeout(),  # Timeout during KEXINIT drain (expected)
        b"some response with pwned",  # Final check response containing 'pwned'
    ]

    # Skip sleep calls to speed up test
    monkeypatch.setattr(time, "sleep", lambda x: None)

    exploit = cve_2025_32433.ErlangSSHPreAuthExploit()
    vulns = exploit.check(target)

    assert len(vulns) == 1
    assert vulns[0].entry.title == cve_2025_32433.VULNERABILITY_TITLE
    assert vulns[0].risk_rating.name == cve_2025_32433.RISK_RATING


def testCVE202532433_whenCheckTimeout_reportsVulnerability(
    patch_socket: DummySocket, monkeypatch: pytest.MonkeyPatch
) -> None:
    """check() should report vulnerability when timeout occurs during the check phase."""
    target = definitions.Target(scheme="ssh", host="127.0.0.1", port=2222)

    # Setup responses with a timeout during the final check (vulnerable behavior)
    patch_socket.to_receive = [
        b"SSH-2.0-Erlang-OTP\r\n",  # Banner response
        socket.timeout(),  # Timeout during KEXINIT drain (expected)
        socket.timeout(),  # Timeout during file check (indicates vulnerability)
    ]

    # Skip sleep calls to speed up test
    monkeypatch.setattr(time, "sleep", lambda x: None)

    exploit = cve_2025_32433.ErlangSSHPreAuthExploit()
    vulns = exploit.check(target)

    assert len(vulns) == 1
    assert vulns[0].entry.title == cve_2025_32433.VULNERABILITY_TITLE
    assert vulns[0].risk_rating.name == cve_2025_32433.RISK_RATING


def testCVE202532433_whenNormalResponseWithoutPwned_reportsNothing(
    patch_socket: DummySocket, monkeypatch: pytest.MonkeyPatch
) -> None:
    """check() should not report vulnerability when response doesn't contain 'pwned'."""
    target = definitions.Target(scheme="ssh", host="127.0.0.1", port=2222)

    # Setup response with a normal response not containing 'pwned' (non-vulnerable)
    patch_socket.to_receive = [
        b"SSH-2.0-Erlang-OTP\r\n",  # Banner response
        socket.timeout(),  # Timeout during KEXINIT drain (expected)
        b"error: file does not exist",  # Normal response without 'pwned'
    ]

    # Skip sleep calls to speed up test
    monkeypatch.setattr(time, "sleep", lambda x: None)

    exploit = cve_2025_32433.ErlangSSHPreAuthExploit()
    vulns = exploit.check(target)

    assert len(vulns) == 0


def testCVE202532433_whenEmptyResponse_reportsNothing(
    patch_socket: DummySocket, monkeypatch: pytest.MonkeyPatch
) -> None:
    """check() should return empty list when an empty response is received."""
    target = definitions.Target(scheme="ssh", host="127.0.0.1", port=2222)

    # Setup response with empty response (non-vulnerable)
    patch_socket.to_receive = [
        b"SSH-2.0-Erlang-OTP\r\n",  # Banner response
        socket.timeout(),  # Timeout during KEXINIT drain (expected)
        b"",  # Empty response
    ]

    # Skip sleep calls to speed up test
    monkeypatch.setattr(time, "sleep", lambda x: None)

    exploit = cve_2025_32433.ErlangSSHPreAuthExploit()
    vulns = exploit.check(target)

    assert len(vulns) == 0


def testCVE202532433_whenSocketErrorDuringCheck_reportsNothing(
    patch_socket: DummySocket, monkeypatch: pytest.MonkeyPatch
) -> None:
    """check() should return empty list when a socket error occurs during operation."""
    target = definitions.Target(scheme="ssh", host="127.0.0.1", port=2222)

    # Setup with a socket error during operation
    patch_socket.to_receive = [
        b"SSH-2.0-Erlang-OTP\r\n",  # Banner response
        socket.error("Connection reset"),  # Socket error during operation
    ]

    # Skip sleep calls to speed up test
    monkeypatch.setattr(time, "sleep", lambda x: None)

    exploit = cve_2025_32433.ErlangSSHPreAuthExploit()
    vulns = exploit.check(target)

    assert len(vulns) == 0


def testCVE202532433_whenConnectErrorInCheck_reportsNothing(
    patch_socket: DummySocket,
) -> None:
    """check() should return empty list when connect() fails."""
    target = definitions.Target(scheme="ssh", host="bad", port=2222)
    exploit = cve_2025_32433.ErlangSSHPreAuthExploit()

    assert exploit.check(target) == []


def testCVE202532433_builderFunctions_returnCorrectData() -> None:
    """Test the SSH packet builder functions."""
    # Test string_payload
    assert cve_2025_32433.string_payload("test") == b"\x00\x00\x00\x04test"

    # Test build_channel_open
    chan_open = cve_2025_32433.build_channel_open(1)
    assert chan_open.startswith(cve_2025_32433.SSH_MSG_CHANNEL_OPEN)
    assert b"session" in chan_open
    assert struct.pack(">I", 1) in chan_open  # Channel ID 1

    # Test build_channel_request
    chan_req = cve_2025_32433.build_channel_request(1, "test_command")
    assert chan_req.startswith(cve_2025_32433.SSH_MSG_CHANNEL_REQUEST)
    assert struct.pack(">I", 1) in chan_req  # Channel ID 1
    assert b"exec" in chan_req
    assert b"test_command" in chan_req

    # Test build_kexinit
    kex = cve_2025_32433.build_kexinit()
    assert kex.startswith(cve_2025_32433.SSH_MSG_KEXINIT)
    assert b"\x00" * 16 in kex  # Cookie
    assert b"curve25519-sha256" in kex

    # Test pad_packet
    payload = b"test"
    padded = cve_2025_32433.pad_packet(payload)
    padding_len = padded[4]
    assert (
        len(padded) == 4 + 1 + len(payload) + padding_len
    )  # 4B len + 1B pad_len + payload + padding
