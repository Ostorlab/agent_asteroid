"""Unit tests for CVE-2025-0890"""

import socket
from unittest import mock

from agent import definitions
from agent.exploits import cve_2025_0890


@mock.patch("socket.create_connection")
def testZyxelDefaultCredExploit_whenTargetRespondsToTelnet_accepts(
    mock_socket: mock.MagicMock,
) -> None:
    """
    Unit test for Zyxel exploit, case when the target responds to Telnet login prompts.

    This test verifies that the exploit can identify a potential Zyxel device
    by checking for a typical Telnet login response.
    """
    mock_conn = mock.MagicMock()
    mock_socket.return_value.__enter__.return_value = mock_conn
    mock_conn.recv.return_value = b"Zyxel VMG4325-B10A\nLogin: "

    target = definitions.Target(scheme="telnet", host="127.0.0.1", port=23)
    exploit_instance = cve_2025_0890.ZyxelDefaultCredExploit()

    accept = exploit_instance.accept(target)

    assert accept is True


@mock.patch("socket.create_connection")
def testZyxelDefaultCredExploit_whenTargetNotResponding_rejects(
    mock_socket: mock.MagicMock,
) -> None:
    """
    Unit test for Zyxel exploit, case when the target does not respond to Telnet.

    This test ensures that non-Zyxel or unresponsive devices are correctly rejected.
    """
    mock_conn = mock.MagicMock()
    mock_socket.return_value = mock_conn
    mock_conn.recv.return_value = b"Some other device"

    target = definitions.Target(scheme="telnet", host="127.0.0.1", port=23)
    exploit_instance = cve_2025_0890.ZyxelDefaultCredExploit()

    accept = exploit_instance.accept(target)

    assert accept is False


@mock.patch("socket.create_connection")
def testZyxelDefaultCredExploit_whenDefaultCredentialsWork_reportsVulnerability(
    mock_socket: mock.MagicMock,
) -> None:
    """
    Unit test for Zyxel exploit, case when default credentials successfully authenticate
    and command injection is possible.

    This test checks the full exploit chain: authentication and remote command execution.
    """
    mock_conn = mock.MagicMock()
    mock_socket.return_value.__enter__.return_value = mock_conn

    # Simulate successful authentication and command injection
    mock_conn.recv.side_effect = [
        b"> ",  # Login Succeeded
        b"admin:/bin/sh",  # Command injection response
    ]

    target = definitions.Target(scheme="telnet", host="127.0.0.1", port=23)
    exploit_instance = cve_2025_0890.ZyxelDefaultCredExploit()

    vulnerabilities = exploit_instance.check(target)

    assert len(vulnerabilities) > 0
    assert vulnerabilities[0].entry.title == cve_2025_0890.VULNERABILITY_TITLE
    assert vulnerabilities[0].risk_rating.name == cve_2025_0890.RISK_RATING
    assert vulnerabilities[0].vulnerability_location is not None
    assert vulnerabilities[0].dna is not None


@mock.patch("socket.create_connection")
def testZyxelDefaultCredExploit_whenAuthenticationFails_reportsNothing(
    mock_socket: mock.MagicMock,
) -> None:
    """
    Unit test for Zyxel exploit, case when authentication fails for all default credentials.

    This test verifies that no vulnerability is reported when login attempts are unsuccessful.
    """
    mock_conn = mock.MagicMock()
    mock_socket.return_value = mock_conn
    mock_conn.recv.return_value = b"Login failed"

    target = definitions.Target(scheme="telnet", host="127.0.0.1", port=23)
    exploit_instance = cve_2025_0890.ZyxelDefaultCredExploit()

    vulnerabilities = exploit_instance.check(target)
    assert len(vulnerabilities) == 0


@mock.patch("socket.create_connection")
def testZyxelDefaultCredExploit_whenSocketErrorOccurs_handlesGracefully(
    mock_socket: mock.MagicMock,
) -> None:
    """
    Unit test for Zyxel exploit, ensuring socket errors are handled without raising exceptions.

    This test checks the exploit's resilience to network communication failures.
    """
    mock_socket.side_effect = socket.error("Connection refused")

    target = definitions.Target(scheme="telnet", host="127.0.0.1", port=23)
    exploit_instance = cve_2025_0890.ZyxelDefaultCredExploit()

    vulnerabilities = exploit_instance.check(target)
    assert len(vulnerabilities) == 0
