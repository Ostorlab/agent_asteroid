"""Agent Asteroid implementation for CVE-2024-38077"""

import logging
import socket

from impacket.dcerpc.v5 import transport, epm  # type: ignore
from impacket.dcerpc.v5 import ndr, dtypes, rpcrt
from impacket import uuid  # type: ignore

from agent import definitions
from agent import exploits_registry

UUID = uuid.uuidtup_to_bin(("3d267954-eeb7-11d1-b94e-00c04fa3080d", "1.0"))
AUTH_LEVEL = 2
TIMEOUT = 30
ALIGNMENT = 4
VULNERABILITY_TITLE = "Windows Remote Desktop Licensing Service RCE"
VULNERABILITY_REFERENCE = "CVE-2024-38077"
VULNERABILITY_DESCRIPTION = (
    "The Windows Remote Desktop Licensing Service is vulnerable to an RCE. Attackers can "
    "trigger a buffer overflow, leading to arbitrary code execution within the context of the RDL service"
)
RISK_RATING = "HIGH"
RECOMMENDATION = (
    "- Apply security patches from Microsoft if available.\n"
    "- Restrict access to the licensing service.\n"
    "- Monitor for unusual activities."
)

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class ContextHandle(ndr.NDRSTRUCT):  # type: ignore
    """Represents the context handle structure used in RPC calls."""

    structure = (("Data", "20s=b"),)

    def getAlignment(self) -> int:
        """Returns the alignment value for the structure."""
        return ALIGNMENT


class TLSRpcGetVersion(ndr.NDRCALL):  # type: ignore
    """Represents the RPC call to get the version of the RDL service."""

    opnum = 0
    structure = (
        ("ctx_handle", ContextHandle),
        ("version", dtypes.PULONG),
    )


class TLSRpcConnect(ndr.NDRCALL):  # type: ignore
    """Represents the RPC call to establish a connection to the RDL service."""

    opnum = 1


class TLSRpcConnectResponse(ndr.NDRCALL):  # type: ignore
    """Represents the response to the TLSRpcConnect RPC call."""

    structure = (("ctx_handle", ContextHandle),)


def _connect_to_license_server(target_ip: str) -> str | None:
    """Connects to the target RDL service and attempts to retrieve the version.

    Args:
        target_ip (str): The IP address of the target.

    Returns:
        str | None: The version of the RDL service as a hexadecimal string, or None if the connection fails.
    """
    try:
        stringbinding = epm.hept_map(target_ip, UUID, protocol="ncacn_ip_tcp")
        logger.info("RPC Binding String: %s", stringbinding)
        rpctransport = transport.DCERPCTransportFactory(stringbinding)
        rpctransport.set_connect_timeout(TIMEOUT)
        dce = rpctransport.get_dce_rpc()
        dce.set_auth_level(AUTH_LEVEL)
        dce.connect()
        dce.bind(UUID)

        rpc_conn = TLSRpcConnect()
        res_rpc_conn = dce.request(rpc_conn)
        ctx_handle = res_rpc_conn["ctx_handle"]

        get_version = TLSRpcGetVersion()
        get_version["ctx_handle"] = ctx_handle
        get_version["version"] = 3
        res_get_version = dce.request(get_version)
        version = res_get_version["version"]
        return "0x{:x}".format(version)

    except (rpcrt.DCERPCException, socket.gaierror) as e:
        logger.error("Failed to connect or get version: %s", e)
        return None


@exploits_registry.register
class WindowsRDLServiceExploit(definitions.Exploit):
    """Main class for detecting the CVE-2024-38077 vulnerability."""

    metadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        risk_rating=RISK_RATING,
        recommendation=RECOMMENDATION,
        cve_ids=["CVE-2024-38077"],
    )

    def accept(self, target: definitions.Target) -> bool:
        """Checks if the target is likely vulnerable by attempting to connect.

        Args:
            target (definitions.Target): The target to check.

        Returns:
            bool: True if the target is likely vulnerable, False otherwise.
        """
        return _connect_to_license_server(target.origin) is not None

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        """Performs a full check to confirm the vulnerability.

        Args:
            target (definitions.Target): The target to check.

        Returns:
            list[definitions.Vulnerability]: A list of vulnerabilities found on the target.
        """
        vulnerabilities = []
        version = _connect_to_license_server(target.origin)
        if version is not None:
            vulnerabilities.append(self.create_vulnerability(target))
        return vulnerabilities
