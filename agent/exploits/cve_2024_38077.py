"""Agent Asteroid implementation for CVE-2024-38077"""

import logging
from impacket.dcerpc.v5 import transport, epm  # type: ignore
from impacket.dcerpc.v5.ndr import NDRSTRUCT, NDRCALL  # type: ignore
from impacket.dcerpc.v5.dtypes import PULONG  # type: ignore
from impacket.dcerpc.v5.rpcrt import DCERPCException  # type: ignore
from impacket.uuid import uuidtup_to_bin  # type: ignore

from ostorlab.agent.kb import kb
from ostorlab.agent.mixins import agent_report_vulnerability_mixin

from agent import definitions
from agent import exploits_registry

UUID = uuidtup_to_bin(("3d267954-eeb7-11d1-b94e-00c04fa3080d", "1.0"))
VULNERABILITY_TITLE = "Windows Remote Desktop Licensing Service RCE"
VULNERABILITY_REFERENCE = "CVE-2024-38077"
VULNERABILITY_DESCRIPTION = (
    "The Windows Remote Desktop Licensing Service is vulnerable to an RCE. Attackers can "
    "trigger a buffer overflow, leading to arbitrary code execution within the context of the RDL service"
)

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class ContextHandle(NDRSTRUCT):  # type: ignore
    structure = (("Data", "20s=b"),)

    def getAlignment(self) -> int:
        return 4


class TLSRpcGetVersion(NDRCALL):  # type: ignore
    opnum = 0
    structure = (
        ("ctx_handle", ContextHandle),
        ("version", PULONG),
    )


class TLSRpcConnect(NDRCALL):  # type: ignore
    opnum = 1


class TLSRpcConnectResponse(NDRCALL):  # type: ignore
    structure = (("ctx_handle", ContextHandle),)


def _connect_to_license_server(target_ip: str) -> str | None:
    try:
        stringbinding = epm.hept_map(target_ip, UUID, protocol="ncacn_ip_tcp")
        logger.info("RPC Binding String: %s", stringbinding)
        rpctransport = transport.DCERPCTransportFactory(stringbinding)
        rpctransport.set_connect_timeout(30)
        dce = rpctransport.get_dce_rpc()
        dce.set_auth_level(2)
        dce.connect()
        dce.bind(UUID)

        rpc_conn = TLSRpcConnect()
        res_rpc_conn = dce.request(rpc_conn)
        ctx_handle = res_rpc_conn["ctx_handle"]

        get_version = TLSRpcGetVersion()
        get_version["ctx_handle"] = ctx_handle
        get_version["version"] = 3
        res_get_version = dce.request(get_version)
        version = res_get_version["version"]
        return "0x{:x}".format(version)

    except DCERPCException as e:
        logger.error("Failed to connect or get version: %s", e)
        return None

    except Exception as e:
        logger.error("An unexpected error occurred: %s", e)
        return None


def _create_vulnerability(target: definitions.Target) -> definitions.Vulnerability:
    entry = kb.Entry(
        title=VULNERABILITY_TITLE,
        risk_rating="HIGH",
        short_description=VULNERABILITY_DESCRIPTION,
        description=VULNERABILITY_DESCRIPTION,
        references={
            "nvd.nist.gov": f"https://nvd.nist.gov/vuln/detail/{VULNERABILITY_REFERENCE}",
        },
        recommendation=(
            "- Apply security patches from Microsoft if available.\n"
            "- Restrict access to the licensing service.\n"
            "- Monitor for unusual activities."
        ),
        security_issue=True,
        privacy_issue=False,
        has_public_exploit=False,
        targeted_by_malware=False,
        targeted_by_ransomware=False,
        targeted_by_nation_state=False,
    )
    technical_detail = (
        f"{target.origin} is vulnerable to {VULNERABILITY_REFERENCE}: "
        f"{VULNERABILITY_TITLE}"
    )
    return definitions.Vulnerability(
        entry=entry,
        technical_detail=technical_detail,
        risk_rating=agent_report_vulnerability_mixin.RiskRating.HIGH,
    )


@exploits_registry.register
class WindowsRDLServiceExploit(definitions.Exploit):
    def accept(self, target: definitions.Target) -> bool:
        try:
            return _connect_to_license_server(target.origin) is not None
        except Exception as e:
            logger.error("Exception during accept: %s", e)
            return False

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        vulnerabilities = []
        version = _connect_to_license_server(target.origin)
        if version is not None:
            vulnerabilities.append(_create_vulnerability(target))
        return vulnerabilities
