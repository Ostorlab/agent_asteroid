"""Agent Asteroid implementation for CVE-2024-55591"""

import datetime
import logging
import random
import re
import socket
import ssl

import requests
from requests import exceptions as requests_exceptions

from agent import definitions
from agent import exploits_registry
from agent.exploits import webexploit

VULNERABILITY_TITLE = "Fortinet FortiOS Authentication Bypass"
VULNERABILITY_REFERENCE = "CVE-2024-55591"
VULNERABILITY_DESCRIPTION = """
An authentication bypass vulnerability in Fortinet FortiOS allows remote attackers 
to bypass authentication via specially crafted web requests.
"""
RISK_RATING = "CRITICAL"
DEFAULT_TIMEOUT = datetime.timedelta(seconds=10)

HTML_MAIN_APP_PATTERN = re.compile(r'<html class="main-app">')
F_ICON_WARNING_PATTERN = re.compile(r'<f-icon class="fa-warning')
F_ICON_CLOSING_PATTERN = re.compile(r"</f-icon>")
APSCOOKIE_PATTERN = re.compile(r"APSCOOKIE_")
UPGRADE = "Upgrade"
STATUS_CODE = 101
LOGIN_ENDPOINT = "/login?redir=/ng"


def _check_response_conditions(response: requests.Response) -> bool:
    """Validate specific conditions in the web response."""
    try:
        if response.status_code != 200:
            return False

        text = response.text
        if HTML_MAIN_APP_PATTERN.search(text) is None:
            logging.info("Target is not a FortiOS Management Interface")
            return False

        if F_ICON_WARNING_PATTERN.search(text) is None:
            logging.info("f-icon warning pattern not found")
            return False

        if F_ICON_CLOSING_PATTERN.search(text) is None:
            logging.info("f-icon closing pattern not found")
            return False

        # Check headers for APSCOOKIE marker
        if (
            any(
                APSCOOKIE_PATTERN.search(str(value))
                for value in response.headers.values()
            )
            is False
        ):
            logging.info("APSCOOKIE marker not found in headers")
            return False

        return True
    except (AttributeError, KeyError) as e:
        logging.error("Error checking response conditions: %s", e)
        return False


def _generate_random_suffix(length: int = 6) -> str:
    """Generate a random lowercase suffix."""
    return "".join(random.choice("abcdefghijklmnopqrstuvwxyz") for _ in range(length))


@exploits_registry.register
class FortiOSAuthBypassExploit(webexploit.WebExploit):
    """
    CVE-2024-55591: Fortinet FortiOS Authentication Bypass
    """

    metadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        risk_rating=RISK_RATING,
        cve_ids=["CVE-2024-55591"],
    )

    def accept(self, target: definitions.Target) -> bool:
        """Check if target is a FortiOS instance."""
        try:
            login_response = self.session.get(
                f"{target.origin}{LOGIN_ENDPOINT}",
                verify=False,
                timeout=DEFAULT_TIMEOUT.seconds,
            )

            return _check_response_conditions(login_response)

        except requests_exceptions.RequestException as e:
            logging.error("Request failed: %s", e)
            return False

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        """Check if target is vulnerable to authentication bypass."""
        vulnerabilities: list[definitions.Vulnerability] = []

        try:
            # Request with websocket headers
            websocket_headers = {
                "Sec-WebSocket-Version": "13",
                "Sec-WebSocket-Key": "thFz/fKwzu5wDEy0XO3fcw==",
                "Connection": "keep-alive, Upgrade",
                "Upgrade": "websocket",
            }
            random_suffix = _generate_random_suffix()
            websocket_response = self.session.get(
                f"{target.origin}/{random_suffix}",
                headers=websocket_headers,
                verify=False,
                timeout=DEFAULT_TIMEOUT.seconds,
            )

            if (
                websocket_response.status_code == STATUS_CODE
                and UPGRADE in websocket_response.headers.get("Connection", "")
            ):
                vulnerabilities.append(self.create_vulnerability(target))

        except requests_exceptions.RequestException as e:
            logging.error("Request failed: %s", e)
        except (socket.error, ssl.SSLError) as e:
            logging.error("Network error: %s", e)

        return vulnerabilities
