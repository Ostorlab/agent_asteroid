"""Agent Asteroid implementation for CVE-2025-10035"""

import re
import logging
from typing import List, Optional

from requests import exceptions as requests_exceptions
from packaging import version

from agent import definitions
from agent import exploits_registry

VULNERABILITY_TITLE = "GoAnywhere MFT License Servlet Deserialization Vulnerability"
VULNERABILITY_REFERENCE = "CVE-2025-10035"
VULNERABILITY_DESCRIPTION = (
    "A deserialization vulnerability in the License Servlet of Fortra's GoAnywhere MFT allows "
    "remote attackers to execute arbitrary code via crafted serialized data. This vulnerability "
    "affects multiple version ranges of GoAnywhere MFT and can be exploited without authentication."
)
VULNERABILITY_RECOMMENDATION = (
    "- Update GoAnywhere MFT to version 7.8.5 or later\n"
    "- If using sustained support versions, upgrade beyond 7.6.3\n"
    "- Apply security patches from Fortra\n"
    "- Monitor network traffic for exploitation attempts\n"
    "- Implement network segmentation to limit access to GoAnywhere MFT instances"
)
RISK_RATING = "CRITICAL"
DEFAULT_TIMEOUT = 30

# Version ranges that are vulnerable
LATEST_MIN = version.parse("7.7.0")
LATEST_MAX = version.parse("7.8.4")
SUSTAIN_MAX = version.parse("7.6.3")

# GoAnywhere identification patterns
GOANYWHERE_PATTERNS = [
    r"GoAnywhere\s+Managed\s+File\s+Transfer",
    r"GoAnywhere\s+MFT",
]

VERSION_PATTERN = re.compile(r"GoAnywhere\s+([0-9]+\.[0-9]+\.[0-9]+)")
LOGIN_ENDPOINT = "/goanywhere/auth/Login.xhtml"

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


@exploits_registry.register
class GoAnywhereDeserializationExploit(definitions.Exploit):
    """
    CVE-2025-10035: GoAnywhere MFT License Servlet Deserialization Vulnerability
    """

    metadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        risk_rating=RISK_RATING,
        recommendation=VULNERABILITY_RECOMMENDATION,
        has_public_exploit=True,
        targeted_by_malware=False,
        targeted_by_ransomware=False,
        targeted_by_nation_state=False,
        cve_ids=[VULNERABILITY_REFERENCE],
        references={
            "github.com": "https://github.com/advisories/GHSA-fcfw-g3g2-2588",
            "fortra.com": "https://www.fortra.com/security-advisories",
        },
    )

    def accept(self, target: definitions.Target) -> bool:
        """
        Check if the target appears to be a GoAnywhere MFT instance.

        Args:
            target: The target to check

        Returns:
            True if target appears to be GoAnywhere MFT, False otherwise
        """
        try:
            # Try the login endpoint first
            login_url = f"{target.origin}{LOGIN_ENDPOINT}"
            response = self.session.get(login_url, timeout=DEFAULT_TIMEOUT)

            # Check if this looks like GoAnywhere
            if self._is_goanywhere_response(response.text) is True:
                return True

            # Fallback: try root endpoint
            root_response = self.session.get(target.origin, timeout=DEFAULT_TIMEOUT)

            return self._is_goanywhere_response(root_response.text) is True

        except requests_exceptions.RequestException:
            return False

    def check(self, target: definitions.Target) -> List[definitions.Vulnerability]:
        """
        Check if the GoAnywhere MFT instance is vulnerable to CVE-2025-10035.

        Args:
            target: The target to test for vulnerability

        Returns:
            List of vulnerabilities found (empty list if none)
        """
        vulnerabilities: List[definitions.Vulnerability] = []

        try:
            # Get the login page to extract version information
            login_url = f"{target.origin}{LOGIN_ENDPOINT}"
            response = self.session.get(login_url, timeout=DEFAULT_TIMEOUT)

            # Confirm this is GoAnywhere
            if self._is_goanywhere_response(response.text) is False:
                return vulnerabilities

            detected_version = self._extract_version(response.text)
            if detected_version is None:
                logger.warning(
                    f"Could not determine GoAnywhere version for {target.origin}"
                )
                return vulnerabilities

            # Check if version is vulnerable
            if self._is_vulnerable_version(detected_version) is True:
                vuln = self.create_vulnerability(target)
                vuln.technical_detail = (
                    f"{target.origin} is running GoAnywhere MFT version {detected_version} "
                    f"which is vulnerable to {VULNERABILITY_REFERENCE}. This version contains "
                    f"a deserialization vulnerability in the License Servlet that allows "
                    f"remote code execution."
                )
                vulnerabilities.append(vuln)
                logger.info(
                    f"Vulnerable GoAnywhere MFT found: {target.origin} (v{detected_version})"
                )
            else:
                logger.info(
                    f"GoAnywhere MFT at {target.origin} (v{detected_version}) is not vulnerable"
                )

        except requests_exceptions.RequestException as e:
            logger.error(f"Vulnerability check failed for {target.origin}: {e}")

        return vulnerabilities

    def _is_goanywhere_response(self, response_text: str | None = None) -> bool:
        """
        Check if response text indicates GoAnywhere MFT.

        Args:
            response_text: HTTP response content

        Returns:
            True if response indicates GoAnywhere MFT
        """
        if response_text is None or response_text.strip() == "":
            return False

        try:
            for pattern in GOANYWHERE_PATTERNS:
                if re.search(pattern, response_text, re.IGNORECASE) is not None:
                    return True
            return False
        except re.error as e:
            logger.error(f"Regex error in GoAnywhere detection: {e}")
            return False

    def _extract_version(self, response_text: str) -> Optional[str]:
        """
        Extract GoAnywhere version from response text.

        Args:
            response_text: HTTP response content

        Returns:
            Version string if found, None otherwise
        """
        if response_text is None or response_text.strip() == "":
            return None

        try:
            match = VERSION_PATTERN.search(response_text)
            if match is not None:
                return match.group(1)
            return None
        except re.error as e:
            logger.error(f"Regex error in version extraction: {e}")
            return None

    def _is_vulnerable_version(self, version_string: str) -> bool:
        """
        Check if the given version is vulnerable to CVE-2025-10035.

        Args:
            version_string: Version string to check

        Returns:
            True if version is vulnerable, False otherwise
        """
        try:
            ver = version.parse(version_string)

            # Check latest branch vulnerability range (7.7.0 <= version <= 7.8.4)
            if LATEST_MIN <= ver <= LATEST_MAX:
                return True

            # Check sustained support branch vulnerability (version < 7.6.3)
            if ver < SUSTAIN_MAX:
                return True

            return False

        except (ValueError, TypeError) as e:
            logger.error(f"Error parsing version '{version_string}': {e}")
            return False
