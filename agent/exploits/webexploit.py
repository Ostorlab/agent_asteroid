import re
from urllib import parse as urlparse

import requests
from ostorlab.agent.kb import kb
from ostorlab.agent.mixins import agent_report_vulnerability_mixin
from requests import exceptions as requests_exceptions

from agent import definitions
from packaging import version

MAX_REDIRECTS = 2
DEFAULT_TIMEOUT = 90

#This is the version pattern list
#Please Add your version pattern if none of them match it
#and make sure to put an example to clarify 
version_pattern = [re.compile(r'\bv\d+\.\d+\.\d+(?:-\d+)?\b')]  # e.g., "v5.2.19-3" or "v1.2.3-4"


class WebExploit(definitions.Exploit):
    accept_request: definitions.Request
    check_request: definitions.Request
    accept_pattern: list[re.Pattern[str]] | None = None
    match_pattern: list[re.Pattern[str]] | None = None
    vuln_ranges : list[definitions.VulnRange] | None = None
    metadata: definitions.VulnerabilityMetadata

    def accept(self, target: definitions.Target) -> bool:
        """Rule: heuristically detect if a specific target is valid.

        Args:
            target: Target to verify

        Returns:
            True if the target is valid; otherwise False.
        """
        session = requests.Session()
        session.max_redirects = MAX_REDIRECTS
        session.verify = False

        target_endpoint = urlparse.urljoin(target.origin, self.accept_request.path)

        try:
            req = requests.Request(
                method=self.accept_request.method,
                url=target_endpoint,
                data=self.accept_request.data,
            ).prepare()
            # Requests library standardizes headers before submitting the request
            # We override this behavior to allow for unsupported cases like headers with
            # Duplicate names. We ignore typing because we assign dict to CaseInsensitiveDict
            if self.accept_request.headers is not None:
                self.accept_request.headers.update(req.headers)
                req.headers = self.accept_request.headers  # type: ignore
            resp = session.send(req, timeout=DEFAULT_TIMEOUT, verify=False)
        except requests_exceptions.RequestException:
            return False

        for pattern in self.accept_pattern:
            if pattern.search(resp.text) is not None:
                return True
        return False

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        """Rule to detect specific vulnerability on a specific target.

        Args:
            target: Target to scan

        Returns:
            List of identified vulnerabilities.
        """
        session = requests.Session()
        session.max_redirects = MAX_REDIRECTS
        session.verify = False

        vulnerabilities: list[definitions.Vulnerability] = []

        target_endpoint = urlparse.urljoin(target.origin, self.check_request.path)

        try:
            req = requests.Request(
                method=self.check_request.method,
                url=target_endpoint,
                data=self.check_request.data,
            ).prepare()
            # Requests library standardizes headers before submitting the request
            # We override this behavior to allow for unsupported cases like headers with
            # Duplicate names. We ignore typing because we assign dict to CaseInsensitiveDict
            if self.check_request.headers is not None:
                self.check_request.headers.update(req.headers)
                req.headers = self.check_request.headers  # type: ignore
            resp = session.send(req, timeout=DEFAULT_TIMEOUT, verify=False)
        except requests_exceptions.RequestException:
            return vulnerabilities

        for pattern in self.match_pattern:
            if pattern.search(resp.text) is not None:
                vulnerability = self._create_vulnerability(target)
                vulnerabilities.append(vulnerability)
                return vulnerabilities

        if self.vuln_ranges is not None:
            for pattern in version_pattern :
                if pattern.search(resp.text) is not None:
                    for range in self.vuln_ranges:
                        if range.min <= version.parse(pattern) <= range.max:
                            vulnerability = self._create_vulnerability(target)
                            vulnerabilities.append(vulnerability)
                            return vulnerabilities
                        
        #TODO(youssef) check if this always return an empty list                           
        return vulnerabilities

    def _create_vulnerability(
        self, target: definitions.Target
    ) -> definitions.Vulnerability:
        entry = kb.Entry(
            title=self.metadata.title,
            risk_rating=self.metadata.risk_rating,
            short_description=self.metadata.description,
            description=self.metadata.description,
            references={
                "nvd.nist.gov": f"https://nvd.nist.gov/vuln/detail/{self.metadata.reference}",
            },
            recommendation=(
                "- Make sure to install the latest security patches from software vendor \n"
                "- Update to the latest software version"
            ),
            security_issue=True,
            privacy_issue=False,
            has_public_exploit=True,
            targeted_by_malware=False,
            targeted_by_ransomware=False,
            targeted_by_nation_state=False,
        )
        technical_detail = (
            f"{target.origin} is vulnerable to {self.metadata.reference}, "
            f"{self.metadata.title}"
        )
        vulnerability = definitions.Vulnerability(
            entry=entry,
            technical_detail=technical_detail,
            risk_rating=agent_report_vulnerability_mixin.RiskRating.CRITICAL,
        )
        return vulnerability
