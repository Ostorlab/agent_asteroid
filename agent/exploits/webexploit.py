import re
import urllib3
from urllib import parse as urlparse

import requests
from requests import exceptions as requests_exceptions
from packaging import version
from ostorlab.agent.kb import kb
from ostorlab.agent.mixins import agent_report_vulnerability_mixin

from agent import definitions

DEFAULT_TIMEOUT = 90

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


class WebExploit(definitions.Exploit):
    accept_request: definitions.Request
    check_request: definitions.Request
    accept_pattern: list[re.Pattern[str]] = []
    match_pattern: list[re.Pattern[str]] = []
    vuln_ranges: list[definitions.VulnRange] = []
    metadata: definitions.VulnerabilityMetadata
    version_pattern: re.Pattern[str] | None = None

    def accept(self, target: definitions.Target) -> bool:
        """Rule: heuristically detect if a specific target is valid.

        Args:
            target: Target to verify

        Returns:
            True if the target is valid; otherwise False.
        """
        target_endpoint = urlparse.urljoin(target.origin, self.accept_request.path)

        try:
            req = requests.Request(
                method=self.accept_request.method,
                url=target_endpoint,
                data=self.accept_request.data,
            ).prepare()
            # Requests library standardizes headers before submitting the request
            # We override this behavior to allow for unsupported cases like headers with
            # Duplicate names. We ignore typing because we assign dict to CaseInsensitiveDict
            if self.accept_request.headers is not None:
                self.accept_request.headers.update(req.headers)
                req.headers = self.accept_request.headers  # type: ignore
            resp = self.session.send(req, timeout=DEFAULT_TIMEOUT)
        except requests_exceptions.RequestException:
            return False

        for pattern in self.accept_pattern:
            if pattern.search(resp.text) is not None:
                return True
        return False

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        """Rule to detect specific vulnerability on a specific target.

        Args:
            target: Target to scan

        Returns:
            List of identified vulnerabilities.
        """
        vulnerabilities: list[definitions.Vulnerability] = []

        target_endpoint = urlparse.urljoin(target.origin, self.check_request.path)

        try:
            req = requests.Request(
                method=self.check_request.method,
                url=target_endpoint,
                data=self.check_request.data,
            ).prepare()
            # Requests library standardizes headers before submitting the request
            # We override this behavior to allow for unsupported cases like headers with
            # Duplicate names. We ignore typing because we assign dict to CaseInsensitiveDict
            if self.check_request.headers is not None:
                self.check_request.headers.update(req.headers)
                req.headers = self.check_request.headers  # type: ignore
            resp = self.session.send(req, timeout=DEFAULT_TIMEOUT)
        except requests_exceptions.RequestException:
            return vulnerabilities

        for pattern in self.match_pattern:
            if pattern.search(resp.text) is not None:
                vulnerability = self._create_vulnerability(target)
                vulnerabilities.append(vulnerability)
                return vulnerabilities

        if self.vuln_ranges is not None:
            if self.version_pattern is not None:
                if (matched := self.version_pattern.findall(resp.text)) is not None:
                    for extracted_version in matched:
                        if isinstance(extracted_version, tuple):
                            extracted_version = extracted_version[0]
                        for range in self.vuln_ranges:
                            if (
                                range.min is None
                                or range.min <= version.parse(extracted_version)
                            ) and (
                                range.max is None
                                or range.max >= version.parse(extracted_version)
                            ):
                                vulnerability = self._create_vulnerability(target)
                                vulnerabilities.append(vulnerability)
                                return vulnerabilities

        return vulnerabilities

    def _create_vulnerability(
        self, target: definitions.Target
    ) -> definitions.Vulnerability:
        entry = kb.Entry(
            title=self.metadata.title,
            risk_rating=self.metadata.risk_rating,
            short_description=self.metadata.description,
            description=self.metadata.description,
            references={
                f"nvd.nist.gov/{cve}": f"https://nvd.nist.gov/vuln/detail/{cve}"
                for cve in self.metadata.reference
            },
            recommendation=(
                "- Make sure to install the latest security patches from software vendor \n"
                "- Update to the latest software version"
            ),
            security_issue=True,
            privacy_issue=False,
            has_public_exploit=True,
            targeted_by_malware=False,
            targeted_by_ransomware=False,
            targeted_by_nation_state=False,
        )
        technical_detail = (
            f"{target.origin} is vulnerable to {self.metadata.reference}, "
            f"{self.metadata.title}"
        )
        vulnerability = definitions.Vulnerability(
            entry=entry,
            technical_detail=technical_detail,
            risk_rating=agent_report_vulnerability_mixin.RiskRating[
                self.metadata.risk_rating.upper()
            ],
        )
        return vulnerability
