"""Agent Asteroid implementation for CVE-2023-43770"""

import re
from urllib import parse as urlparse

import requests
from ostorlab.agent.kb import kb
from ostorlab.agent.mixins import agent_report_vulnerability_mixin
from packaging import version
from requests import exceptions as requests_exceptions

from agent import definitions
from agent import exploits_registry

VULNERABILITY_TITLE = (
    "Roundcube Webmail Persistent Cross-Site Scripting (XSS) Vulnerability"
)
VULNERABILITY_REFERENCE = "CVE-2023-43770"
VULNERABILITY_DESCRIPTION = (
    "Roundcube Webmail contains a persistent cross-site scripting (XSS) vulnerability that can "
    "lead to information disclosure via malicious link references in plain/text messages."
)

DEFAULT_TIMEOUT = 30
MAIL_ENDPOINT_PATTERN = re.compile(r'content="\d; url=(.*)"')
DEFAULT_MAIL_ENDPOINT = "/mail/"
VERSION_PATTERN = re.compile(r'"rcversion":(\d+)')
VULNERABLE_RANGES = [
    (version.parse("1.0.0"), version.parse("1.4.13")),
    (version.parse("1.5.0"), version.parse("1.5.3")),
    (version.parse("1.6.0"), version.parse("1.6.2")),
]
MAX_REDIRECTS = 2
ROUNDCUBE_KEYWORD = "rcmail"


@exploits_registry.register
class CVE202343770Exploit(definitions.Exploit):
    """
    CVE-2023-43770: Roundcube Webmail Persistent Cross-Site Scripting (XSS) Vulnerability
    """

    def accept(self, target: definitions.Target) -> bool:
        session = requests.Session()
        session.max_redirects = MAX_REDIRECTS
        session.verify = False

        mail_url = self._get_mail_url(session, target)
        if mail_url is None:
            return False
        try:
            resp = session.get(mail_url, timeout=DEFAULT_TIMEOUT)
        except requests_exceptions.RequestException:
            return False

        return ROUNDCUBE_KEYWORD in resp.text

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        session = requests.Session()
        session.max_redirects = MAX_REDIRECTS
        session.verify = False

        vulnerabilities: list[definitions.Vulnerability] = []

        mail_url = self._get_mail_url(session, target)
        if mail_url is None:
            return vulnerabilities

        try:
            resp = session.get(mail_url, timeout=DEFAULT_TIMEOUT)
        except requests_exceptions.RequestException:
            return vulnerabilities

        target_version_match = VERSION_PATTERN.search(resp.text)
        if target_version_match is None:
            return vulnerabilities

        rc_version = self._parse_rc_version(target_version_match.group(1))
        for version_range in VULNERABLE_RANGES:
            if version_range[0] <= rc_version <= version_range[1]:
                vulnerability = self._create_vulnerability(target)
                vulnerabilities.append(vulnerability)

        return vulnerabilities

    def _create_vulnerability(
        self, target: definitions.Target
    ) -> definitions.Vulnerability:
        entry = kb.Entry(
            title=VULNERABILITY_TITLE,
            risk_rating="MEDIUM",
            short_description=VULNERABILITY_DESCRIPTION,
            description=VULNERABILITY_DESCRIPTION,
            references={
                "nvd.nist.gov": f"https://nvd.nist.gov/vuln/detail/{VULNERABILITY_REFERENCE}",
                "github.com": "https://github.com/roundcube/roundcubemail/compare/1.5.5...1.5.6",
            },
            recommendation=(
                "- Make sure to install the latest security patches from software vendor \n"
                "- Update to the latest software version"
            ),
            security_issue=True,
            privacy_issue=False,
            has_public_exploit=True,
            targeted_by_malware=False,
            targeted_by_ransomware=False,
            targeted_by_nation_state=True,
        )
        technical_detail = (
            f"{target.origin} is vulnerable to {VULNERABILITY_REFERENCE}, "
            f"{VULNERABILITY_TITLE}"
        )
        vulnerability = definitions.Vulnerability(
            entry=entry,
            technical_detail=technical_detail,
            risk_rating=agent_report_vulnerability_mixin.RiskRating.CRITICAL,
        )
        return vulnerability

    def _get_mail_url(
        self, session: requests.Session, target: definitions.Target
    ) -> str | None:
        try:
            resp = session.get(target.origin, timeout=DEFAULT_TIMEOUT)
        except requests_exceptions.RequestException:
            return None

        mail_endpoint_match = MAIL_ENDPOINT_PATTERN.search(resp.text)
        if mail_endpoint_match is None:
            mail_endpoint = DEFAULT_MAIL_ENDPOINT
        else:
            mail_endpoint = mail_endpoint_match.group(1)

        return urlparse.urljoin(target.origin, mail_endpoint)

    def _parse_rc_version(self, raw_version: str) -> version.Version:
        rc_version = int(raw_version)
        major_version = rc_version // 10000
        minor_version = (rc_version % 10000) // 100
        patch_level = rc_version % 100
        parsed_version = version.parse(f"{major_version}.{minor_version}.{patch_level}")
        return parsed_version
