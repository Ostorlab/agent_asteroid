"""Common utilities for the exploits."""

import ipaddress
import json
from typing import cast, Any
from urllib import parse

import tld
from ostorlab.agent.mixins import agent_report_vulnerability_mixin
from ostorlab.assets import domain_name as domain_asset
from ostorlab.assets import ipv4 as ipv4_asset
from ostorlab.assets import ipv6 as ipv6_asset


def _is_ipv6(ip: str) -> bool:
    """Check if the provided IP is an IPv6 address.
    Args:
        ip: The IP address to check.
    Returns:
        True if the IP is an IPv6 address, False otherwise.
    """
    try:
        ipaddress.IPv6Address(ip)
        return True
    except ipaddress.AddressValueError:
        return False


def prepare_host(host: str) -> str:
    """Prepare the host for the request.
    Args:
        host: The host to prepare.
    Returns:
        The prepared host.
    """
    if _is_ipv6(host) is True:
        return f"[{host}]"
    return host


def is_ipv4(potential_ip: str) -> bool:
    """check if the potential_ip is a valid ipv4.

    Args:
        potential_ip: string.

    Returns:
        - boolean.
    """
    ip, _ = split_ipv4(potential_ip)
    try:
        ipaddress.IPv4Address(ip)
        return True
    except ValueError:
        return False


def split_ipv4(potential_ip: str) -> tuple[str, str | None]:
    """split the potential_ip to get the ip and the port if existed.

    Args:
        potential_ip: string.

    Returns:
        - ip, port.
    """
    ip = potential_ip
    port = None
    if ":" in potential_ip:
        ip, port = potential_ip.split(":", maxsplit=1)
    return ip, port


def is_ipv6(potential_ip: str) -> bool:
    """check if the potential_ip is a valid ipv6.

    Args:
        potential_ip: string.

    Returns:
        - boolean.
    """
    try:
        ipaddress.IPv6Address(potential_ip)
        return True
    except ValueError:
        return False


def build_vuln_location(
    target_url: str,
) -> agent_report_vulnerability_mixin.VulnerabilityLocation:
    """Build VulnerabilityLocation based on the asset.

    Args:
        The target URL.

    Returns:
        The vulnerability location object.
    """
    metadata = []
    target = parse.urlparse(target_url)
    asset: ipv4_asset.IPv4 | ipv6_asset.IPv6 | domain_asset.DomainName
    ip = None
    port = None
    potential_ip = target_url
    if target.scheme != "":
        potential_ip = potential_ip.replace(f"{target.scheme}://", "")
    if is_ipv4(potential_ip) is True:
        ip, port = split_ipv4(potential_ip)
        asset = ipv4_asset.IPv4(host=str(ip), version=4, mask="32")
    elif is_ipv6(potential_ip) is True:
        asset = ipv6_asset.IPv6(host=str(potential_ip), version=6, mask="128")
    else:
        full_url = parse.urlunparse(
            (target.scheme, target.netloc, target.path, "", "", "")
        )
        metadata.append(
            agent_report_vulnerability_mixin.VulnerabilityLocationMetadata(
                metadata_type=agent_report_vulnerability_mixin.MetadataType.URL,
                value=full_url,
            )
        )
        asset = domain_asset.DomainName(name=prepare_domain_asset(target_url))

    if target.port is not None or (ip is not None and port is not None):
        metadata_type = agent_report_vulnerability_mixin.MetadataType.PORT
        metadata_value = str(target.port) if target.port is not None else port
        if metadata_value is not None:
            metadata.append(
                agent_report_vulnerability_mixin.VulnerabilityLocationMetadata(
                    metadata_type=metadata_type, value=metadata_value
                )
            )

    return agent_report_vulnerability_mixin.VulnerabilityLocation(
        asset=asset, metadata=metadata
    )


def prepare_domain_asset(url: str) -> str:
    """Prepares the domain asset object for the given URL.

    Args:
    url: The URL to extract the domain from.

    Returns:
    Optional[domain_asset.DomainName]: A domain asset
    """
    if url is None:
        return ""

    canonized_domain = tld.get_tld(
        url, as_object=True, fix_protocol=True, fail_silently=True
    )

    if canonized_domain is None:
        return parse.urlparse(url).netloc

    tld_domain = cast(tld.Result, canonized_domain)
    result_neloc = tld_domain.parsed_url.netloc
    if ":" in result_neloc:
        asset = result_neloc.split(":")[0]
    else:
        asset = result_neloc

    return asset


def compute_dna(
    vulnerability_title: str,
    vuln_location: agent_report_vulnerability_mixin.VulnerabilityLocation,
) -> str:
    """Compute a deterministic, debuggable DNA representation for a vulnerability.

    Args:
        vulnerability_title: The title of the vulnerability.
        vuln_location: The location of the vulnerability.

    Returns:
        A deterministic JSON representation of the vulnerability DNA.
    """
    dna_data: dict[str, Any] = {"title": vulnerability_title}

    if vuln_location is not None:
        location_dict: dict[str, Any] = vuln_location.to_dict()
        sorted_location_dict = sort_dict(location_dict)
        dna_data["location"] = sorted_location_dict

    return json.dumps(dna_data, sort_keys=True)


def sort_dict(d: dict[str, Any] | list[Any]) -> dict[str, Any] | list[Any]:
    """Recursively sort dictionary keys and lists within.

    Args:
        d: The dictionary or list to sort.

    Returns:
        A sorted dictionary or list.
    """
    if isinstance(d, dict):
        return {k: sort_dict(v) for k, v in sorted(d.items())}
    if isinstance(d, list):
        return sorted(
            d,
            key=lambda x: json.dumps(x, sort_keys=True)
            if isinstance(x, dict)
            else str(x),
        )
    return d
