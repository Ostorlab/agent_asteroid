"""Agent Asteroid implementation for CVE-2024-10905"""

import datetime
import re
from urllib import parse as urlparse

import requests
from packaging import version
from requests import exceptions as requests_exceptions

from agent import definitions
from agent import exploits_registry
from agent.exploits import webexploit

VULNERABILITY_TITLE = "SailPoint IdentityIQ Static File Exposure"
VULNERABILITY_REFERENCE = "CVE-2024-10905"
VULNERABILITY_DESCRIPTION = """A critical vulnerability in SailPoint IdentityIQ 
allows unauthorized access to files in the application directory via improper handling 
of virtual resources. Exploiting this flaw could lead to sensitive file disclosure."""
RISK_RATING = "CRITICAL"

# Define vulnerable ranges
VULNERABLE_VERSIONS = [
    (version.parse("8.4"), version.parse("8.4.2")),
    (version.parse("8.3"), version.parse("8.3.5")),
    (version.parse("8.2"), version.parse("8.2.8")),
]

DEFAULT_TIMEOUT = datetime.timedelta(seconds=90)

VERSION_PATTERN = re.compile(r"Build:\s*(\d+\.\d+)([a-z]*)(\d*)")


def _normalize_version(build_string: str) -> str:
    """Normalize build strings like '8.4p1' to semantic versions like '8.4.1'."""
    match = VERSION_PATTERN.match(build_string)
    if match is not None:
        base_version = match.group(1)
        patch_letter = match.group(2)
        patch_number = match.group(3)
        # Convert patch letter to number if present, e.g., 'p1' -> '.1'
        if patch_letter != "" and patch_number != "":
            return f"{base_version}.{patch_number}"
        return base_version
    return build_string


def _is_version_vulnerable(build_string: str) -> bool:
    """Check if the given build string matches any of the vulnerable ranges."""
    normalized_version = version.parse(_normalize_version(build_string))
    # Check for versions below 8.2 (All prior versions)
    if normalized_version < version.parse("8.2"):
        return True
    for lower, upper in VULNERABLE_VERSIONS:
        if lower <= normalized_version < upper:
            return True
    return False


@exploits_registry.register
class CVE202410905Exploit(webexploit.WebExploit):
    accept_request = definitions.Request(
        method="GET", path="/identityiq/login.jsf?prompt=true"
    )
    check_request = definitions.Request(
        method="GET", path="/identityiq/login.jsf?prompt=true"
    )

    accept_pattern = [re.compile(r"SailPoint IdentityIQ")]

    metadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        risk_rating=RISK_RATING,
    )

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        """Check if the page indicates a vulnerable version."""
        vulnerabilities: list[definitions.Vulnerability] = []

        target_endpoint = urlparse.urljoin(target.origin, self.check_request.path)

        try:
            req = requests.Request(
                method=self.check_request.method,
                url=target_endpoint,
                data=self.check_request.data,
            ).prepare()
            response = self.session.send(
                req, timeout=DEFAULT_TIMEOUT.seconds, allow_redirects=True
            )

        except requests_exceptions.RequestException:
            return vulnerabilities

        if match := VERSION_PATTERN.search(response.text):
            detected_version = match.group(0)  # Full build string
            if _is_version_vulnerable(detected_version) is True:
                return [self.create_vulnerability(target)]
        return vulnerabilities
