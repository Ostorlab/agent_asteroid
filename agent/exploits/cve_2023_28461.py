"""Agent Asteroid implementation for CVE-2023-28461"""

import datetime
import logging
import re
import ssl
from typing import Any
from urllib import parse as urlparse

import urllib3
from packaging import version

from agent import definitions
from agent import exploits_registry
from agent.exploits import webexploit

VULNERABILITY_TITLE = (
    "Array Networks Array AG Series and vxAG Remote Code Execution Vulnerability"
)
VULNERABILITY_REFERENCE = "CVE-2023-28461"
VULNERABILITY_DESCRIPTION = """A critical vulnerability in Array Networks Array AG Series and vxAG
SSL VPN gateways allows remote code execution by exploiting an HTTP header with the 'flags' attribute
to browse the filesystem without authentication."""
RISK_RATING = "CRITICAL"
MAX_VULNERABLE_VERSION = version.parse("9.4.0.481")

DEFAULT_TIMEOUT = datetime.timedelta(seconds=90)


@exploits_registry.register
class CVE202328461Exploit(webexploit.WebExploit):
    accept_request = definitions.Request(
        method="GET", path="/prx/000/http/localhost/login"
    )
    accept_pattern = [re.compile(r"Rel_AG_(\d+_\d+_\d+_\d+)")]
    metadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        risk_rating=RISK_RATING,
    )

    def _create_ssl_context(self) -> Any:
        """Creates an SSL context that allows insecure connections."""
        ctx = urllib3.util.ssl_.create_urllib3_context()
        ctx.load_default_certs()
        ctx.options |= 0x4  # ssl.OP_LEGACY_SERVER_CONNECT
        ctx.check_hostname = False
        ctx.verify_mode = ssl.CERT_NONE
        return ctx

    def _send_ssl_request(self, url: str) -> Any:
        """Send a GET request using urllib3 with a custom SSL context."""
        ssl_context = self._create_ssl_context()
        with urllib3.PoolManager(ssl_context=ssl_context) as http:
            try:
                response = http.request(
                    "GET", url, timeout=DEFAULT_TIMEOUT.total_seconds()
                )
                return response.data.decode("utf-8")
            except urllib3.exceptions.HTTPError as e:
                logging.error("Error during SSL request: %s", e)
                return ""

    def accept(self, target: definitions.Target) -> bool:
        """Checks if the target matches the accept pattern.

        Args:
            target: Target to verify

        Returns:
            True if the target appears valid; otherwise False.
        """
        target_endpoint = urlparse.urljoin(target.origin, self.accept_request.path)
        response_body = self._send_ssl_request(target_endpoint)

        for pattern in self.accept_pattern:
            if pattern.search(response_body) is not None:
                return True

        return False

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        """Rule to detect specific vulnerability on a specific target.

        Args:
            target: Target to scan

        Returns:
            List of identified vulnerabilities.
        """
        vulnerabilities: list[definitions.Vulnerability] = []
        target_endpoint = urlparse.urljoin(target.origin, self.accept_request.path)
        response_body = self._send_ssl_request(target_endpoint)

        for pattern in self.accept_pattern:
            match = pattern.search(response_body)
            if match is not None:
                version_str = match.group(1).replace("_", ".")
                target_version = version.parse(version_str)

                if target_version <= MAX_VULNERABLE_VERSION:
                    vulnerability = self._create_vulnerability(target)
                    vulnerabilities.append(vulnerability)
                break

        return vulnerabilities
