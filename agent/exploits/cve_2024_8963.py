"""Agent Asteroid implementation for CVE-2024-8963"""

import re
import logging
import datetime
import requests

from urllib import parse as urlparse

from agent.exploits import webexploit
from agent import exploits_registry
from agent import definitions


VULNERABILITY_TITLE = "Path Traversal in Ivanti CSA"
VULNERABILITY_REFERENCE = "CVE-2024-8963"
VULNERABILITY_DESCRIPTION = """Path Traversal in the Ivanti CSA before 4.6 Patch 519 allows a remote unauthenticated attacker to access restricted functionality."""
RISK_RATING = "CRITICAL"
PATCH_DATE = datetime.datetime(2024, 9, 10)

MAX_REDIRECTS = 2
DEFAULT_TIMEOUT = 90


@exploits_registry.register
class CVE20248963Exploit(webexploit.WebExploit):
    accept_request = definitions.Request(method="GET", path="/")
    check_request = definitions.Request(method="GET", path="/allowed/ivanti-logo.png")
    accept_pattern = [
        re.compile(r"<title>Ivanti\(R\) Cloud Services Appliance</title>")
    ]
    metadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        risk_rating=RISK_RATING,
    )

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        """Rule to detect specific vulnerability on a specific target.

        Args:
            target: Target to scan

        Returns:
            List of identified vulnerabilities.
        """
        session = requests.Session()
        session.max_redirects = MAX_REDIRECTS
        session.verify = False

        vulnerabilities: list[definitions.Vulnerability] = []

        target_endpoint = urlparse.urljoin(target.origin, self.check_request.path)

        try:
            req = requests.Request(
                method=self.check_request.method,
                url=target_endpoint,
            ).prepare()
            resp = session.send(req, timeout=DEFAULT_TIMEOUT)
        except requests.RequestException as e:
            logging.error("HTTP Request failed: %s", e)
            return vulnerabilities

        if "Last-Modified" not in resp.headers:
            return vulnerabilities

        try:
            last_modified = datetime.datetime.strptime(
                resp.headers["Last-Modified"], "%a, %d %b %Y %H:%M:%S %Z"
            )
        except ValueError as e:
            logging.error("Couldn't parse date string and format: %s", e)
            return vulnerabilities

        if last_modified < PATCH_DATE:
            vulnerability = self._create_vulnerability(target)
            vulnerabilities.append(vulnerability)

        return vulnerabilities
