import socket
import re
import logging

from ostorlab.agent.kb import kb
from ostorlab.agent.mixins import agent_report_vulnerability_mixin

from agent import definitions, exploits_registry

VULNERABILITY_TITLE = "OpenSSH Remote Code Execution Vulnerability"
VULNERABILITY_REFERENCE = "CVE-2024-6387"
VULNERABILITY_DESCRIPTION = (
    "A remote code execution vulnerability in multiple versions of OpenSSH allows remote attackers to execute "
    "arbitrary code, granting full root access. The vulnerability affects the default configuration and does not "
    "require user interaction."
)
DEFAULT_TIMEOUT = 90
VULNERABLE_VERSIONS = [
    "8.5",
    "8.6",
    "8.7",
    "8.8",
    "8.9",
    "9.0",
    "9.1",
    "9.2",
    "9.3",
    "9.4",
    "9.5",
    "9.6",
    "9.7",
]

logger = logging.getLogger(__name__)


def _create_vulnerability(
    target: definitions.Target, details: str
) -> definitions.Vulnerability:
    """Creates a vulnerability instance with the given details.

    Args:
        target: The target instance.
        details: The details of the vulnerability.

    Returns:
        A Vulnerability instance.
    """
    entry = kb.Entry(
        title=VULNERABILITY_TITLE,
        risk_rating="CRITICAL",
        short_description=VULNERABILITY_DESCRIPTION,
        description=VULNERABILITY_DESCRIPTION,
        references={
            "nvd.nist.gov": f"https://nvd.nist.gov/vuln/detail/{VULNERABILITY_REFERENCE}"
        },
        recommendation="Ensure OpenSSH is updated to the latest version.",
        security_issue=True,
        privacy_issue=False,
        has_public_exploit=True,
        targeted_by_malware=False,
        targeted_by_ransomware=False,
        targeted_by_nation_state=False,
    )
    technical_detail = f"Target: {target.origin}:{target.port}\nDetails: {details}"
    vulnerability = definitions.Vulnerability(
        entry=entry,
        technical_detail=technical_detail,
        risk_rating=agent_report_vulnerability_mixin.RiskRating.CRITICAL,
    )
    return vulnerability


def _get_ssh_banner(ip_address: str, port: int) -> str:
    """Retrieves the SSH banner from the specified IP address and port.

    Args:
        ip_address: The IP address of the target.
        port: The port of the target.

    Returns:
        The SSH banner as a string, or an empty string if retrieval fails.
    """
    try:
        with socket.create_connection(
            (ip_address, port), timeout=DEFAULT_TIMEOUT
        ) as sock:
            sock.settimeout(2)
            banner = sock.recv(1024).decode().strip()
            return banner
    except socket.timeout as error:
        logger.error("Timeout error retrieving SSH banner: %s", error)
    except socket.error as error:
        logger.error("Socket error retrieving SSH banner: %s", error)
    except Exception as error:  # Explicit exception handling
        logger.error("Unexpected error retrieving SSH banner: %s", error)
    return ""


@exploits_registry.register
class OpenSSHExploit(definitions.Exploit):
    """Exploit class for detecting the OpenSSH Remote Code Execution Vulnerability."""

    def accept(self, target: definitions.Target) -> bool:
        """Checks if the target is potentially vulnerable based on its SSH banner.

        Args:
            target: The target to check.

        Returns:
            True if the target is potentially vulnerable, False otherwise.
        """
        ip_address = target.host
        port = target.port
        banner = _get_ssh_banner(ip_address, port)
        logger.debug("Retrieved banner for %s:%d - %s", ip_address, port, banner)

        if "OpenSSH" in banner:
            version = re.search(r"OpenSSH_(\d+\.\d+)", banner)
            if version:
                if version.group(1) in VULNERABLE_VERSIONS:
                    return True
        return False

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        """Checks the target for the specific vulnerability.

        Args:
            target: The target to scan.

        Returns:
            A list of identified vulnerabilities.
        """
        vulnerabilities = []
        if self.accept(target) is True:
            details = f"{target.origin} is vulnerable to {VULNERABILITY_REFERENCE}: {VULNERABILITY_TITLE}"
            vulnerability = _create_vulnerability(target, details)
            vulnerabilities.append(vulnerability)
        return vulnerabilities
