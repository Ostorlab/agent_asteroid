"""Agent Asteroid implementation for CVE-2024-28986"""

import re
from urllib import parse as urlparse

from requests import exceptions as requests_exceptions

from agent import definitions
from agent.exploits import webexploit
from agent import exploits_registry

VULNERABILITY_TITLE = "SolarWinds Web Help Desk 12.8.3 - Java Deserialization RCE"
VULNERABILITY_REFERENCE = "CVE-2024-28986"
VULNERABILITY_DESCRIPTION = (
    "Java deserialization remote code execution (RCE) vulnerability in SolarWinds Web Help Desk 12.8.3. "
    "This vulnerability allows remote, unauthenticated attackers to execute arbitrary code on the server by "
    "exploiting a deserialization flaw."
)
RISK_RATING = "CRITICAL"
MAX_VULNERABLE_VERSION = "12_8_3_0-HF1"

VERSION_PATTERN = re.compile(r"v=(\d+_\d+_\d+_\d+-HF\d+)")
DEFAULT_TIMEOUT = 90


def _parse_version(version_str: str) -> list[int]:
    """Parse version string into comparable parts."""
    parts = version_str.split("_")
    main_version = list(map(int, parts[:3]))
    build_number = int(parts[3].split("-")[0])
    hotfix = int(parts[3].split("-")[1][2:])
    return main_version + [build_number, hotfix]


def _is_version_less_or_equal(version1: str, version2: str) -> bool:
    """Compare two version strings."""
    return _parse_version(version1) <= _parse_version(version2)


@exploits_registry.register
class CVE202428986Exploit(webexploit.WebExploit):
    accept_request = definitions.Request(
        method="GET", path="/helpdesk/WebObjects/Helpdesk.woa"
    )
    check_request = definitions.Request(
        method="GET", path="/helpdesk/WebObjects/Helpdesk.woa"
    )
    accept_pattern = [re.compile(r"v=\d+_\d+_\d+_\d+-HF\d+")]
    metadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        risk_rating=RISK_RATING,
    )

    def accept(self, target: definitions.Target) -> bool:
        """Check if the target matches the accept pattern."""
        target_endpoint = urlparse.urljoin(target.origin, self.accept_request.path)
        try:
            response = self.session.get(target_endpoint, timeout=DEFAULT_TIMEOUT)
            response.raise_for_status()
            return any(pattern.search(response.text) for pattern in self.accept_pattern)
        except requests_exceptions.RequestException:
            return False

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        """Rule to detect specific vulnerability on a specific target."""
        vulnerabilities: list[definitions.Vulnerability] = []
        target_endpoint = urlparse.urljoin(target.origin, self.check_request.path)

        try:
            response = self.session.get(target_endpoint, timeout=DEFAULT_TIMEOUT)
            response.raise_for_status()
        except requests_exceptions.RequestException:
            return vulnerabilities

        version_match = VERSION_PATTERN.search(response.text)
        if version_match is not None:
            extracted_version = version_match.group(1)
            if _is_version_less_or_equal(extracted_version, MAX_VULNERABLE_VERSION):
                vulnerability = self.create_vulnerability(target)
                vulnerabilities.append(vulnerability)

        return vulnerabilities
