"""Agent implementation for detecting source code disclosure vulnerability in Apache HTTP Server."""

import os
import re
import logging

import pathlib
import cloudscraper
import semantic_version
from pygments import highlight
from pygments import lexers
from pygments import formatters
from ostorlab.agent.kb import kb
from ostorlab.agent.mixins import agent_report_vulnerability_mixin
from requests import exceptions as requests_exceptions

from agent import definitions
from agent import exploits_registry

EXTENSIONS = [".php", ".cfm", ".pl", ".asp", ".bat", ".cgi", ".js", ".inc", ".php3"]
VULNERABILITY_TITLE = "Source Code Disclosure in Apache HTTP Server"
VULNERABILITY_REFERENCE = "CVE-2024-40725"
VULNERABILITY_DESCRIPTION = (
    "A source code disclosure vulnerability in Apache HTTP Server 2.4.60 and 2.4.61 allows for the exposure of local "
    "content under certain circumstances. This issue affects the legacy content-type based configuration of handlers."
)
DEFAULT_TIMEOUT = 30

VULNERABLE_START = semantic_version.Version("2.4.60")
VULNERABLE_END = semantic_version.Version("2.4.61")

FILENAMES_PATH = pathlib.Path("Wordlists/filenames.txt").resolve()

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def _get_server_version(session: cloudscraper.CloudScraper, url: str) -> str | None:  # type: ignore[no-any-unimported]
    """Gets the server version from the given URL.

    Args:
        url: The URL to check.

    Returns:
        The server version string if found, else None.
    """
    try:
        response = session.head(url)
        server_header = response.headers.get("Server", "")
        if "Apache" in server_header:
            version_match = re.search(r"Apache/(\d+\.\d+\.\d+)", server_header)
            if version_match is not None:
                return version_match.group(1)
        return None
    except requests_exceptions.RequestException as e:
        logger.error("Error retrieving server version: %s", e)
        return None


def _is_version_vulnerable(version: str | None) -> bool:
    """Checks if the given version is vulnerable.

    Args:
        version: The version string to check.

    Returns:
        True if the version is vulnerable, else False.
    """
    if version is None:
        return False

    version_obj = semantic_version.Version(version)
    return bool(VULNERABLE_START <= version_obj <= VULNERABLE_END)


def _read_filenames(file_path: str) -> list[str]:
    """Reads the filenames from the given file path.

    Args:
        file_path: The path to the file containing filenames.

    Returns:
        A list of filenames.
    """
    logger.info("Current working directory: %s", os.getcwd())
    absolute_path = pathlib.Path(file_path)
    logger.info("Reading filenames from: %s", absolute_path)

    try:
        with open(absolute_path, "r") as file:
            return [line.strip() for line in file if line.strip()]
    except IOError as e:
        logger.error("Error reading file list: %s", e)
        return []


def _contains_code_content(content: str) -> bool:
    """Checks if the content contains actual code rather than just plain HTML.

    Args:
        content: The content to check.

    Returns:
        True if the content contains code, else False.
    """
    try:
        lexer = lexers.guess_lexer(content)
        if not isinstance(lexer, (lexers.HtmlLexer, lexers.CssLexer)):
            highlighted = highlight(content, lexer, formatters.TerminalFormatter())
            logger.info("%s", highlighted)
            return True
        return False
    except (TypeError, ValueError) as e:
        logger.error("Error determining code content: %s", e)
        return False


def _check_files(  # type: ignore[no-any-unimported]
    session: cloudscraper.CloudScraper, url: str, filenames: list[str]
) -> bool:
    """Checks the given files for source code disclosure.

    Args:
        url: The base URL to check.
        filenames: The list of filenames to check.

    Returns:
        True if source code disclosure is detected, else False.
    """
    for filename in filenames:
        file_url = url + filename
        try:
            response = session.get(file_url)
            if (
                any(file_url.endswith(ext) for ext in EXTENSIONS) is True
                and _contains_code_content(response.text) is True
            ):
                return True
        except requests_exceptions.HTTPError as e:
            logger.error("HTTP error checking file %s: %s", filename, e)
        except requests_exceptions.ConnectionError as e:
            logger.error("Connection error checking file %s: %s", filename, e)
        except requests_exceptions.Timeout as e:
            logger.error("Timeout error checking file %s: %s", filename, e)
        except requests_exceptions.RequestException as e:
            logger.error("Request error checking file %s: %s", filename, e)
    return False


def _create_vulnerability(target: definitions.Target) -> definitions.Vulnerability:
    """Creates and returns a vulnerability object for source code disclosure in Apache HTTP Server.

    Args:
        target: The target to create the vulnerability for.

    Returns:
        The created vulnerability object.
    """
    entry = kb.Entry(
        title=VULNERABILITY_TITLE,
        risk_rating="HIGH",
        short_description=VULNERABILITY_DESCRIPTION,
        description=VULNERABILITY_DESCRIPTION,
        references={
            "nvd.nist.gov": f"https://nvd.nist.gov/vuln/detail/{VULNERABILITY_REFERENCE}"
        },
        recommendation=(
            "Update to a version of Apache HTTP Server where this vulnerability is fixed."
        ),
        security_issue=True,
        privacy_issue=False,
        has_public_exploit=False,
        targeted_by_malware=False,
        targeted_by_ransomware=False,
        targeted_by_nation_state=False,
    )
    technical_detail = f"{target.origin} is vulnerable to {VULNERABILITY_REFERENCE}: {VULNERABILITY_TITLE}"
    vulnerability = definitions.Vulnerability(
        entry=entry,
        technical_detail=technical_detail,
        risk_rating=agent_report_vulnerability_mixin.RiskRating.HIGH,
    )
    return vulnerability


@exploits_registry.register
class ApacheSourceCodeDisclosureExploit(definitions.Exploit):
    """CVE-2024-40725: Source Code Disclosure in Apache HTTP Server."""

    def accept(self, target: definitions.Target) -> bool:
        """Checks if the target is running a vulnerable version of Apache HTTP Server.

        Args:
            target: The target to check.

        Returns:
            True if the target is running a vulnerable version, else False.
        """
        version = _get_server_version(self.session, target.origin)
        if version is not None:
            logger.info("Server version detected: Apache/%s", version)
            return _is_version_vulnerable(version)
        return False

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        """Checks for source code disclosure vulnerability in Apache HTTP Server.

        Args:
            target: The target to check.

        Returns:
            A list of vulnerabilities found.
        """
        filenames = _read_filenames(str(FILENAMES_PATH))
        if len(filenames) == 0:
            logger.warning(
                "No filenames to check. Please ensure filenames.txt exists and is correctly formatted."
            )
            return []

        vulnerabilities = []
        if _check_files(self.session, target.origin, filenames) is True:
            vulnerability = _create_vulnerability(target)
            vulnerabilities.append(vulnerability)
        else:
            logger.info("No source code disclosure detected with the tested files.")
        return vulnerabilities
