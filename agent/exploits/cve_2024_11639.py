"""Agent Asteroid implementation for CVE-2024-11639"""

import re
import logging
import datetime
from urllib import parse as urlparse

import requests
from requests import exceptions as requests_exceptions

from agent.exploits import webexploit
from agent import exploits_registry
from agent import definitions

VULNERABILITY_TITLE = "Authentication Bypass in Ivanti CSA Admin Console"
VULNERABILITY_REFERENCE = "CVE-2024-11639"
VULNERABILITY_DESCRIPTION = """An authentication bypass in the admin web console of Ivanti CSA before 5.0.3 allows a remote unauthenticated attacker to gain administrative access."""
RISK_RATING = "CRITICAL"

PATCH_DATE = datetime.datetime(
    2024, 12, 10, 17, 58, 17
)  # Based on Last Modified Date in advisory

DEFAULT_TIMEOUT = 90
HEADER_LAST_MODIFIED = "Last-Modified"


@exploits_registry.register
class CVE202411639Exploit(webexploit.WebExploit):
    accept_request = definitions.Request(method="GET", path="/")
    check_request = definitions.Request(method="GET", path="/allowed/ivanti-logo.png")
    accept_pattern = [
        re.compile(r"<title>Ivanti\(R\) Cloud Services Appliance</title>")
    ]
    metadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        risk_rating=RISK_RATING,
    )

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        """Rule to detect specific vulnerability on a specific target.

        Args:
            target: Target to scan

        Returns:
            List of identified vulnerabilities.
        """
        target_endpoint = urlparse.urljoin(target.origin, self.check_request.path)

        try:
            req = requests.Request(
                method=self.check_request.method,
                url=target_endpoint,
            ).prepare()
            resp = self.session.send(req, timeout=DEFAULT_TIMEOUT)
        except requests_exceptions.RequestException as e:
            logging.error("HTTP Request failed: %s", e)
            return []

        if HEADER_LAST_MODIFIED not in resp.headers:
            return []

        try:
            last_modified = datetime.datetime.strptime(
                resp.headers[HEADER_LAST_MODIFIED], "%a, %d %b %Y %H:%M:%S %Z"
            )
        except ValueError as e:
            logging.error("Couldn't parse date string and format: %s", e)
            return []

        if last_modified < PATCH_DATE:
            vulnerability = self.create_vulnerability(target)
            return [vulnerability]
        else:
            return []
