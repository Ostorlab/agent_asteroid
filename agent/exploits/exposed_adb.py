"""Agent Asteroid implementation to detect unauthenticated exposed adb"""
import socket

from adb_shell import adb_device
from adb_shell import exceptions as adb_exceptions
from ostorlab.agent.kb import kb
from ostorlab.agent.mixins import agent_report_vulnerability_mixin

from agent import definitions
from agent import exploits_registry

VULNERABILITY_TITLE = "Unauthenticated exposed Android Debug Bridge (ADB)"
VULNERABILITY_REFERENCE = "N/A"
VULNERABILITY_DESCRIPTION = (
    "Android Debug Bridge (ADB) remove debugging is a feature helping app developers communicate "
    "with Android devices remotely to execute commands and, if necessary, completely control a "
    "device. If left enabled, unauthorized remote attackers can leverage it to remotely and "
    "silently install malware on user devices."
)

DEFAULT_TIMEOUT = 90
ADB_PORT = 5555
KEYWORD = "__VULNERABLE__"

ADB_TCP_EXCEPTIONS = (
    socket.error,
    adb_exceptions.DeviceAuthError,
    adb_exceptions.TcpTimeoutException,
    adb_exceptions.AdbTimeoutError,
)
ADB_COMMAND_EXCEPTIONS = (
    adb_exceptions.AdbCommandFailureException,
    adb_exceptions.InvalidCommandError,
)


@exploits_registry.register
class ExposedAdbExploit(definitions.Exploit):
    """Unauthenticated Exposed ADB Access."""

    def accept(self, target: definitions.Target) -> bool:
        if target.port != ADB_PORT:
            return False

        device = adb_device.AdbDeviceTcp(
            target.host, target.port, default_transport_timeout_s=DEFAULT_TIMEOUT
        )
        try:
            connection_status = device.connect(auth_timeout_s=DEFAULT_TIMEOUT)
        except ADB_TCP_EXCEPTIONS:
            return False
        return connection_status is True

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        device = adb_device.AdbDeviceTcp(
            target.host, target.port, default_transport_timeout_s=DEFAULT_TIMEOUT
        )
        try:
            device.connect(auth_timeout_s=DEFAULT_TIMEOUT)
        except ADB_TCP_EXCEPTIONS:
            return []

        try:
            command_output = device.shell(
                f"echo {KEYWORD}", timeout_s=DEFAULT_TIMEOUT
            ).strip()
        except ADB_TCP_EXCEPTIONS:
            return []
        except ADB_COMMAND_EXCEPTIONS:
            return []

        if command_output != KEYWORD:
            return []

        vulnerability = self._generate_vulnerability_object(target)
        return [vulnerability]

    def _generate_vulnerability_object(
        self, target: definitions.Target
    ) -> definitions.Vulnerability:
        entry = kb.Entry(
            title=VULNERABILITY_TITLE,
            risk_rating="CRITICAL",
            short_description=VULNERABILITY_DESCRIPTION,
            description=VULNERABILITY_DESCRIPTION,
            references={
                "developer.android.com": "https://developer.android.com/tools/adb",
                "westoahu.hawaii.edu": "https://westoahu.hawaii.edu/cyber/vulnerability-research/"
                "vulnerabilities-weekly-summaries/adb-miner-a-silent-outbreak-of-mining/",
            },
            recommendation=(
                "- Make sure to install the latest security patches from software vendor \n"
                "- Update to the latest software version"
            ),
            security_issue=True,
            privacy_issue=False,
            has_public_exploit=True,
            targeted_by_malware=True,
            targeted_by_ransomware=True,
            targeted_by_nation_state=True,
        )
        technical_detail = (
            f"{target.host}:{target.port} is vulnerable to {VULNERABILITY_TITLE}."
        )
        vulnerability = definitions.Vulnerability(
            entry=entry,
            technical_detail=technical_detail,
            risk_rating=agent_report_vulnerability_mixin.RiskRating.CRITICAL,
        )
        return vulnerability
