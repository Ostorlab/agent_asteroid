"""Agent Asteroid implementation for CVE-2018-14667"""

import re

from requests import exceptions as requests_exceptions
from ostorlab.agent.kb import kb
from ostorlab.agent.mixins import agent_report_vulnerability_mixin
from packaging import version

from agent import definitions
from agent import exploits_registry

VULNERABILITY_TITLE = (
    "Red Hat JBoss RichFaces Framework Expression Language Injection Vulnerability"
)
VULNERABILITY_REFERENCE = "CVE-2018-14667"
VULNERABILITY_DESCRIPTION = (
    "The RichFaces Framework 3.X through 3.3.4 is vulnerable to Expression Language (EL) injection "
    "via the UserResource resource. A remote, unauthenticated attacker could exploit this to execute "
    "arbitrary code using a chain of java serialized objects via org.ajax4jsf.resource.UserResource$UriData."
)

DEFAULT_TIMEOUT = 90
JST_PATTERN = re.compile(r"JSF/(.*)")
UPPER_VULNERABLE_VERSION = version.parse("3.3.4")
VERSION_PATTERN = re.compile(r'href="/a4j/s/(\d+_\d+_\d+)\.Final')
MAX_REDIRECTS = 2


@exploits_registry.register
class CVE201814667Exploit(definitions.Exploit):
    """
    CVE-2018-14667: Red Hat JBoss RichFaces Framework Expression Language Injection Vulnerability
    """

    def accept(self, target: definitions.Target) -> bool:
        try:
            resp = self.session.get(target.origin, timeout=DEFAULT_TIMEOUT)
        except requests_exceptions.RequestException:
            return False

        if resp.status_code != 200:
            return False

        jsf_header = resp.headers.get("X-Powered-By", "Unknown")

        return JST_PATTERN.search(jsf_header) is not None

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        try:
            resp = self.session.get(
                target.origin,
                timeout=DEFAULT_TIMEOUT,
            )
        except requests_exceptions.RequestException:
            return []

        if resp.status_code != 200:
            return []

        version_match = VERSION_PATTERN.search(resp.text)
        if version_match is None:
            return []
        target_version = version.parse(version_match.group(1).replace("_", "."))
        if target_version <= UPPER_VULNERABLE_VERSION:
            vulnerability = self._create_vulnerability(target.origin)
            return [vulnerability]
        else:
            return []

    def _create_vulnerability(self, target_uri: str) -> definitions.Vulnerability:
        entry = kb.Entry(
            title=VULNERABILITY_TITLE,
            risk_rating="CRITICAL",
            short_description=VULNERABILITY_DESCRIPTION,
            description=VULNERABILITY_DESCRIPTION,
            references={
                "nvd.nist.gov": f"https://nvd.nist.gov/vuln/detail/{VULNERABILITY_REFERENCE}",
                "github.com": "https://github.com/syriusbughunt/CVE-2018-14667",
            },
            recommendation=(
                "- Make sure to install the latest security patches from software vendor \n"
                "- Update to the latest software version"
            ),
            security_issue=True,
            privacy_issue=False,
            has_public_exploit=True,
            targeted_by_malware=True,
            targeted_by_ransomware=True,
            targeted_by_nation_state=True,
        )
        technical_detail = (
            f"{target_uri} is vulnerable to {VULNERABILITY_REFERENCE}, "
            f"{VULNERABILITY_TITLE}"
        )
        vulnerability = definitions.Vulnerability(
            entry=entry,
            technical_detail=technical_detail,
            risk_rating=agent_report_vulnerability_mixin.RiskRating.CRITICAL,
        )
        return vulnerability
