"""Agent Asteroid implementation for CVE-2024-51479"""

import re
import datetime

import requests
from packaging import version

from agent import definitions
from agent import exploits_registry
from agent.exploits import webexploit

DEFAULT_TIMEOUT = datetime.timedelta(seconds=90)

VULNERABILITY_TITLE = "Next.js Authorization Bypass via Middleware"
VULNERABILITY_REFERENCE = "CVE-2024-51479"
VULNERABILITY_DESCRIPTION = (
    "A recently disclosed security vulnerability in Next.js, a popular React framework used by millions of developers worldwide, "
    "could have allowed unauthorized access to sensitive application data. The vulnerability stemmed from an authorization bypass issue "
    "in Next.js middleware when performing authorization checks based on pathname. This affected versions 9.5.5 through 14.2.14 and allowed "
    "unauthorized access to pages under the root directory of an application."
)
RISK_RATING = "HIGH"

CHUNK_FILE_PATTERN = re.compile(
    r'<script src="(/_next/static/chunks/main-[a-zA-Z0-9-]+\.js)" defer=""></script>'
)
VERSION_PATTERN = re.compile(r't\.version="(\d+\.\d+(?:\.\d+)?)"')
MAX_VULNERABLE_VERSION = version.parse("14.2.14")
MIN_VULNERABLE_VERSION = version.parse("9.5.5")


def _fetch_chunk_file(target_url: str, chunk_path: str) -> str | None:
    """
    Fetches the JavaScript chunk file to extract the version information.

    Args:
        target_url: The base URL of the target application.
        chunk_path: The path to the chunk file.

    Returns:
        The content of the chunk file, if accessible, or an empty string.
    """
    try:
        full_url = f"{target_url}{chunk_path}"
        response = requests.get(full_url, timeout=DEFAULT_TIMEOUT.seconds, verify=False)
        if response.status_code == 200:
            return response.text
    except requests.RequestException:
        pass

    return None


def _extract_version(chunk_content: str) -> str | None:
    """
    Extracts the Next.js version from the chunk file content.

    Args:
        chunk_content: The content of the fetched chunk file.

    Returns:
        The extracted version string, if found, or None.
    """
    match = VERSION_PATTERN.search(chunk_content)
    if match is not None:
        return match.group(1)
    return None


@exploits_registry.register
class CVE202451479Exploit(webexploit.WebExploit):
    accept_request = definitions.Request(method="GET", path="/")
    accept_pattern = [re.compile(r"/_next/static")]

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        vulnerabilities: list[definitions.Vulnerability] = []

        root_response = requests.get(
            target.origin, timeout=DEFAULT_TIMEOUT.seconds, verify=False
        )
        if root_response.status_code != 200:
            return vulnerabilities

        chunk_match = CHUNK_FILE_PATTERN.search(root_response.text)
        if chunk_match is None:
            return vulnerabilities

        chunk_path = chunk_match.group(1)
        chunk_content = _fetch_chunk_file(target.origin, chunk_path)

        if chunk_content is not None:
            extracted_version = _extract_version(chunk_content)
            if (
                extracted_version is not None
                and MIN_VULNERABLE_VERSION
                <= version.parse(extracted_version)
                <= MAX_VULNERABLE_VERSION
            ):
                vulnerability = self.create_vulnerability(target)
                vulnerabilities.append(vulnerability)

        return vulnerabilities

    metadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        risk_rating=RISK_RATING,
        cve_ids=["CVE-2024-51479"],
    )
